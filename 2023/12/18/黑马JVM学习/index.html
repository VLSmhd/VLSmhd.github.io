<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>黑马JVM学习 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM内存结构 程序计数器 Program Counter Register 程序计数器（寄存器） 作用：是记录下一条 jvm 指令的执行地址行号。 特点：  线程私有 不会溢出  如下是一段字节码指令，注释对应的具体的代码块： 1234567891011121314151617180: getstatic #20 &#x2F;&#x2F; PrintStream out &#x3D; System.out">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马JVM学习">
<meta property="og:url" content="https://vlsmhd.github.io/2023/12/18/%E9%BB%91%E9%A9%ACJVM%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="JVM内存结构 程序计数器 Program Counter Register 程序计数器（寄存器） 作用：是记录下一条 jvm 指令的执行地址行号。 特点：  线程私有 不会溢出  如下是一段字节码指令，注释对应的具体的代码块： 1234567891011121314151617180: getstatic #20 &#x2F;&#x2F; PrintStream out &#x3D; System.out">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-12-18T02:10:13.777Z">
<meta property="article:modified_time" content="2024-03-14T02:02:05.630Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2023/12/18/%E9%BB%91%E9%A9%ACJVM%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马JVM学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-14 10:02:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">黑马JVM学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-18T02:10:13.777Z" title="发表于 2023-12-18 10:10:13">2023-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-14T02:02:05.630Z" title="更新于 2024-03-14 10:02:05">2024-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="黑马JVM学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="jvm内存结构">JVM内存结构</h1>
<h2 id="程序计数器">程序计数器</h2>
<p>Program Counter Register 程序计数器（寄存器）</p>
<p>作用：是<strong>记录下一条 jvm 指令</strong>的执行地址行号。</p>
<p>特点：</p>
<ul>
<li>线程私有</li>
<li>不会溢出</li>
</ul>
<p>如下是一段字节码指令，注释对应的具体的代码块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic <span class="comment">#20 // PrintStream out = System.out; </span></span><br><span class="line">3: astore_1 // -- </span><br><span class="line">4: aload_1 // out.println(1); </span><br><span class="line">5: iconst_1 // -- </span><br><span class="line">6: invokevirtual <span class="comment">#26 // -- </span></span><br><span class="line">9: aload_1 // out.println(2); </span><br><span class="line">10: iconst_2 // -- </span><br><span class="line">11: invokevirtual <span class="comment">#26 // -- </span></span><br><span class="line">14: aload_1 // out.println(3); </span><br><span class="line">15: iconst_3 // -- </span><br><span class="line">16: invokevirtual <span class="comment">#26 // -- </span></span><br><span class="line">19: aload_1 // out.println(4); </span><br><span class="line">20: iconst_4 // -- </span><br><span class="line">21: invokevirtual <span class="comment">#26 // -- </span></span><br><span class="line">24: aload_1 // out.println(5); </span><br><span class="line">25: iconst_5 // -- </span><br><span class="line">26: invokevirtual <span class="comment">#26 // -- </span></span><br><span class="line">29: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以上这些指令，存储在CPU的寄存器中；程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li>
<li><strong>解释器</strong>会解释以上这些指令为机器码交给 cpu 执行</li>
</ul>
<h2 id="虚拟机栈">虚拟机栈</h2>
<p>概念：</p>
<ul>
<li>栈：每个线程运行时需要的内存空间，就叫虚拟机栈；每个线程独有一份；每个线程有一个活动栈帧，只能执行一个方法
<ul>
<li>栈帧：栈内有多个栈帧，每个栈帧对应一个方法，里面存储了方法的局部变量等</li>
</ul></li>
</ul>
<p>常见问题</p>
<ol type="1">
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<p>​ 不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p>
<ol start="2" type="1">
<li>栈内存分配越大越好吗？</li>
</ol>
<p>​
不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p>
<ol start="3" type="1">
<li>方法里的局部变量是否线程安全
<ul>
<li>局部变量逃离了方法的作用范围，就会有。例如：引用传参、返回值、外部引用等等</li>
</ul></li>
</ol>
<p>​</p>
<h3 id="stackoverflow">StackOverFlow</h3>
<p><strong>出现情况</strong></p>
<ol type="1">
<li>栈帧过大</li>
<li>递归调用</li>
<li>第三方类库引用：如循环引用</li>
</ol>
<h3 id="线程运行诊断">线程运行诊断</h3>
<h4 id="cpu占用分析">CPU占用分析</h4>
<p>Linux 环境下运行某些程序的时候，可能导致 CPU
的占用过高，这时需要定位占用 CPU 过高的线程</p>
<ol type="1">
<li>top命令，查看是哪个进程占用 CPU
过高；记住进程号pid，用于下面命令</li>
<li><code>ps H -eo pid,tid,%cpu | grep</code>，通过 ps
命令进一步查看是哪个线程占用 CPU 过高</li>
<li>利用<code>jstack pid</code>，找到对应的线程，查看执行情况</li>
</ol>
<h4 id="死锁分析">死锁分析</h4>
<p>通过jstack命令定位。</p>
<p>找到两个线程对应的执行代码位置。</p>
<h2 id="本地方法栈">本地方法栈</h2>
<p>一些带有 native 关键字的方法就是需要 JAVA
去调用本地的C或者C++方法，因为 JAVA
有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带
native 关键字的方法。</p>
<h2 id="堆">堆</h2>
<p>存放对象：通过new关键字创建的对象都会被放在堆内存</p>
<p>特点：</p>
<ul>
<li>线程共享</li>
<li>有gc机制</li>
</ul>
<h3 id="堆内存溢出">堆内存溢出</h3>
<p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出</p>
<ul>
<li>可以使用 -Xmx 来指定堆内存大小</li>
</ul>
<h3 id="堆内存诊断">堆内存诊断</h3>
<ol type="1">
<li>jps 工具 查看当前系统中有哪些 java 进程</li>
<li>jmap 工具 查看堆内存占用情况 <code>jmap - heap 进程id</code></li>
<li>jconsole 工具 图形界面的，多功能的监测工具，可以连续监测</li>
<li>jvisualvm 工具</li>
</ol>
<h3 id="stringtable">StringTable</h3>
<p>定义：是一个记录字符督串的常量表（哈希表），
可利用这样一个串池，避免重复创建相同的字符串对象。</p>
<ul>
<li>常量池中的字符串仅是符号，符合懒加载机制，被用到以后会转化为字符串对象</li>
<li>字符串<strong>对象</strong>拼接的原理：StringBuilder</li>
<li>字符串<strong>常量</strong>拼接的原理：编译器优化。编译时期将字符串合并</li>
<li>使用intern方法，主动将不在串池中的字符串对象放入串池中</li>
</ul>
<p>是否会垃圾回收：是</p>
<h4 id="intern方法">intern方法</h4>
<p>1.8版本：调用字符串对象的 intern
方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败；无论放入是否成功，都会<strong>返回串池中</strong>的字符串对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中  </span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//此时串池[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">		<span class="comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();<span class="comment">//此时串池[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;(指向堆中&quot;ab&quot;对象)]</span></span><br><span class="line">		<span class="comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		<span class="comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span></span><br><span class="line">		System.out.println(str == str2);</span><br><span class="line">		System.out.println(str == str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用关系：str2 -&gt; str（串池） -&gt; "ab"（堆中） str3 -&gt;
str</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">//此时串池[&quot;ab&quot;]</span></span><br><span class="line">        <span class="comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//此时串池[&quot;ab&quot; ,&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">        <span class="comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">        <span class="comment">// false</span></span><br><span class="line">		System.out.println(str == str2);</span><br><span class="line">        <span class="comment">// false</span></span><br><span class="line">		System.out.println(str == str3);</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">		System.out.println(str2 == str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用关系： str2 -&gt; str3(串池) -&gt; "ab"(1) str -&gt;
"ab"(2)</li>
</ul>
<h4 id="位置">位置</h4>
<p>1.8版本：</p>
<p><img src="image-20231223132738881.png" alt="image-20231223132738881" style="zoom:80%;" /></p>
<p>1.6版本以下：</p>
<p><img src="image-20231223132804083.png" alt="image-20231223132804083" style="zoom:80%;" /></p>
<h4 id="调优">调优</h4>
<p>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=桶个数（最少设置为 1009 以上）</span><br></pre></td></tr></table></figure>
<h2 id="方法区">方法区</h2>
<p>Java 虚拟机有一个在所有 Java
虚拟机<strong>线程之间共享</strong>的方法区域。方法区域类似于
用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的 “文本”
段。</p>
<ul>
<li>内容：它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化</li>
<li>创建时机：方法区域是在虚拟机启动时创建的。</li>
<li>实现：尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！
不同的虚拟机有不同的实现</li>
</ul>
<figure>
<img src="image-20231222114529710.png" alt="方法区" />
<figcaption aria-hidden="true">方法区</figcaption>
</figure>
<h3 id="运行时常量池">运行时常量池</h3>
<p>二进制字节码包含（类的基本信息，<strong>常量池</strong>，类方法定义，包含了虚拟机的指令）</p>
<p>反编译如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-17032216964146.png" alt="字节码-代码指令" style="zoom:80%;" /></p>
<ul>
<li>红框内的就是在常量表中的地址</li>
</ul>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-17032216494603.png" alt="字节码-常量池表" style="zoom:80%;" /></p>
<p><strong>常量池</strong></p>
<p>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p>
<p><strong>运行时常量池</strong></p>
<p>常量池是 *.class
文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>
<h2 id="直接内存">直接内存</h2>
<p>应用场景：NIO 操作时，用于数据缓冲区bytebuffer</p>
<p>特点：</p>
<ul>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM垃圾回收管理</li>
</ul>
<h3 id="优势-文件读写">优势-文件读写</h3>
<p>正常文件读写流程</p>
<p><img src="image-20231224103120537.png" alt="image-20231224103120537" style="zoom:80%;" /></p>
<p>因为 java
不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区，
然后在将系统缓冲区数据，复制到 java
堆内存中。缺点是数据存储了两份，在系统内存中有一份，java
堆中有一份，造成了不必要的复制。</p>
<p><strong>使用了 DirectBuffer 文件读取流程</strong></p>
<p><img src="image-20231224103633606.png" alt="image-20231224103633606" style="zoom:67%;" /></p>
<p>直接内存是<strong>操作系统和 Java
程序共享的一块区域</strong>，无需将代码从系统内存复制到 Java
堆内存，从而提高了效率。</p>
<h3 id="回收原理">回收原理</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_06_DirectMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        method();</span></span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存 是被 unsafe 创建与回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)field.get(Unsafe.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base,_1GB, (<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存被 释放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 手动 gc   才能释放byteBuffer虚引用，这样真正的内存不被引用，就可以用unsafe释放</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接内存的回收不通过gc垃圾回收，是通过unsafe.freeMemory
来手动释放</p>
<p><strong>Bytebuffer底层实现</strong></p>
<ol type="1">
<li><p>allocateDirect 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">//创建这个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DirectByteBuffer 类</p></li>
</ol>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象(bytebuffer), 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li><p>Cleaner.create方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleaner</span> <span class="keyword">extends</span> <span class="title class_">PhantomReference</span>&lt;Object&gt; </span><br></pre></td></tr></table></figure>
<p>这个方法是<strong>创建一个虚引用的对象</strong>，底层是一个双向链表连起来；</p>
<p>虚拟机后台会对虚引用的对象监测，如果虚引用的实际对象（这里是
DirectByteBuffer ）被回收以后就会调用 Cleaner 的 clean
方法，来清除直接内存中占用的内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//如果remove成功，调用thunk线程的run方法执行，这个run方法是前面DirectByteBuffer的构造方法传入进来，通过Cleaner.create方法传入</span></span><br><span class="line">               <span class="built_in">this</span>.thunk.run();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">   </span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//真正从链表中移除</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Cleaner var0)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (var0.next == var0) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (first == var0) &#123;</span><br><span class="line">               <span class="keyword">if</span> (var0.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                   first = var0.next;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   first = var0.prev;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">if</span> (var0.next != <span class="literal">null</span>) &#123;</span><br><span class="line">               var0.next.prev = var0.prev;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">if</span> (var0.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">               var0.prev.next = var0.next;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           var0.next = var0;</span><br><span class="line">           var0.prev = var0;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this.thunk.run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deallocator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> address;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> size;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Deallocator</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> size, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.address = address;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//真正执行回收的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Paranoia</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.freeMemory(address);</span><br><span class="line">            address = <span class="number">0</span>;</span><br><span class="line">            Bits.unreserveMemory(size, capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="禁用显示回收">禁用显示回收</h3>
<p>System.gc()方法，在jvm调优的时候尽量设置 -XX:+DisableExplicitGC</p>
<h1 id="gc垃圾回收机制">GC垃圾回收机制</h1>
<p>JVM之所以能够帮我们管理对象的回收操作，不用我们手动释放对象的内存，就是靠JVM的垃圾回收。</p>
<h2 id="判断回收条件">判断回收条件</h2>
<h3 id="引用计数法">引用计数法</h3>
<p>概念：当一个对象被引用时，这个对象的引用计数器 +
1，值为0表示不在被引用，直接清除</p>
<p>缺陷：循环引用问题</p>
<p><img src="image-20231225103144019.png" alt="image-20231225103144019" style="zoom:80%;" /></p>
<ul>
<li>两个对象的计数都为1，导致两个对象都无法被释放。</li>
</ul>
<h4 id="种引用类型">5种引用类型</h4>
<p><img src="image-20231226102624330.png" alt="image-20231226102624330" style="zoom: 67%;" /></p>
<h5 id="强引用">强引用</h5>
<p>所有 GC Roots
对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p>
<h5 id="软引用">软引用</h5>
<p>仅有软引用引用该对象时，在垃圾回收后，内存<strong>仍不足</strong>时会再次出发垃圾回收，回收软引用对象，可以配合引用队列来释放软引用自身</p>
<h5 id="弱引用">弱引用</h5>
<p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象，可以配合引用队列来释放弱引用自身。</p>
<h6 id="threadlocal内存泄露">ThreadLocal内存泄露</h6>
<figure>
<img src="v2-50b25a5f65fe02d6eebe27801a94c833_720w.webp"
alt="ThreadLocal引用" />
<figcaption aria-hidden="true">ThreadLocal引用</figcaption>
</figure>
<p>线程内部实际拥有的是Entry，ThreadLocal只是对这个Entry的K的一个引用，但是获取这个Entry的Value的途径还是通过K获取。</p>
<p><strong>突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap（thread
的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。</strong></p>
<h5 id="虚引用">虚引用</h5>
<p><strong>必须配合引用队列使用</strong>，主要配合 ByteBuffer
使用，被引用对象回收时，会将虚引用入队，由 Reference Handler
线程调用虚引用相关方法释放直接内存</p>
<h5 id="终结器引用">终结器引用</h5>
<p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由
Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize（已重写）
方法，第二次 GC 时才能回收被引用对象。</p>
<h3 id="可达性分析法">可达性分析法</h3>
<p>JVM 中的垃圾回收器通过可达性分析来探索所有存活的对象。</p>
<p>jvm会定时去搜索扫描堆中的对象，沿着GC
root的引用链搜寻，搜寻到的对象不被清除，没有搜寻到也就是没有被GC
root引用链串起来的对象会被垃圾回收。</p>
<h4 id="可以作为gc-root的对象">可以作为GC root的对象</h4>
<ul>
<li><strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类<strong>静态属性</strong>引用的对象</li>
<li>方法区中<strong>常量</strong>引用的对象</li>
<li>本地方法栈中
JNI（即一般说的<strong>Native方法</strong>）引用的对象</li>
</ul>
<h5 id="eclipse-memory-analyzer工具查看">Eclipse Memory
Analyzer工具查看</h5>
<ol type="1">
<li><p>使用 jps 命令，查看程序的进程</p></li>
<li><p>使用 <code>jmap -dump:format=b,live,file=1.bin 进程id</code>
命令转储文件</p>
<ul>
<li>dump：转储文件</li>
<li>format=b：二进制文件</li>
<li>file：文件名</li>
</ul></li>
<li><p>打开 Eclipse Memory Analyzer 对 1.bin 文件进行分析</p>
<figure>
<img src="image-20231225103710405.png" alt="image-20231225103710405" />
<figcaption aria-hidden="true">image-20231225103710405</figcaption>
</figure></li>
</ol>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<h3 id="标记-清除">标记-清除</h3>
<p>对标记的对象直接清除</p>
<p>优点：</p>
<ul>
<li>速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>会产生内存碎片</li>
</ul>
<p><img src="image-20231227111055176.png" alt="image-20231227111055176" style="zoom:67%;" /></p>
<h3 id="标记-整理">标记-整理</h3>
<p>清除完之后，会把存活的对象的内存地址重新整理，排列整齐，保证不出现内存碎片问题，但是效率比较慢。</p>
<p>存活对象比较多的话，整理起来耗时，占用CPU，甚至出现用户程序阻塞的问题。</p>
<p><img src="image-20231227111237657.png" alt="image-20231227111237657" style="zoom:67%;" /></p>
<h3 id="标记-复制">标记-复制</h3>
<p>一种空间换时间的思想，两段空间，省去了整理对象的用时，同时能保证对象复制到另一半内存空间之后不会产生内存碎片。</p>
<figure>
<img src="image-20231227111408977.png" alt="image-20231227111408977" />
<figcaption aria-hidden="true">image-20231227111408977</figcaption>
</figure>
<h3 id="分代回收">分代回收</h3>
<figure>
<img src="image-20231228195330497.png" alt="image-20231228195330497" />
<figcaption aria-hidden="true">image-20231228195330497</figcaption>
</figure>
<ol type="1">
<li>新的对象首先分配在eden区 ，其中
新生代区域还包括幸存区（from、to）</li>
<li>新生代空间不足时，触发minor gc
<ul>
<li>Minor GC： 把eden区和from区存活的对象移动到to区，并且对应的存活年龄
+ 1</li>
<li>引发stop the
world：暂停其他线程，等垃圾回收结束后，恢复用户线程运行</li>
<li>存活年龄：用四个比特位标识，最大15，当年龄到达15就会被送到老年代</li>
</ul></li>
<li>当老年代空间不足时，会先触发 minor gc，如果空间仍然不足，那么就触发
full gc ，STW停止的时间更长。</li>
<li>当最后一次full
GC以后，老年代依旧没内存，整个内存空间满了，就会触发OOM异常</li>
</ol>
<h3 id="gc调优参数">GC调优参数</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">含义</th>
<th style="text-align: center;">参数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">堆初始大小</td>
<td style="text-align: center;">-Xms</td>
</tr>
<tr class="even">
<td style="text-align: center;">堆最大大小</td>
<td style="text-align: center;">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr class="odd">
<td style="text-align: center;">新生代大小</td>
<td style="text-align: center;">-Xmn 或 (-XX:NewSize=size +
-XX:MaxNewSize=size )</td>
</tr>
<tr class="even">
<td style="text-align: center;">幸存区比例（动态）</td>
<td style="text-align: center;">-XX:InitialSurvivorRatio=ratio 和
-XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr class="odd">
<td style="text-align: center;">幸存区比例</td>
<td style="text-align: center;">-XX:SurvivorRatio=ratio</td>
</tr>
<tr class="even">
<td style="text-align: center;">晋升阈值</td>
<td style="text-align: center;">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr class="odd">
<td style="text-align: center;">晋升详情</td>
<td style="text-align: center;">-XX:+PrintTenuringDistribution</td>
</tr>
<tr class="even">
<td style="text-align: center;">GC详情</td>
<td style="text-align: center;">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr class="odd">
<td style="text-align: center;">FullGC 前 MinorGC</td>
<td style="text-align: center;">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<h2 id="垃圾回收器">垃圾回收器</h2>
<p>指标：</p>
<ul>
<li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li>
<li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个
CPU 上</li>
<li>吞吐量：即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值
<ul>
<li><code>吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )</code>，也就是。例如：虚拟机共运行
100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</li>
</ul></li>
</ul>
<h3 id="串行">串行</h3>
<p>适用场景：</p>
<ul>
<li>单线程</li>
<li>堆内存较少，适合个人电脑</li>
</ul>
<figure>
<img src="image-20231230171402073.png" alt="image-20231230171402073" />
<figcaption aria-hidden="true">image-20231230171402073</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//老年代新生代都采用</span><br><span class="line">-XX:+UseSerialGC=serial + serialOld</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>安全：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</li>
<li>阻塞：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</li>
</ul>
<p><strong>Serial 收集器</strong> Serial
收集器是最基本的、发展历史最悠久的收集器
特点：单线程、简单高效（与其他收集器的单线程相比），采用标记-复制算法。对于限定单个
CPU 的环境来说，Serial
收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop
The World）</p>
<p><strong>ParNew 收集器</strong> ParNew 收集器其实就是 Serial
收集器的多线程版本 特点：多线程、ParNew
收集器默认开启的收集线程数与CPU的数量相同，在 CPU
非常多的环境中，可以使用 -XX:ParallelGCThreads
参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World
问题</p>
<p><strong>Serial Old 收集器</strong> Serial Old 是 Serial
收集器的老年代版本 特点：同样是单线程收集器，采用标记-整理算法</p>
<h3 id="吞吐量优先">吞吐量优先</h3>
<p>适用场景：</p>
<ul>
<li>多线程</li>
<li>适用于堆内存较大，多核 cpu</li>
<li>目的：让单位时间内，STW 的时间最短</li>
</ul>
<figure>
<img src="image-20231230173848573.png" alt="image-20231230173848573" />
<figcaption aria-hidden="true">image-20231230173848573</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC ~ -XX:+UsePrallerOldGC</span><br><span class="line">-XX:+UseAdaptiveSizePolicy</span><br><span class="line">-XX:GCTimeRatio=ratio // 1/(1+radio)</span><br><span class="line">-XX:MaxGCPauseMillis=ms // 200ms</span><br><span class="line">-XX:ParallelGCThreads=n</span><br></pre></td></tr></table></figure>
<p><strong>Parallel Scavenge 收集器</strong>
与吞吐量关系密切，故也称为吞吐量优先收集器
特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与
ParNew 收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与
ParNew 收集器最重要的一个区别）</p>
<ul>
<li>GC自适应调节策略：Parallel Scavenge 收集器可设置
-XX:+UseAdptiveSizePolicy
参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor
区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为
GC 的自适应调节策略。</li>
</ul>
<p>Parallel Scavenge 收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis=ms 控制最大的垃圾收集停顿时间（默认200ms）</li>
<li>XX:GCTimeRatio=rario 直接设置吞吐量的大小</li>
</ul>
<p><strong>Parallel Old 收集器</strong></p>
<ul>
<li>是 Parallel Scavenge 收集器的老年代版本</li>
<li>特点：多线程，采用标记-整理算法（老年代没有幸存区）</li>
</ul>
<h3 id="响应时间优先">响应时间优先</h3>
<p>特点：</p>
<ul>
<li>多线程</li>
<li>适用于堆内存较大，多核 cpu</li>
<li>尽可能让 STW 的单次时间最短</li>
</ul>
<figure>
<img src="image-20231230174314031.png" alt="image-20231230174314031" />
<figcaption aria-hidden="true">image-20231230174314031</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure>
<h4 id="cms-收集器">CMS 收集器</h4>
<p>Concurrent Mark
Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</p>
<p>特点：</p>
<ul>
<li>基于标记-清除算法实现。</li>
<li>并发收集、低停顿，但是会产生内存碎片</li>
</ul>
<p>应用场景：适用于注重服务的<strong>响应</strong>速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如
web 程序、b/s 服务</p>
<p>CMS 收集器的运行过程分为下列4步：</p>
<ol type="1">
<li>初始标记：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The
World 问题。</li>
<li>并发标记：进行 GC Roots Tracing
的过程，找出存活对象且用户线程可并发执行。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在
Stop The World 问题</li>
<li>并发清除：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为
serial Old
收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的</li>
</ol>
<p>CMS 收集器的内存回收过程是与用户线程一起并发执行的，可以搭配 ParNew
收集器（多线程，新生代，复制算法）与 Serial Old
收集器（单线程，老年代，标记-整理算法）使用。</p>
<h3 id="g1">G1</h3>
<p><strong>特征</strong></p>
<ul>
<li>同时注重<strong>吞吐量</strong>和<strong>低延迟</strong>（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域Region</li>
<li>整体上是标记-整理算法，两个区域之间是复制算法</li>
</ul>
<p>JDK8 并不是默认开启的，所需要参数开启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:MaxGCPauseMillis=time</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收阶段">垃圾回收阶段</h4>
<p><img src="image-20240102110849985.png" alt="image-20240102110849985" style="zoom:67%;" /></p>
<ul>
<li>Young Collection：对新生代垃圾收集</li>
<li>Young Collection + Concurrent
Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</li>
<li>Mixed Collection：会对新生代 + 老年代 +
幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</li>
</ul>
<h5 id="young-collection">Young Collection</h5>
<p>分区是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制
GC 产生的停顿时间！</p>
<p>每个小区间可以代表：E：eden，S：幸存区，O：老年代</p>
<figure>
<img src="20210210122339138.gif" alt="Young Collection" />
<figcaption aria-hidden="true">Young Collection</figcaption>
</figure>
<p>注意：会产生STW</p>
<h6 id="跨代引用">跨代引用</h6>
<p>老年代可能有老年对象引用了新生代对象（卡表），这样可以使新生代对象不被回收</p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-170416686796910.png" alt="跨代引用" style="zoom:50%;" /></p>
<p><strong>卡表&amp;Remembered Set</strong></p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-170416698795213.png" alt="卡表" style="zoom:50%;" /></p>
<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡
<ul>
<li>脏卡：O
被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul></li>
</ul>
<h5 id="young-collection-cm">Young Collection + CM</h5>
<p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由 JVM
参数决定 -XX:InitiatingHeapOccupancyPercent=percent （默认45%）</p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<h5 id="mixed-collection">Mixed Collection</h5>
<p>会对 E S O
进行<strong>全面的回收</strong>，阶段分为：最终标记、拷贝存活的对象（都会产生STW）</p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-17041665984177.png" alt="Mixed Collection" style="zoom:50%;" /></p>
<h5 id="full-gc">Full GC</h5>
<p>G1 在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full
GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发 Full
GC，然后<strong>退化成 serial Old</strong>
收集器串行的收集，就会导致停顿的时候长。</li>
</ul>
<h5 id="remark">Remark</h5>
<p>三色标记法：</p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-170416746268716.png" alt="三色标记法" style="zoom:33%;" /></p>
<ul>
<li>黑色：已被处理，需要保留的</li>
<li>灰色：正在处理中的</li>
<li>白色：还未处理的</li>
</ul>
<p>并发标记问题：</p>
<p><img src="image-20240102115226270.png" alt="标记1" style="zoom:67%;" /></p>
<p>这时，B断掉与C的引用，但是与此同时，A打算引用C，这时会引发Remark：</p>
<ul>
<li><p>之前 C 未被引用，这时 A 引用了 C ，就会给 C
加一个写屏障，写屏障的指令会被执行，将 C 放入一个队列当中，并将 C 变为
<strong>处理中</strong>状态，也就是灰色</p>
<p><img src="image-20240102115559103.png" alt="Remark1" style="zoom:50%;" /></p></li>
<li><p>在并发标记阶段结束以后，重新标记阶段会 STW
，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它，由灰色变成黑色。</p>
<p><img src="image-20240102115620042.png" alt="Remark2" style="zoom:50%;" /></p></li>
</ul>
<h4 id="优化">优化</h4>
<h5 id="字符串去重">字符串去重</h5>
<p>过程：</p>
<ul>
<li>将所有新分配的字符串（底层是 char[]
）放入一个<strong>队列</strong></li>
<li>当新生代回收时，G1 并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们引用<strong>同一个char数组</strong></li>
</ul>
<p>注意，其与 String.intern() 的区别</p>
<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串标</li>
</ul>
<h5 id="巨型对象的回收">巨型对象的回收</h5>
<ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li><strong>G1不会对巨型对象进行拷贝</strong></li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming（卡表）引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-170416845516119.png" alt="巨型对象的回收" style="zoom:50%;" /></p>
<h2 id="gc调优">gc调优</h2>
<p>查看虚拟机参数命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\JavaJDK1.8\bin\java   -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;</span><br></pre></td></tr></table></figure>
<p>可以根据参数去查询具体的信息</p>
<p><strong>调优领域</strong></p>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
<li>gc</li>
</ul>
<p><strong>目标</strong> 低延迟/高吞吐量 ？ 选择合适的GC</p>
<ul>
<li><p>CMS G1 ZGC</p></li>
<li><p>ParallelGC</p></li>
<li><p>Zing</p></li>
</ul>
<p><strong>最快的 GC</strong></p>
<p>首先排除减少因为自身编写的代码而引发的内存问题，不产生GC就是最快的GC</p>
<p>查看 Full GC 前后的内存占用，考虑以下几个问题</p>
<ul>
<li><p>数据是不是太多？</p>
<ul>
<li>例如：<code>resultSet = statement.executeQuery(“select * from 大表 limit n”)</code>
从数据库中一下子取出众多数据放到内存中，肯定会引起堆内存紧张</li>
</ul></li>
<li><p>数据表示是否太臃肿</p>
<ul>
<li><p>对象图</p></li>
<li><p>对象大小 16byte 例如 Integer 是24字节，非必要可以转化成 int
类型，只占用4byte</p></li>
</ul></li>
<li><p>是否存在内存泄漏</p>
<ul>
<li><p>static Map map …</p></li>
<li><p>软</p></li>
<li><p>弱</p></li>
<li><p>第三方缓存实现</p></li>
</ul></li>
</ul>
<h3 id="新生代调优">新生代调优</h3>
<p><strong>新生代的特点</strong></p>
<ul>
<li><p>所有的 new 操作分配内存都是非常廉价的</p>
<ul>
<li>为了防止多线程并发访问某一内存块，采用TLAB thread-lcoal allocation
buffer 单独的给每个线程提供私有空间</li>
</ul></li>
<li><p>死亡对象回收零代价</p></li>
<li><p>大部分对象用过即死（朝生夕死）</p></li>
<li><p>Minor GC 所用时间远小于 Full GC</p></li>
</ul>
<p>新生代内存越大越好么？</p>
<p>不是</p>
<ul>
<li>新生代内存太小：频繁触发 Minor GC ，会 STW ，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full
GC。而且触发 Minor GC 时，清理新生代所花费的时间会更长</li>
</ul>
<p>新生代内存设置为能容纳
<code>[并发量*(单次请求-&gt;响应 产生的对象大小)]</code> 的数据为宜</p>
<ul>
<li><p>幸存区需要能够保存 当前活跃对象 + 需要晋升的对象</p>
<ul>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold</span><br><span class="line">-XX:+PrintTenuringDistrubution</span><br></pre></td></tr></table></figure>
<h3 id="老年代调优">老年代调优</h3>
<p><strong>CMS</strong></p>
<p>CMS 的老年代内存越大越好，先尝试不做调优</p>
<ul>
<li><p>如果没有 Full GC
那么内存已经够用，否则先尝试调优新生代。</p></li>
<li><p>当观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~
1/3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure></li>
</ul>
<p>案例</p>
<p>案例1：Full GC 和 Minor GC 频繁</p>
<p>案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）</p>
<p>案例3：老年代充裕情况下，发生 Full GC（jdk1.7）</p>
<h1 id="字节码技术">字节码技术</h1>
<h2 id="类文件结构">类文件结构</h2>
<p>通过 javac 类名.java 编译 java 文件后，会生成一个 .class
的文件，以下是字节码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure>
<p>根据 JVM 规范，字节码文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u4 			   magic									-- 前四个字节的魔数，不同的东西有不同的魔数</span><br><span class="line">u2             minor_version;    						-- 小版本</span><br><span class="line">u2             major_version;     						-- 大版本   </span><br><span class="line">u2             constant_pool_count;    					-- 常量池大小</span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    -- </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure>
<h2 id="字节码指令">字节码指令</h2>
<h3 id="javap工具">javap工具</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v D:Demo.class</span><br></pre></td></tr></table></figure>
<h3 id="图解案例">图解案例</h3>
<h4 id="赋值基础运算">赋值基础运算</h4>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_1</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的字节码文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">Classfile /root/Demo3_1.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Last</span> modified Jul <span class="number">7</span>, <span class="number">2019</span>; size <span class="number">665</span> bytes</span><br><span class="line">MD5 checksum a2c29a22421e218d4924d31e6990cfc5</span><br><span class="line">Compiled from <span class="string">&quot;Demo3_1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cn</span>.itcast.jvm.t3.bytecode.Demo3_1</span><br><span class="line">minor version: <span class="number">0</span></span><br><span class="line">major version: <span class="number">52</span></span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#<span class="number">1</span> = Methodref #<span class="number">7.</span>#<span class="number">26</span> <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">2</span> = Class #<span class="number">27</span> <span class="comment">// java/lang/Short</span></span><br><span class="line">#<span class="number">3</span> = Integer <span class="number">32768</span></span><br><span class="line">#<span class="number">4</span> = Fieldref #<span class="number">28.</span>#<span class="number">29</span> <span class="comment">//</span></span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#<span class="number">5</span> = Methodref #<span class="number">30.</span>#<span class="number">31</span> <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">#<span class="number">6</span> = Class #<span class="number">32</span> <span class="comment">// cn/itcast/jvm/t3/bytecode/Demo3_1</span></span><br><span class="line">#<span class="number">7</span> = Class #<span class="number">33</span> <span class="comment">// java/lang/Object</span></span><br><span class="line">#<span class="number">8</span> = Utf8 &lt;init&gt;</span><br><span class="line">#<span class="number">9</span> = Utf8 ()V</span><br><span class="line">#<span class="number">10</span> = Utf8 Code</span><br><span class="line">#<span class="number">11</span> = Utf8 LineNumberTable</span><br><span class="line">#<span class="number">12</span> = Utf8 LocalVariableTable</span><br><span class="line">#<span class="number">13</span> = Utf8 <span class="built_in">this</span></span><br><span class="line">#<span class="number">14</span> = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">#<span class="number">15</span> = Utf8 main</span><br><span class="line">#<span class="number">16</span> = Utf8 ([Ljava/lang/String;)V</span><br><span class="line">#<span class="number">17</span> = Utf8 args</span><br><span class="line">#<span class="number">18</span> = Utf8 [Ljava/lang/String;</span><br><span class="line">#<span class="number">19</span> = Utf8 a</span><br><span class="line">#<span class="number">22</span> = Utf8 c</span><br><span class="line">#<span class="number">23</span> = Utf8 MethodParameters</span><br><span class="line">#<span class="number">24</span> = Utf8 SourceFile</span><br><span class="line">#<span class="number">25</span> = Utf8 Demo3_1.java</span><br><span class="line">#<span class="number">26</span> = NameAndType #<span class="number">8</span>:#<span class="number">9</span> <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">27</span> = Utf8 java/lang/Short</span><br><span class="line">#<span class="number">28</span> = Class #<span class="number">34</span> <span class="comment">// java/lang/System</span></span><br><span class="line">#<span class="number">29</span> = NameAndType #<span class="number">35</span>:#<span class="number">36</span> <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">#<span class="number">30</span> = Class #<span class="number">37</span> <span class="comment">// java/io/PrintStream</span></span><br><span class="line">#<span class="number">31</span> = NameAndType #<span class="number">38</span>:#<span class="number">39</span> <span class="comment">// println:(I)V</span></span><br><span class="line">#<span class="number">32</span> = Utf8 cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">#<span class="number">33</span> = Utf8 java/lang/Object</span><br><span class="line">#<span class="number">34</span> = Utf8 java/lang/System</span><br><span class="line">#<span class="number">35</span> = Utf8 out</span><br><span class="line">#<span class="number">36</span> = Utf8 Ljava/io/PrintStream;</span><br><span class="line">#<span class="number">37</span> = Utf8 java/io/PrintStream</span><br><span class="line">#<span class="number">38</span> = Utf8 println</span><br><span class="line">#<span class="number">39</span> = Utf8 (I)V</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> cn.itcast.jvm.t3.bytecode.Demo3_1();</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method java/lang/Object.&quot;</span></span><br><span class="line">&lt;init&gt;<span class="string">&quot;:()V</span></span><br><span class="line"><span class="string">4: return</span></span><br><span class="line"><span class="string">LineNumberTable:</span></span><br><span class="line"><span class="string">line 6: 0</span></span><br><span class="line"><span class="string">LocalVariableTable:</span></span><br><span class="line"><span class="string">Start Length Slot Name Signature</span></span><br><span class="line"><span class="string">0 5 0 this Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span></span><br><span class="line"><span class="string">public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="string">descriptor: ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="string">flags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line"><span class="string">Code:</span></span><br><span class="line"><span class="string">	stack=2, locals=4, args_size=1</span></span><br><span class="line"><span class="string">    0: bipush 10</span></span><br><span class="line"><span class="string">    2: istore_1</span></span><br><span class="line"><span class="string">    3: ldc #3 // int 32768</span></span><br><span class="line"><span class="string">    5: istore_2</span></span><br><span class="line"><span class="string">    6: iload_1</span></span><br><span class="line"><span class="string">    7: iload_2</span></span><br><span class="line"><span class="string">    8: iadd</span></span><br><span class="line"><span class="string">    9: istore_3</span></span><br><span class="line"><span class="string">    10: getstatic #4 // Field</span></span><br><span class="line"><span class="string">    java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="string">    13: iload_3</span></span><br><span class="line"><span class="string">    14: invokevirtual #5 // Method</span></span><br><span class="line"><span class="string">    java/io/PrintStream.println:(I)V</span></span><br><span class="line"><span class="string">    17: return</span></span><br><span class="line"><span class="string">LineNumberTable:</span></span><br><span class="line"><span class="string">    line 8: 0</span></span><br><span class="line"><span class="string">    line 9: 3</span></span><br><span class="line"><span class="string">    line 12: 17</span></span><br><span class="line"><span class="string">LocalVariableTable:</span></span><br><span class="line"><span class="string">	Start 	Length 	Slot 	Name 	Signature</span></span><br><span class="line"><span class="string">	0 		18 		0 		args 	[Ljava/lang/String;</span></span><br><span class="line"><span class="string">	3 		15 		1 		a 			I</span></span><br><span class="line"><span class="string">	6 		12 		2 		b 			I</span></span><br><span class="line"><span class="string">	10 		8 		3 		c 			I</span></span><br><span class="line"><span class="string">MethodParameters:</span></span><br><span class="line"><span class="string">	Name Flags</span></span><br><span class="line"><span class="string">	args</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>常量池载入运行时常量池</strong></p>
<p>将静态变量放到常量池中，其实常量池也属于方法区，单独抽出来了。</p>
<figure>
<img src="image-20240108120650688.png" alt="常量池载入" />
<figcaption aria-hidden="true">常量池载入</figcaption>
</figure>
<p><strong>方法字节码载入方法区</strong></p>
<figure>
<img src="image-20240108121208720.png" alt="方法字节码载入方法区" />
<figcaption aria-hidden="true">方法字节码载入方法区</figcaption>
</figure>
<p><strong>main 线程开始运行，分配栈帧内存</strong></p>
<p>（stack=2，locals=4）对应操作数栈有 2 个空间（每个空间 4
个字节），局部变量表中有 4 个槽位。</p>
<figure>
<img src="image-20240108150115655.png" alt="image-20240108150115655" />
<figcaption aria-hidden="true">image-20240108150115655</figcaption>
</figure>
<p><strong>执行引擎执行代码</strong></p>
<ol type="1">
<li><strong>bipush 10</strong>
<ul>
<li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4
个字节），类似的指令还有
<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为
long 是 8 个字节）</li>
<li>这里存在于short范围内的数字都是和字节码指令存在一起，<strong>超过
short 范围的数字存入了常量池</strong></li>
</ul></li>
</ul></li>
</ol>
<figure>
<img src="image-20240108152307214.png" alt="bipush" />
<figcaption aria-hidden="true">bipush</figcaption>
</figure>
<ol start="2" type="1">
<li><strong>istore 1</strong>
<ul>
<li>将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中，对应代码中的 a =
10</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108152626006.png" alt="istore 1" />
<figcaption aria-hidden="true">istore 1</figcaption>
</figure>
<ol start="3" type="1">
<li><strong>ldc #3</strong>
<ul>
<li>读取运行时常量池中 #3 ，即 32768 (超过 short
最大值范围的数会被放到运行时常量池中)，将其<strong>加载到操作数栈</strong>中，编译期已经做了编译优化，进行了计算。</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108152733243.png" alt="ldc #3" />
<figcaption aria-hidden="true">ldc #3</figcaption>
</figure>
<ol start="4" type="1">
<li><strong>istore 2</strong>
<ul>
<li>将操作数栈中的元素弹出，放到局部变量表的 2 号位置</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108152838616.png" alt="istore 2" />
<figcaption aria-hidden="true">istore 2</figcaption>
</figure>
<ol start="5" type="1">
<li><strong>iload1 iload2</strong>
<ul>
<li>将局部变量表中 1 号位置和 2
号位置的元素放入操作数栈中。因为<strong>只能在操作数栈中执行运算操作</strong></li>
</ul></li>
</ol>
<figure>
<img src="image-20240108154151871.png" alt="iload" />
<figcaption aria-hidden="true">iload</figcaption>
</figure>
<figure>
<img src="image-20240108154407127.png" alt="iload" />
<figcaption aria-hidden="true">iload</figcaption>
</figure>
<ol start="6" type="1">
<li><strong>iadd</strong>
<ul>
<li>将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中。</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108154817167.png" alt="iadd" />
<figcaption aria-hidden="true">iadd</figcaption>
</figure>
<ol start="7" type="1">
<li><strong>istore 3</strong>
<ul>
<li>将操作数栈中的元素弹出，放入局部变量表的3号位置</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108154904597.png" alt="istore" />
<figcaption aria-hidden="true">istore</figcaption>
</figure>
<ol start="8" type="1">
<li><strong>getstatic #4</strong>
<ul>
<li>在运行时常量池中找到#4，发现是一个对象，在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108155055022.png" alt="getstatic #4" />
<figcaption aria-hidden="true">getstatic #4</figcaption>
</figure>
<ol start="9" type="1">
<li><strong>iload 3</strong></li>
</ol>
<figure>
<img src="image-20240108155129991.png" alt="iload 3" />
<figcaption aria-hidden="true">iload 3</figcaption>
</figure>
<ol start="10" type="1">
<li><strong>invokevirtual</strong> 5
<ul>
<li>找到常量池 #5 项</li>
<li>定位到方法区 <code>java/io/PrintStream.println:(I)V</code> 方法</li>
<li>生成新的栈帧（分配 locals、stack等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
</ul></li>
</ol>
<figure>
<img src="image-20240108155220452.png" alt="invokevirtual 5" />
<figcaption aria-hidden="true">invokevirtual 5</figcaption>
</figure>
<p>​</p>
<ul>
<li><p>执行完毕，弹出栈帧</p></li>
<li><p>清除 main 操作数栈内容</p></li>
</ul>
<figure>
<img src="image-20240108155322128.png" alt="清除 main 操作数栈内容" />
<figcaption aria-hidden="true">清除 main 操作数栈内容</figcaption>
</figure>
<ol start="11" type="1">
<li>return
<ul>
<li>完成 main 方法调用，弹出 main 栈帧</li>
<li>程序结束</li>
</ul></li>
</ol>
<h4 id="i-i案例">i++ ++i案例</h4>
<p>对于i++，先执行iload，再执行iint，但是只对变量表里变量自增，并不在操作栈更新</p>
<p>对于++i，先执行iint，再执行iload，这样先在变量表更新后的值再放到操作数栈里</p>
<h4 id="x恒等于0">x恒等于0</h4>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_11_ByteCodeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span>	<span class="comment">// 操作数栈分配2个空间，局部变量表分配 3 个空间</span></span><br><span class="line">        <span class="number">0</span>: iconst_0	<span class="comment">// 准备一个常数 0</span></span><br><span class="line">        <span class="number">1</span>: istore_1	<span class="comment">// 将常数 0 放入局部变量表的 1 号槽位 i = 0</span></span><br><span class="line">        <span class="number">2</span>: iconst_0	<span class="comment">// 准备一个常数 0</span></span><br><span class="line">        <span class="number">3</span>: istore_2	<span class="comment">// 将常数 0 放入局部变量的 2 号槽位 x = 0	</span></span><br><span class="line">        <span class="number">4</span>: iload_1		<span class="comment">// 将局部变量表 1 号槽位的数放入操作数栈中</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">10</span>	<span class="comment">// 将数字 10 放入操作数栈中，此时操作数栈中有 2 个数</span></span><br><span class="line">        <span class="number">7</span>: if_icmpge     <span class="number">21</span>	<span class="comment">// 比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到 21 。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span></span><br><span class="line">            </span><br><span class="line">       <span class="number">10</span>: iload_2		<span class="comment">// 将局部变量 2 号槽位的数放入操作数栈中，放入的值是 0 </span></span><br><span class="line">       <span class="number">11</span>: iinc          <span class="number">2</span>, <span class="number">1</span>	<span class="comment">// 将局部变量 2 号槽位的数加 1 ，自增后，槽位中的值为 1 </span></span><br><span class="line">       <span class="number">14</span>: istore_2	<span class="comment">//将操作数栈中的数放入到局部变量表的 2 号槽位，2 号槽位的值又变为了0</span></span><br><span class="line">       <span class="number">15</span>: iinc          <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 1 号槽位的值自增 1 </span></span><br><span class="line">           </span><br><span class="line">       <span class="number">18</span>: goto          <span class="number">4</span> <span class="comment">// 跳转到第4条指令</span></span><br><span class="line">       <span class="number">21</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">24</span>: iload_2</span><br><span class="line">       <span class="number">25</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">       <span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="构造方法">构造方法</h3>
<h4 id="静态">静态</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_12_CinitTest</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(i); <span class="comment">// 30</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译器会按从上至下的顺序，收集所有 static
静态代码块和静态成员赋值的代码，合并为一个特殊的方法
<code>cinit()V</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack=1, locals=0, args_size=0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: putstatic     #3                  // Field i:I</span><br><span class="line">         5: bipush        20</span><br><span class="line">         7: putstatic     #3                  // Field i:I</span><br><span class="line">        10: bipush        30</span><br><span class="line">        12: putstatic     #3                  // Field i:I</span><br><span class="line">        15: return</span><br></pre></td></tr></table></figure>
<h4 id="对象">对象</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_13_InitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Code_13_InitTest</span><span class="params">(String a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code_13_InitTest</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code_13_InitTest</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(d.a);</span><br><span class="line">        System.out.println(d.b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会按从上至下的顺序，收集所有 {}
代码块和成员变量赋值的代码，形成新的构造方法，但<strong>原始构造方法</strong>内的代码总是<strong>在后.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: aload_0</span><br><span class="line">        <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String s1</span></span><br><span class="line">        <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">10</span>: aload_0</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">16</span>: aload_0</span><br><span class="line">       <span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">19</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">22</span>: aload_0</span><br><span class="line">       <span class="number">23</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String s2</span></span><br><span class="line">       <span class="number">25</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="comment">// 原始构造方法在最后执行</span></span><br><span class="line">       <span class="number">28</span>: aload_0</span><br><span class="line">       <span class="number">29</span>: aload_1</span><br><span class="line">       <span class="number">30</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">33</span>: aload_0</span><br><span class="line">       <span class="number">34</span>: iload_2</span><br><span class="line">       <span class="number">35</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">38</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="方法调用">方法调用</h3>
<p>不同类型的方法，调用时对应的字节码指令如下：</p>
<ul>
<li>私有、构造、被 final 修饰的方法，在调用时都使用 invokespecial
指令，就是调用特定方法</li>
<li>普通成员方法在调用时，使用 invokevirtual
指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用 invokestatic 指令</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_14_MethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Code_14_MethodTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code_14_MethodTest</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code_14_MethodTest</span>();</span><br><span class="line">        obj.test1();</span><br><span class="line">        obj.test2();</span><br><span class="line">        obj.test3();</span><br><span class="line">        Code_14_MethodTest.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">对应字节码</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">//</span></span><br><span class="line">         <span class="number">3</span>: dup 							<span class="comment">// 复制一份对象地址压入操作数栈中</span></span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line">        <span class="number">20</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="多态原理">多态原理</h3>
<p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用
invokevirtual 指令，在执行 invokevirtual
指令时，经历了以下几个步骤：</p>
<ol type="1">
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的 Class</li>
<li>Class 结构中有 vtable</li>
<li>查询 vtable 找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h3 id="异常机制">异常机制</h3>
<h4 id="普通try-catch">普通try-catch</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">12</span></span><br><span class="line">        <span class="number">8</span>: astore_2			<span class="comment">//将异常对象e放入局部变量表2号位置</span></span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1</span><br><span class="line">       <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">     <span class="comment">//多出来一个异常表</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure>
<ul>
<li>[from, to) 是前闭后开（也就是检测 2~4 行）的检测范围</li>
<li>type 匹配异常类型，如果一致，进入 target 所指示行号</li>
</ul>
<h4 id="多catch块">多catch块</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1</span><br><span class="line">       <span class="number">12</span>: goto          <span class="number">19</span></span><br><span class="line">       <span class="number">15</span>: astore_2			</span><br><span class="line">       <span class="number">16</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">18</span>: istore_1</span><br><span class="line">       <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ArithmeticException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/Exception</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="finally">finally</h4>
<p>代码1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           i = <span class="number">10</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           i = <span class="number">20</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           i = <span class="number">30</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>对应字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="comment">// try块</span></span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="comment">// try块执行完后，会执行finally    </span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">7</span>: istore_1</span><br><span class="line">        <span class="number">8</span>: goto          <span class="number">27</span></span><br><span class="line">       <span class="comment">// catch块     </span></span><br><span class="line">       <span class="number">11</span>: astore_2 <span class="comment">// 异常信息放入局部变量表的2号槽位</span></span><br><span class="line">       <span class="number">12</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">14</span>: istore_1</span><br><span class="line">       <span class="comment">// catch块执行完后，会执行finally        </span></span><br><span class="line">       <span class="number">15</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">17</span>: istore_1</span><br><span class="line">       <span class="number">18</span>: goto          <span class="number">27</span></span><br><span class="line">       <span class="comment">// 出现异常，但未被 Exception 捕获，会抛出其他异常，这时也需要执行 finally 块中的代码   </span></span><br><span class="line">       <span class="number">21</span>: astore_3</span><br><span class="line">       <span class="number">22</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">24</span>: istore_1</span><br><span class="line">       <span class="number">25</span>: aload_3</span><br><span class="line">       <span class="number">26</span>: athrow  <span class="comment">// 抛出异常</span></span><br><span class="line">       <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">           <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any</span><br></pre></td></tr></table></figure>
<ul>
<li>ﬁnally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及
catch 剩余的异常类型流程</li>
</ul>
<p>代码2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_18_FinallyReturnTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Code_18_FinallyReturnTest.test();</span><br><span class="line">        <span class="comment">// 结果为 20</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回结果：<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>对应字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0</span><br><span class="line">        3: iload_0</span><br><span class="line">        4: istore_1  // 暂存返回值</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0</span><br><span class="line">        8: iload_0</span><br><span class="line">        9: ireturn	// ireturn 会返回操作数栈顶的整型值 20</span><br><span class="line">       // 如果出现异常，还是会执行finally 块中的内容，没有抛出异常</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: iload_0</span><br><span class="line">       15: ireturn	// 这里没有 athrow 了，也就是如果在 finally 块中如果有返回操作的话，且 try 块中出现异常，会吞掉异常！</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     5    10   any</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			i = <span class="number">20</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">返回值：<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>对应字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0 <span class="comment">// 赋值给i 10</span></span><br><span class="line">        <span class="number">3</span>: iload_0	<span class="comment">// 加载到操作数栈顶</span></span><br><span class="line">        <span class="number">4</span>: istore_1 <span class="comment">// 加载到局部变量表的1号位置</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0 <span class="comment">// 赋值给i 20</span></span><br><span class="line">        <span class="number">8</span>: iload_1 <span class="comment">// 加载局部变量表1号位置的数10到操作数栈</span></span><br><span class="line">        <span class="number">9</span>: ireturn <span class="comment">// 返回操作数栈顶元素 10</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2 <span class="comment">// 加载异常</span></span><br><span class="line">       <span class="number">15</span>: athrow <span class="comment">// 抛出异常</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="类加载">类加载</h1>
<h2 id="过程">过程</h2>
<h3 id="加载">加载</h3>
<p>加载规则：</p>
<ul>
<li><p>将<strong>类的字节码载入方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用
C++ 的 <strong>instanceKlass</strong> 描述 java 类，它的重要 ﬁeld
有：</p>
<ul>
<li><p>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是
String.class，作用是把 klass 暴露给 java 使用</p></li>
<li><p>_super 即父类</p></li>
<li><p>_ﬁelds 即成员变量</p></li>
<li><p>_methods 即方法</p></li>
<li><p>_constants 即常量池</p></li>
<li><p>_class_loader 即类加载器</p></li>
<li><p>_vtable 虚方法表</p></li>
<li><p>_itable 接口方法</p></li>
</ul></li>
<li><p>优先加载父类</p></li>
<li><p>加载和链接可能是<strong>交替运行</strong>的</p></li>
<li><p><strong>instanceKlass</strong>
这样的【元数据】是存储在<strong>方法区</strong>（1.8 后的元空间内），但
**_java_mirror** 是存储在<strong>堆</strong>中</p></li>
<li><p>instanceKlass和_java_mirror（java镜像类）互相保存了对方的地址</p></li>
<li><p>类的对象在对象头中保存了 *.class
的地址，让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</p></li>
</ul>
<figure>
<img src="image-20240127173914863.png" alt="jvm内存结构——类存储" />
<figcaption aria-hidden="true">jvm内存结构——类存储</figcaption>
</figure>
<h3 id="链接">链接</h3>
<h4 id="验证">验证</h4>
<p>验证类是否符合 JVM规范，安全性检查，检查字节码文件中的二进制位。</p>
<h4 id="准备">准备</h4>
<p>为 <code>static</code> 变量分配空间，设置默认值</p>
<ul>
<li><p>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK
7以后就存储在_java_mirror末尾了</p></li>
<li><p>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</p></li>
<li><p>如果 static 变量是 ﬁnal
的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</p></li>
<li><p>如果 static 变量是 ﬁnal
的，但属于引用类型，那么赋值也会在初始化阶段完成</p></li>
</ul>
<h4 id="解析">解析</h4>
<p>将常量池中的符号引用解析为直接引用</p>
<p>类似linux的符号、物理链接</p>
<h3 id="初始化">初始化</h3>
<p>初始化即调用
<code>&lt;cinit&gt;()</code>，虚拟机会保证这个类的【构造方法】的线程安全。</p>
<p>触发时机：</p>
<ul>
<li><p>main 方法所在的类，总会被首先初始化</p></li>
<li><p>首次访问这个类的静态变量或静态方法时</p></li>
<li><p>子类初始化，如果父类还没初始化，会引发</p></li>
<li><p>子类访问父类的静态变量，只会触发父类的初始化</p></li>
<li><p>Class.forName</p></li>
<li><p>new 会导致初始化</p></li>
</ul>
<p>以下情况不会初始化：</p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的数组</li>
<li>类加载器的.loadClass方法</li>
<li>Class.forName的参数2为false时</li>
</ul>
<h2 id="类加载器">类加载器</h2>
<p>以 JDK 8 为例：</p>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 23%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>加载的类路径</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问</td>
</tr>
<tr class="even">
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap，显示为null</td>
</tr>
<tr class="odd">
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr class="even">
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody>
</table>
<p>启用Bootstrap ClassLoader：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:&lt;追加路径&gt;（后追加）</span><br><span class="line"></span><br><span class="line">java -Xbootclasspath/p:&lt;追加路径&gt;（前追加）</span><br></pre></td></tr></table></figure>
<ul>
<li>-Xbootclasspath 表示设置 bootclasspath</li>
<li>其中 /a: . 表示将当前目录追加至 bootclasspath 之后</li>
</ul>
<h3 id="双亲委派">双亲委派</h3>
<p>类加载过程：</p>
<ol type="1">
<li><code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个class时，它也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败
(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用<code>ExtClassLoader</code>来尝试加载；</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ol>
<p>类加载器的loadClass方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检查该类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2. 有上级的话，委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 如果没有上级了（ExtClassLoader），则委派</span></span><br><span class="line">                    <span class="type">BootstrapClassLoader</span></span><br><span class="line">                        <span class="variable">c</span> <span class="operator">=</span> findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">// 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// 5. 记录耗时</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="自定义类加载器">自定义类加载器</h2>
<p><strong>场景</strong></p>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于
tomcat 容器</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol type="1">
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法
<ul>
<li>不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul></li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ol>
<h1 id="运行期优化">运行期优化</h1>
<h2 id="即时编译">即时编译</h2>
<h3 id="分层编译">分层编译</h3>
<p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：<strong>解释</strong>执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带
proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>解释器</p>
<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
<p>即时编译器</p>
<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code
Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。</p>
<p>效率：解释器 &lt; C1 &lt; C2</p>
<h3 id="方法内联">方法内联</h3>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure>
<p>如果发现 square
是热点方法，并且长度不太长时，会进行<strong>内联</strong>；内联就是把方法内代码拷贝、
粘贴到调用者的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(9 * 9);</span><br></pre></td></tr></table></figure>
<p>再进行<strong>常量折叠</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(8);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2023/12/18/%E9%BB%91%E9%A9%ACJVM%E5%AD%A6%E4%B9%A0/">https://vlsmhd.github.io/2023/12/18/%E9%BB%91%E9%A9%ACJVM%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/04/2024%E6%98%A5%E6%8B%9B%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/" title="2024春招投递记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2024春招投递记录</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/29/%E6%B8%90%E8%BF%9B%E5%BC%8Fredis%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7Vedis/" title="渐进式redis缓存工具Vedis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">渐进式redis缓存工具Vedis</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stackoverflow"><span class="toc-number">1.2.1.</span> <span class="toc-text">StackOverFlow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="toc-number">1.2.2.</span> <span class="toc-text">线程运行诊断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">CPU占用分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">死锁分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.4.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.4.1.</span> <span class="toc-text">堆内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="toc-number">1.4.2.</span> <span class="toc-text">堆内存诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringtable"><span class="toc-number">1.4.3.</span> <span class="toc-text">StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#intern%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">intern方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">调优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.5.1.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.6.</span> <span class="toc-text">直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">1.6.1.</span> <span class="toc-text">优势-文件读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">回收原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E6%98%BE%E7%A4%BA%E5%9B%9E%E6%94%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">禁用显示回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">GC垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">判断回收条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">引用计数法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">5种引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.1.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.1.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.1.3.</span> <span class="toc-text">弱引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#threadlocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">2.1.1.1.3.1.</span> <span class="toc-text">ThreadLocal内存泄露</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.1.4.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.1.5.</span> <span class="toc-text">终结器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">可达性分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">可以作为GC root的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#eclipse-memory-analyzer%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">Eclipse Memory
Analyzer工具查看</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="toc-number">2.2.1.</span> <span class="toc-text">标记-清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">标记-整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">标记-复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">GC调优参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">2.3.1.</span> <span class="toc-text">串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">响应时间优先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cms-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">CMS 收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#g1"><span class="toc-number">2.3.4.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">垃圾回收阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#young-collection"><span class="toc-number">2.3.4.1.1.</span> <span class="toc-text">Young Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="toc-number">2.3.4.1.1.1.</span> <span class="toc-text">跨代引用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#young-collection-cm"><span class="toc-number">2.3.4.1.2.</span> <span class="toc-text">Young Collection + CM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mixed-collection"><span class="toc-number">2.3.4.1.3.</span> <span class="toc-text">Mixed Collection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#full-gc"><span class="toc-number">2.3.4.1.4.</span> <span class="toc-text">Full GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remark"><span class="toc-number">2.3.4.1.5.</span> <span class="toc-text">Remark</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">2.3.4.2.1.</span> <span class="toc-text">字符串去重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.4.2.2.</span> <span class="toc-text">巨型对象的回收</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc%E8%B0%83%E4%BC%98"><span class="toc-number">2.4.</span> <span class="toc-text">gc调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">老年代调优</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">字节码技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">字节码指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javap%E5%B7%A5%E5%85%B7"><span class="toc-number">3.2.1.</span> <span class="toc-text">javap工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">图解案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">赋值基础运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-i%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">i++ ++i案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x%E6%81%92%E7%AD%89%E4%BA%8E0"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">x恒等于0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">静态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.5.</span> <span class="toc-text">多态原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.6.</span> <span class="toc-text">异常机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9Atry-catch"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">普通try-catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9Acatch%E5%9D%97"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">多catch块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally"><span class="toc-number">3.2.6.3.</span> <span class="toc-text">finally</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.1.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">4.1.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-number">4.2.1.</span> <span class="toc-text">双亲委派</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91"><span class="toc-number">5.1.</span> <span class="toc-text">即时编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="toc-number">5.1.1.</span> <span class="toc-text">分层编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-number">5.1.2.</span> <span class="toc-text">方法内联</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/13/%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E6%95%B0/" title="显示屏参数">显示屏参数</a><time datetime="2024-07-12T16:41:23.059Z" title="发表于 2024-07-13 00:41:23">2024-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/20/OBCA%E5%AD%A6%E4%B9%A0/" title="OBCA学习">OBCA学习</a><time datetime="2024-06-20T08:29:14.233Z" title="发表于 2024-06-20 16:29:14">2024-06-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/31/Spring%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Spring深度学习">Spring深度学习</a><time datetime="2024-03-31T11:41:11.573Z" title="发表于 2024-03-31 19:41:11">2024-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/" title="软件测试入门">软件测试入门</a><time datetime="2024-03-27T07:10:53.727Z" title="发表于 2024-03-27 15:10:53">2024-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="深入理解分布式系统-阅读笔记">深入理解分布式系统-阅读笔记</a><time datetime="2024-03-26T03:26:08.300Z" title="发表于 2024-03-26 11:26:08">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>