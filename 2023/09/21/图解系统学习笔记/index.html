<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>图解系统学习笔记 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="硬件结构 操作系统结构 内核 内核的概念：应用程序和外部硬件设备交互的桥梁。  内核的作用：  进程、线程管理： 内存管理： 硬件设施管理： 内核调用：应用程序需要更高权限运行的服务，必须要有内核调用，是用户程序与操作系统之间的接口  内核的工作流程 大多数的操作系统，内存会有俩区域：  内核空间，这个内存空间只有内核程序可以访问； 用户空间，这个内存空间专门给应用">
<meta property="og:type" content="article">
<meta property="og:title" content="图解系统学习笔记">
<meta property="og:url" content="https://vlsmhd.github.io/2023/09/21/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="硬件结构 操作系统结构 内核 内核的概念：应用程序和外部硬件设备交互的桥梁。  内核的作用：  进程、线程管理： 内存管理： 硬件设施管理： 内核调用：应用程序需要更高权限运行的服务，必须要有内核调用，是用户程序与操作系统之间的接口  内核的工作流程 大多数的操作系统，内存会有俩区域：  内核空间，这个内存空间只有内核程序可以访问； 用户空间，这个内存空间专门给应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-09-21T09:23:59.557Z">
<meta property="article:modified_time" content="2023-11-09T07:34:02.429Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2023/09/21/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '图解系统学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-09 15:34:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">图解系统学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-21T09:23:59.557Z" title="发表于 2023-09-21 17:23:59">2023-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-09T07:34:02.429Z" title="更新于 2023-11-09 15:34:02">2023-11-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="图解系统学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="硬件结构">硬件结构</h1>
<h1 id="操作系统结构">操作系统结构</h1>
<h2 id="内核">内核</h2>
<p>内核的概念：应用程序和外部硬件设备交互的桥梁。</p>
<p><img src="图解系统学习笔记/Kernel_Layout.png" alt="内核" style="zoom: 33%;"></p>
<p>内核的作用：</p>
<ul>
<li>进程、线程管理：</li>
<li>内存管理：</li>
<li>硬件设施管理：</li>
<li>内核调用：应用程序需要更高权限运行的服务，必须要有内核调用，是用户程序与操作系统之间的接口</li>
</ul>
<p>内核的工作流程</p>
<p>大多数的操作系统，内存会有俩区域：</p>
<ul>
<li>内核空间，这个内存空间只有内核程序可以访问；</li>
<li>用户空间，这个内存空间专门给应用程序使用；</li>
</ul>
<p>系统调用过程：</p>
<p><img src="图解系统学习笔记/systemcall.png" alt="img" style="zoom:67%;"></p>
<ul>
<li>第一次中断：中断用户程序</li>
<li>第二次中断：中断内核程序</li>
</ul>
<h2 id="linux设计">linux设计</h2>
<p>设计理念：</p>
<ul>
<li><em>MultiTask</em>，多任务</li>
<li><em>SMP</em>，对称多处理</li>
<li><em>ELF</em>，可执行文件链接格式</li>
<li><em>Monolithic Kernel</em>，宏内核</li>
</ul>
<h3 id="multitask">MultiTask</h3>
<p>多任务机制：</p>
<ul>
<li>单CPU并发</li>
<li>多CPU并行</li>
</ul>
<h3 id="smp">SMP</h3>
<p><strong>对称多处理</strong>，每个CPU的权重低位是相同的，对资源的使用权限相同。</p>
<p>每个CPU都共享整个内存空间。</p>
<h3 id="elf">ELF</h3>
<p>定义：可执行文件链接格式</p>
<p>结构：</p>
<p><img src="图解系统学习笔记/Elf.png" alt="ELF 文件格式" style="zoom: 33%;"></p>
<p>ELF文件的生成：</p>
<p>编写的代码，首先通过「<strong>编译器</strong>」编译成汇编代码，接着通过「<strong>汇编器</strong>」变成目标代码，也就是目标文件，最后通过「<strong>链接器</strong>」把多个目标文件以及调用的各种函数库链接起来，形成一个可执行文件，也就是
ELF 文件。</p>
<p>ELF文件的执行：</p>
<p>利用<strong>装载器</strong>把ELF文件装载到内存中，CPU
读取内存中的指令和数据，于是程序就被执行起来了。</p>
<h3 id="monolithic-kernel">Monolithic Kernel</h3>
<p>Monolithic Kernel 的意思是<strong>宏内核</strong>，Linux
内核架构就是宏内核，</p>
<figure>
<img src="图解系统学习笔记/OS-structure2.png" alt="分别为宏内核、微内核、混合内核的操作系统结构">
<figcaption aria-hidden="true">分别为宏内核、微内核、混合内核的操作系统结构</figcaption>
</figure>
<h2 id="windows设计">windows设计</h2>
<p>Windows NT 的结构图片：</p>
<p><img src="图解系统学习笔记/windowNT.png" alt="Windows NT 的结构" style="zoom:50%;"></p>
<p>windows可执行文件：</p>
<p>可执行文件格式叫
PE，称为<strong>可移植执行文件</strong>，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等。</p>
<p>PE结构：</p>
<p><img src="图解系统学习笔记/pe.png" alt="PE 文件结构" style="zoom:80%;"></p>
<h1 id="内存管理">内存管理</h1>
<h2 id="虚拟内存">虚拟内存</h2>
<p>单片机：一次性只能烧录一个程序运行，<strong>无法运行多个程序</strong>。</p>
<p>操作系统利用虚拟内存解决多程序运行的问题：</p>
<p>内存隔离：把进程所使用的地址隔离开，让每个进程都<strong>拥有自己的内存地址</strong>——虚拟内存</p>
<p>内存映射：把虚拟内存和真实物理内存一 一映射</p>
<ul>
<li>虚拟内存地址</li>
<li>物理内存地址</li>
</ul>
<p>转换过程：</p>
<p><img src="图解系统学习笔记/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="img" style="zoom:50%;"></p>
<p>管理虚存地址和物理内存地址的方式：内存分段、内存分页、段页混合式管理。</p>
<h2 id="内存分段">内存分段</h2>
<p>程序由多个段组成：</p>
<ul>
<li>代码段</li>
<li>数据分段</li>
<li>栈段</li>
<li>堆段</li>
</ul>
<p>采用分段，将以上的段分离</p>
<p><strong>分段机制下，虚拟——&gt;真实地址的映射</strong></p>
<p>虚拟地址的组成：</p>
<ul>
<li>段选择因子：保存在<strong>段寄存器</strong>里。其中包含：
<ul>
<li>段号：段表的索引</li>
<li>标志位等</li>
</ul></li>
<li>段内偏移量：位于 0 和段界限之间</li>
</ul>
<p><img src="图解系统学习笔记/a9ed979e2ed8414f9828767592aadc21.png" alt="img" style="zoom: 50%;"></p>
<p>CPU解析虚拟地址，通过段选择因子获取段表索引，查找到对应段的段内描述符，获取段内描述符里的段基地址，配合段内偏移量找到对应的物理地址。</p>
<ul>
<li>段表：
<ul>
<li>段内描述符
<ul>
<li>段基地址：段的起始地址（低地址）</li>
<li>段界限</li>
<li>DPL</li>
</ul></li>
</ul></li>
</ul>
<p>程序分段示意图：</p>
<p><img src="图解系统学习笔记/c5e2ab63e6ee4c8db575f3c7c9c85962.png" alt="程序分段示意图" style="zoom:67%;"></p>
<p>分段的缺陷：内存碎片、内存交换效率低</p>
<p><strong>内存碎片</strong></p>
<p>分类：</p>
<ul>
<li>内部碎片</li>
<li>外部碎片</li>
</ul>
<p><img src="图解系统学习笔记/6142bc3c917e4a6298bdb62936e0d332.png" alt="img" style="zoom:50%;"></p>
<p>分段不会产生内部碎片，因为段根据实际需要分配内存。但是多个段之间会产生外部碎片，导致其它程序无法运行。</p>
<p><strong>交换效率低</strong></p>
<p>有外部内存碎片，就要重新swap内存区域，swap是内存和磁盘进行交互，由于磁盘IO速度过慢，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上，所以显得效率很慢。</p>
<h2 id="内存分页">内存分页</h2>
<p>分页，就是把虚拟空间和物理空间都切成一段段大小相同的内存块。通过<strong>页表</strong>来映射。</p>
<p><img src="图解系统学习笔记/08a8e315fedc4a858060db5cb4a654af.png" alt="img" style="zoom:50%;"></p>
<ul>
<li><p>页表存储在内存，通过MMU（内存管理单元）</p></li>
<li><p>缺页异常：虚拟地址在页表中查不到</p></li>
</ul>
<p><strong>分页机制下，虚拟——&gt;真实地址的映射</strong></p>
<p>虚拟地址组成：</p>
<ul>
<li>页号</li>
<li>页内偏移量</li>
</ul>
<p>页表项组成：</p>
<ul>
<li>虚拟页号</li>
<li>物理页号</li>
</ul>
<p><img src="图解系统学习笔记/7884f4d8db4949f7a5bb4bbd0f452609.png" alt="img" style="zoom:50%;"></p>
<p>分页解决内存外部碎片问题，但是出现内部碎片问题：</p>
<p>页与页之间紧密排列，不会出现外部碎片，但是由于每页大小固定，但是进程占多少页不清楚，而<strong>内存分配的最小单位是页</strong>，有可能进程的某部分只占了一页的一小部分大小，这时候这个页也会被标记已经使用，从而浪费掉一段空间。这浪费掉的一段空间就叫内部碎片。</p>
<p>分页提高内存交换效率：</p>
<p>内存空间不够的时候，操作系统会把正在运行的进程<strong>最近最少使用</strong>的页，给<strong>换出</strong>（swap
out）到磁盘中，等待需要的时候再<strong>换入</strong>（swap
in）内存。</p>
<p><img src="图解系统学习笔记/388a29f45fe947e5a49240e4eff13538-20230309234651917.png" alt="img" style="zoom: 40%;"></p>
<p>分页的最大优点就是：加载程序的时候，没必要一次性把程序都加载到物理内存，而是通过虚存的页映射到物理内存的页的时候，根据当前的需要加载特定的页即可。</p>
<p>缺陷：</p>
<ul>
<li><p>内部碎片</p></li>
<li><p>存储页表项需要耗费大量空间</p>
<p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是
4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4
个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code>
的内存来存储页表。这 4MB
大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</p>
<p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code>
的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p></li>
</ul>
<h3 id="多级页表">多级页表</h3>
<p>在32位系统、页大小4KB、页表项4B的情况下，一个进程的页表需要装下 100
多万个「页表项」，并且每个页表项是占用 4
字节大小的，于是相当于每个页表需占用 4MB
大小的空间，对这些页表项进行二级分页处理：</p>
<p><img src="图解系统学习笔记/19296e249b2240c29f9c52be70f611d5.png" alt="img" style="zoom: 50%;"></p>
<p>为什么二级页表会减少空间消耗？</p>
<p>假如一个进程需要4GB的内存空间，如果全部映射到物理内存，那二级页表占用空间
&gt;
一级页表，但是实际上程序执行的时候操作系统不会为该进程分配全部内存。</p>
<p>局部性原理来解释：</p>
<p>每个进程都有 4GB
的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到
4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p>
<p>如果使用了二级分页，一级页表就可以覆盖整个 4GB
虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。</p>
<ul>
<li>假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有
4KB（一级页表） + 20% * 4MB（二级页表）=
<code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 小得多</li>
</ul>
<p>64位系统的分页：</p>
<ul>
<li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li>
<li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li>
<li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li>
<li>页表项 PTE（<em>Page Table Entry</em>）；</li>
</ul>
<p><img src="图解系统学习笔记/四级分页.png" alt="img" style="zoom: 33%;"></p>
<h3 id="tlb">TLB</h3>
<p>程序是有局部性的，即<strong>在一段时间内，整个程序的执行仅限于程序中的某一部分</strong>。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p><img src="图解系统学习笔记/edce58534d9342ff89f5261b1929c754.png" alt="局部性原理" style="zoom:50%;"></p>
<p>把这些热点页进行缓存，无疑是提高效率的良好途径。于是CPU中添加了缓存：TLB（<em>Translation
Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<p><img src="图解系统学习笔记/a3cdf27646b24614a64cfc5d7ccffa35.png" alt="CPU与TLB的结构关系" style="zoom:67%;"></p>
<h2 id="段页式内存管理">段页式内存管理</h2>
<p>实现方式：</p>
<ol type="1">
<li>把程序分成多个段：代码段、栈段...</li>
<li>把每个段分成多个页</li>
</ol>
<p>虚拟地址结构：</p>
<ul>
<li>段号</li>
<li>页号</li>
<li>页内偏移量</li>
</ul>
<p><img src="图解系统学习笔记/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="段页式虚存物存映射" style="zoom:50%;"></p>
<h2 id="内存达到上限的处理">内存达到上限的处理</h2>
<h3 id="内存分配的过程">内存分配的过程</h3>
<ol type="1">
<li><p>malloc分配：申请虚拟内存，此时并没有分配物理内存</p></li>
<li><p>缺页中断：应用程序访问这片内存，发现没有映射到物理内存，CPU产生缺页中断，进程从用户态变为内核态，并将缺页中断交给内核的
Page Fault Handler （缺页中断函数）处理。</p></li>
<li><p>缺页函数判断有无空闲空间，进行分配，如果没有空闲空间，进行<strong>内存回收</strong></p></li>
</ol>
<p>内存回收：</p>
<ul>
<li>后台内存回收：唤醒kswapd
内核线程来<strong>异步</strong>的回收内存。</li>
<li>直接内存回收：假如后台回收的速度赶不上进程申请内存的速度，会将进程阻塞，转而同步回收内存。</li>
</ul>
<p>OOM机制：</p>
<p>触发条件：如果内存回收后依旧没有足够的内存分配给进程，则触发该机制。</p>
<p>作用：OOM Killer
机制会根据算法选择一个占用物理内存较高的进程，杀死该进程，（循环进行），直到有足够空间分配</p>
<p>流程：</p>
<p><img src="图解系统学习笔记/2f61b0822b3c4a359f99770231981b07.png" alt="img" style="zoom:50%;"></p>
<h3 id="可以被回收的内存">可以被回收的内存</h3>
<p><strong>文件页：</strong></p>
<ul>
<li>内核缓存的磁盘、文件数据，这些都属于干净页，可以直接释放。</li>
<li>被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），还需要先写入磁盘，才能释放内存</li>
</ul>
<p><strong>匿名页：</strong></p>
<p>没有实际载体的数据，例如：堆栈数据等</p>
<p>回收方式：Linux的Swap机制</p>
<p>LRU回收算法：</p>
<p>LRU维护的队列：</p>
<ul>
<li><strong>active_list</strong>
活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong>
不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<p>回收影响：</p>
<p>动用磁盘IO，影响机器性能。</p>
<h4 id="降低内存回收带来的性能影响">降低内存回收带来的性能影响</h4>
<h5 id="调整文件页和匿名页的回收倾向">调整文件页和匿名页的回收倾向</h5>
<p>文件页中，干净页直接回收，效率高于脏页。
一般只要动用linux的swap机制，就会触发IO</p>
<p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code>
选项，用来调整文件页和匿名页的回收倾向。</p>
<p><code>swappiness</code> 的范围是 0-100，数值越大，越积极使用
Swap，也就是更倾向于回收匿名页；数值越小，越消极使用
Swap，也就是更倾向于回收文件页。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]# cat /proc/sys/vm/swappiness</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>一般建议 swappiness 设置为 0（默认值是
60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p>
<h5 id="尽早触发-kswapd-内核线程异步回收内存">尽早触发 kswapd
内核线程异步回收内存</h5>
<p>内核定义三个内存阈值（watermark，也称为水位），用来衡量当前剩余内存（pages_free）是否充裕或者紧张，分别是：</p>
<ul>
<li>页最小阈值（pages_min）；</li>
<li>页低阈值（pages_low）；</li>
<li>页高阈值（pages_high）；</li>
</ul>
<p>对应四种内存使用情况：</p>
<p><img src="图解系统学习笔记/166bc9f5b7c545d89f1e36ab8dd772cf.png" alt="img" style="zoom:67%;"></p>
<p>kswapd
会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作：</p>
<ul>
<li>在橙色范围，kswapd 0线程会<strong>异步</strong>进行内存回收</li>
<li>在红色范围，kswapd 会进行直接内存回收。阻塞进程</li>
</ul>
<h5 id="numa-架构下的内存回收策略">NUMA 架构下的内存回收策略</h5>
<p>CPU的两种架构：</p>
<h6 id="smp架构">SMP架构</h6>
<p><img src="图解系统学习笔记/image-20231011171048345.png" alt="image-20231011171048345" style="zoom:80%;"></p>
<p>多个CPU通过一条总线共享内存资源，CPU地位相同。也被称为一致存储访问结构（UMA，Uniform
Memory Access）。</p>
<p>缺陷：总线带宽压力大，CPU越多，每个CPU分得的带宽越少。</p>
<h6 id="numa架构">NUMA架构</h6>
<p><img src="图解系统学习笔记/image-20231011171155253.png" alt="image-20231011171155253" style="zoom:80%;"></p>
<p>分组CPU思想：每组称为Node，有自己独立的内存、总线、IO等，每个 Node
之间可以通过<strong>互联模块总线</strong>（QPI）进行通信，</p>
<p>NUMA回收策略：</p>
<p>当一个结点的内存不足时，系统可以从其它结点找空闲内存，也可以对自己的内存空间进行释放。</p>
<p>具体选哪种模式，可以通过 /proc/sys/vm/zone_reclaim_mode
来控制。它支持以下几个选项：</p>
<ul>
<li>0 （默认值）：在回收本地内存之前，在其他 Node 寻找空闲内存；</li>
<li>1：只回收本地内存；</li>
<li>2：只回收本地内存，在本地回收内存时，可以将文件页中的脏页写回硬盘，以回收内存。</li>
<li>4：只回收本地内存，在本地回收内存时，可以用 swap 方式回收内存。</li>
</ul>
<blockquote>
<p>虽然说访问远端 Node
的内存比访问本地内存要耗时很多，但是相比内存回收的危害而言，访问远端
Node 的内存带来的性能影响还是比较小的。因此，zone_reclaim_mode
一般建议设置为 0。</p>
</blockquote>
<h3 id="如何保证进程不被oom杀死">如何保证进程不被OOM杀死</h3>
<p>linux系统根据<strong>某种标准</strong>杀死进程：</p>
<p>在 Linux 内核里有一个 <code>oom_badness()</code>
函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。</p>
<p>影响得分因素：</p>
<ul>
<li>进程使用的物理页面数</li>
<li>每个进程的 OOM 校准值 <code>oom_score_adj</code>。它是可以通过
<code>/proc/[pid]/oom_score_adj</code> 来配置的。我们可以在设置 -1000 到
1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。</li>
</ul>
<p>函数 oom_badness() 里的最终计算方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// points 代表打分的结果</span></span><br><span class="line"><span class="comment">// process_pages 代表进程已经使用的物理内存页面数</span></span><br><span class="line"><span class="comment">// oom_score_adj 代表 OOM 校准值</span></span><br><span class="line"><span class="comment">// totalpages 代表系统总的可用页面数</span></span><br><span class="line">points = process_pages + oom_score_adj*totalpages/<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>不想杀死一个进程，就把校准值降低。</p>
<blockquote>
<p>一般来说，我们最好将一些很重要的系统服务的 oom_score_adj 配置为
-1000，比如
sshd，因为这些系统服务一旦被杀掉，我们就很难再登陆进系统了。</p>
</blockquote>
<h1 id="进程管理">进程管理</h1>
<h2 id="进程">进程</h2>
<p>编写的代码——&gt; 编译为二进制文件——&gt;CPU执行每一条指令</p>
<p>正在运行中的程序叫做进程。</p>
<p>提高CPU利用率：<strong>并发</strong>技术，多程序交替运行。</p>
<ul>
<li>只不过由于时间片较短，我们的视角看上去像是每个线程都在运行一样。</li>
</ul>
<p><img src="图解系统学习笔记/4-进程交替运行.jpg" alt="进程 1 与进程 2 切换" style="zoom:67%;"></p>
<p>并发与并行的区别：</p>
<p><img src="图解系统学习笔记/5-并发与并行.jpg" alt="并发与并行" style="zoom:67%;"></p>
<h3 id="进程状态">进程状态</h3>
<p>基础状态：</p>
<ul>
<li>运行：CPU为进程分配了时间片执行</li>
<li>就绪：可运行，<strong>但是其它进程占用了CPU</strong>导致当前进程没有执行</li>
<li>阻塞：该进程在等待某一事件结束（如磁盘IO），这时即使CPU给它时间片它也不会执行。</li>
</ul>
<p><img src="图解系统学习笔记/7-进程三个基本状态.jpg" alt="进程的三种基本状态" style="zoom:67%;"></p>
<ul>
<li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li>
<li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态</li>
</ul>
<p><img src="图解系统学习笔记/8-进程五个状态.jpg" alt="进程五种状态的变迁" style="zoom: 67%;"></p>
<p>在有虚拟内存管理的系统，一般把处于阻塞状态的进程所占的内存页给swap到磁盘，节省内存空间。而被换出的进程有一个独立的状态，叫做
<strong>挂起状态</strong>，只要是处于挂起状态，那就是在外存里</p>
<ul>
<li>阻塞挂起：在外存等待某一事件的发生</li>
<li>就绪挂起：在外存就绪，进入内存就变成就绪状态</li>
</ul>
<p><img src="图解系统学习笔记/image-20231012144137284.png" alt="image-20231012144137284" style="zoom:67%;"></p>
<h3 id="进程控制结构">进程控制结构</h3>
<p>进程的描述：由进程控制块PCB（<em>process control
block</em>）这一数据结构描述。</p>
<p>PCB信息：</p>
<ul>
<li>进程描述信息
<ul>
<li>进程标识符：标识进程的唯一id，pid</li>
<li>用户标识符：进程所属用户的id</li>
</ul></li>
<li>进程控制和管理信息
<ul>
<li>进程当前状态</li>
<li>进程优先级</li>
</ul></li>
<li>资源分配清单
<ul>
<li>内存地址空间、虚拟地址空间、进程所使用的IO设备、所打开文件列表</li>
</ul></li>
<li>CPU相关信息
<ul>
<li>CPU各寄存器的值，当进程进行上下文切换时，会告知CPU上次运行到哪了、变量的值等信息</li>
</ul></li>
</ul>
<p>PCB的组织：</p>
<p>根据状态分配，相同状态的线程串成链表：</p>
<p><img src="图解系统学习笔记/12-PCB状态链表组织.jpg" alt="就绪队列和阻塞队列" style="zoom:67%;"></p>
<h3 id="进程的控制">进程的控制</h3>
<h4 id="创建">创建</h4>
<p>由于进程由PCB管理：</p>
<ol type="1">
<li>申请空白PCB：并填写相关基本管理信息，比如进程pid等</li>
<li>分配资源：比如内存资源</li>
<li>将PCB放入就绪队列，等待运行</li>
</ol>
<h4 id="终止">终止</h4>
<p>终止方式：</p>
<ul>
<li>正常执行结束</li>
<li>异常结束</li>
<li>外界干扰：如kill指令</li>
</ul>
<p>父进程与子进程的终止：当子进程结束后，需要把从父进程继承而来的资源还回去。当父进程结束后，子进程变成孤儿进程，会被一号进程收留。</p>
<p>终止过程：</p>
<ol type="1">
<li>查找对应进程的PCB</li>
<li>如果处于执行状态，立即终止，<strong>将CPU资源转让给别的进程</strong></li>
<li>如果有子进程，将子进程交给1号进程</li>
<li>将<strong>全部资源</strong>（内存等）归还给操作系统</li>
<li>将进程的PCB从所在队列移除</li>
</ol>
<h4 id="阻塞">阻塞</h4>
<p>当进程需要等待某一事件完成时，它可以调用<strong>阻塞语句</strong>把自己阻塞等待。</p>
<ul>
<li>被阻塞时，只能等待别的进程唤醒</li>
</ul>
<ol type="1">
<li>找到进程PCB</li>
<li>如果进程是运行状态，保护现场，记录信息，然后切换为阻塞状态</li>
<li>将PCB插入到阻塞队列</li>
</ol>
<h4 id="唤醒">唤醒</h4>
<ol type="1">
<li>从阻塞队列找到进程PCB</li>
<li>移除阻塞队列，设置为就绪队列</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li>
</ol>
<h3 id="进程上下文切换">进程上下文切换</h3>
<p>CPU上下文切换：</p>
<p>系统通常支持＞CPU个数的进程同时运行，但是这个“同时”，只是假象罢了。实际上CPU是通过进程间的不断切换，而且切换的时间间隔很小，我们就觉得进程之间都是并行的。</p>
<p>每个任务运行前，CPU
需要知道任务从哪里加载，又从哪里开始运行，这些借助CPU的<strong>寄存器（CPU缓存）、程序计数器</strong>，也就是<strong>CPU上下文</strong>。</p>
<p>CPU 上下文切换：</p>
<ol type="1">
<li>先<strong>把前一个任务的 CPU 上下文（CPU
寄存器和程序计数器）保存起来</strong></li>
<li><strong>加载新任务的上下文到这些寄存器和程序计数器</strong></li>
<li>跳转到程序计数器所指的新位置，运行新任务。</li>
</ol>
<p>进程上下文切换：</p>
<p>用户资源（虚拟内存、栈、全局变量等），内核资源（堆栈、寄存器等）都会切换</p>
<figure>
<img src="图解系统学习笔记/13-进程上下文切换.jpg" alt="进程上下文切换">
<figcaption aria-hidden="true">进程上下文切换</figcaption>
</figure>
<p>进程上下文切换的场景：</p>
<ul>
<li>为了保证所有进程可以得到公平调度，CPU
时间被划分为一段段的时间片，这些<strong>时间片再被轮流分配</strong>给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li><strong>进程在系统资源不足（比如内存不足）时</strong>，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li>
<li>当<strong>进程通过睡眠函数 sleep</strong>
这样的方法将自己主动挂起时，自然也会重新调度；</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li>
<li>发生<strong>硬件中断</strong>时，CPU
上的进程会被中断挂起，转而执行内核中的中断服务程序；</li>
</ul>
<h2 id="线程">线程</h2>
<p>进程内的新执行单位，共享进程内存，是进程里的执行流程，</p>
<p><img src="图解系统学习笔记/16-多线程内存结构.jpg" alt="多线程" style="zoom:67%;"></p>
<p>线程的优点：</p>
<ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以并发执行；</li>
<li>各个线程之间可以共享地址空间和文件等资源；</li>
</ul>
<p>线程的缺点：</p>
<ul>
<li>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对
C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃</li>
</ul>
<p>线程与进程的比较：</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 37%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>单位</td>
<td>资源分配单位</td>
<td>CPU调度单位</td>
</tr>
<tr class="even">
<td>资源拥有量</td>
<td>完整的资源平台</td>
<td>只独享必不可少的资源，如寄存器和栈；</td>
</tr>
<tr class="odd">
<td>状态</td>
<td>基本状态</td>
<td>具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</td>
</tr>
<tr class="even">
<td>创建时间开销</td>
<td>慢</td>
<td>快，因为共享进程的资源信息，无需加载</td>
</tr>
<tr class="odd">
<td>终止时间</td>
<td>慢</td>
<td>快，因为线程释放的资源相比进程少很多；</td>
</tr>
<tr class="even">
<td>上下文切换开销</td>
<td>要切换页表（每个进程对应一个页表），速度较慢</td>
<td>因为共享进程内存资源空间，无需切换页表</td>
</tr>
</tbody>
</table>
<p><strong>线程线程上下文切换：</strong></p>
<p><strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p>
<ul>
<li>当进程仅有一个线程（main），进程 ≈ 线程</li>
<li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；</li>
</ul>
<h3 id="线程的实现">线程的实现</h3>
<p>三种线程：</p>
<ul>
<li>用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li>内核线程：在内核中实现的线程，是由内核管理的线程</li>
<li>轻量级线程：在内核中来支持用户线程；</li>
</ul>
<p>用户线程和内核线程的关系：</p>
<p>一对一：</p>
<p><img src="图解系统学习笔记/18-内核线程与用户线程-一对一关系.jpg" alt="一对一" style="zoom:50%;"></p>
<p>多对一：</p>
<p><img src="图解系统学习笔记/17-内核线程与用户线程-一对多关系.jpg" alt="多对一" style="zoom: 50%;"></p>
<p>多对多：</p>
<p><img src="图解系统学习笔记/19-内核线程与用户线程-多对多关系.jpg" alt="多对多" style="zoom:50%;"></p>
<p><strong>用户线程：</strong></p>
<p>基于用户态的<strong>线程管理库</strong>来实现的，那么<strong>线程控制块（*Thread
Control Block, TCB*）</strong> 也是在库里面来实现的。</p>
<p>用户线程的整个调度和管理，只由用户线程库管理（自管理），操作系统不参与</p>
<p><img src="图解系统学习笔记/20-线程PCB-一对多关系.jpg" alt="用户级线程模型" style="zoom:50%;"></p>
<p>用户线程的<strong>优点</strong>：</p>
<ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB
由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</li>
<li>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</li>
</ul>
<p>用户线程的<strong>缺点</strong>：</p>
<ul>
<li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li>
<li>当一个线程开始运行后，除非它主动地交出 CPU
的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</li>
<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li>
</ul>
<p><strong>内核线程：</strong></p>
<p><strong>内核线程是由操作系统管理的，线程对应的 TCB
自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</strong></p>
<p>内核线程的模型，也就类似前面提到的<strong>一对一</strong>的关系，即一个用户线程对应一个内核线程，如下图所示：</p>
<p><img src="图解系统学习笔记/21-线程PCB-一对一关系.jpg" alt="内核线程模型" style="zoom:50%;"></p>
<p>内核线程的<strong>优点</strong>：</p>
<ul>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运行时间；</li>
</ul>
<p>内核线程的<strong>缺点</strong>：</p>
<ul>
<li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如
PCB 和 TCB；</li>
<li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；</li>
</ul>
<p><strong>轻量级线程</strong></p>
<p>定义：内核支持的用户级线程，<strong>（Light-weight
process，LWP）</strong>，进程可以有多个LWP，每个LWP和内核线程一对一映射。</p>
<p>在 LWP 之上也是可以使用用户线程的，那么 LWP
与用户线程的对应关系就有三种：</p>
<ul>
<li><code>1 : 1</code>，即一个 LWP 对应 一个用户线程；</li>
<li><code>N : 1</code>，即一个 LWP 对应多个用户线程；</li>
<li><code>M : N</code>，即多个 LWP 对应多个用户线程；</li>
</ul>
<p>接下来针对上面这三种对应关系说明它们优缺点。先看下图的 LWP 模型：</p>
<p><img src="图解系统学习笔记/22-LWP.jpg" alt="LWP 模型" style="zoom: 33%;"></p>
<h3 id="多线程冲突">多线程冲突</h3>
<h4 id="竞争与协作">竞争与协作</h4>
<p>CPU执行线程时的并发：</p>
<p><img src="图解系统学习笔记/3-并发.jpg" alt="并发" style="zoom:50%;"></p>
<p>并发安全问题：</p>
<p>假如每个线程都执行以下步骤：</p>
<p><img src="图解系统学习笔记/8-汇编语句赋值过程.jpg" alt="img" style="zoom: 50%;"></p>
<p>由于<strong>CPU时钟中断</strong>的存在，这些指令并不是原子操作，导致线程可能执行到第二步就被中断，转而运行另一个线程，于是就发送了<strong>丢失修改</strong>，这一现象。如图：</p>
<p><img src="图解系统学习笔记/9-汇编语句-赋值过程-竞争.jpg" alt="蓝色表示线程 1 ，红色表示线程 2" style="zoom:50%;"></p>
<h5 id="互斥">互斥</h5>
<p>多线程<strong>竞争临界资源</strong>的行为就叫互斥（竞争条件），</p>
<p>临界区：操作共享变量的代码块</p>
<ul>
<li>这段代码不能给多线程运行，也就是要保证<strong>互斥</strong></li>
</ul>
<p><img src="图解系统学习笔记/10-临界区.jpg" alt="互斥" style="zoom:50%;"></p>
<h5 id="同步">同步</h5>
<p>多线程之间要合作完成某项工作，要保证线程间的执行顺序。</p>
<h4 id="互斥和同步的实现">互斥和同步的实现</h4>
<h5 id="锁">锁</h5>
<p>进入临界区前，必须获得锁才能执行。</p>
<p>原子指令<strong>Test-and-Set</strong></p>
<figure>
<img src="图解系统学习笔记/image-20231013173136692.png" alt="image-20231013173136692">
<figcaption aria-hidden="true">image-20231013173136692</figcaption>
</figure>
<p>忙等待锁：</p>
<p>源码：</p>
<p><img src="图解系统学习笔记/image-20231013173231704.png" alt="image-20231013173231704" style="zoom:67%;"></p>
<p>锁的工作流程：</p>
<p>场景一：锁空闲，有一个线程申请锁，调用lock方法，由于锁初值为0，进入到while里0
！= 1，于是跳出循环，获得锁</p>
<p>场景二：锁已经被占用，当一个线程申请锁，此时flag就是1，会一直满足while循环条件，会一直等待锁释放以后获得锁才行。</p>
<h5 id="信号量">信号量</h5>
<p>PV操作算法实现：</p>
<p><img src="图解系统学习笔记/17-操作系统PV算法描述-16973795960521.jpg" alt="PV 操作的算法描述" style="zoom:25%;"></p>
<h5 id="生产者消费者问题">生产者消费者问题</h5>
<figure>
<img src="图解系统学习笔记/20-生产者消费者.jpg" alt="生产者-消费者模型">
<figcaption aria-hidden="true">生产者-消费者模型</figcaption>
</figure>
<p>问题概述：</p>
<ul>
<li><strong>生产者</strong>在生成数据后，放在一个缓冲区中；</li>
<li><strong>消费者</strong>从缓冲区取出数据处理；</li>
<li>任何时刻，<strong>只能有一个</strong>生产者或消费者可以访问缓冲区；</li>
</ul>
<p>问题剖析：</p>
<ul>
<li>缓冲区是临界代码，互斥</li>
<li>生产者、消费者需要同步操作，</li>
</ul>
<p>信号量设置：</p>
<ul>
<li>互斥信号量 <code>mutex</code>：用于互斥访问缓冲区，初始化值为
1；</li>
<li>资源信号量
<code>fullBuffers</code>：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为
0（表明缓冲区一开始为空）；</li>
<li>资源信号量
<code>emptyBuffers</code>：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为
n （缓冲区大小）；</li>
</ul>
<p><img src="图解系统学习笔记/21-生产者消费者代码示例.jpg" alt="img" style="zoom:25%;"></p>
<ul>
<li>规律：操作信号量必须有一对PV操作，不能单独P或者单独V</li>
</ul>
<h4 id="经典同步问题">经典同步问题</h4>
<h5 id="哲学家就餐">哲学家就餐</h5>
<p><img src="图解系统学习笔记/23-哲学家进餐模型.jpg" alt="哲学家就餐的问题" style="zoom:50%;"></p>
<p>问题描述：</p>
<ul>
<li><code>5</code> 个哲学家，闲着没事做，围绕着一张圆桌吃面；</li>
<li>巧就巧在，这个桌子只有 <code>5</code>
支叉子，每两个哲学家之间放一支叉子；</li>
<li>哲学家围在一起先思考，思考中途饿了就会想进餐；</li>
<li><strong>奇葩的是，这些哲学家要两支叉子才愿意吃面，也就是需要拿到左右两边的叉子才进餐</strong>；</li>
<li><strong>吃完后，会把两支叉子放回原处，继续思考</strong>；</li>
</ul>
<p><strong>方案一，利用PV操作：</strong></p>
<p><img src="图解系统学习笔记/image-20231016190252520.png" alt="image-20231016190252520" style="zoom: 67%;"></p>
<p>死锁问题：假如每个哲学家同时拿了左手边的叉子，则所有的哲学家都会卡在P(fork[(i
+ 1) % n]);</p>
<p><strong>方案二，全局互斥</strong></p>
<p><img src="图解系统学习笔记/26-哲学家进餐-方案二示例.jpg" alt="img" style="zoom: 25%;"></p>
<p>效率低下问题：当一个线程顺利抢到锁，进入临界区，但是由于锁只有一个，没抢到锁的直接要等这个抢到锁的吃完才能抢叉子，造成资源浪费，如下：</p>
<p><img src="图解系统学习笔记/27-哲学家进餐-方案二问题.jpg" alt="方案二的问题" style="zoom: 50%;"></p>
<p><strong>方案三，奇偶分明</strong></p>
<p>改进方案一，不让全部哲学家都拿左边的等右边的，<strong>即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。</strong></p>
<p><img src="图解系统学习笔记/28-哲学家进餐-方案三示例.jpg" alt="img" style="zoom:25%;"></p>
<p><strong>方案四，多状态</strong></p>
<p>设置每个哲学家三个状态：</p>
<ul>
<li>思考态：吃饱了</li>
<li>就餐态：</li>
<li>饥饿态：等待就餐</li>
</ul>
<p>哲学家要在左右两个哲学家都没有就餐的时候，才能就餐。</p>
<p>第i个哲学家，左邻右舍分别为： (i - 1 + 5) % 5， (i + 1) % 5</p>
<p><img src="图解系统学习笔记/30-哲学家进餐-方案四示例.jpg" alt="img" style="zoom:25%;"></p>
<p>流程：</p>
<p><img src="图解系统学习笔记/31-哲学家进餐-方案四-图解.jpg" alt="方案四也可解决问题" style="zoom: 50%;"></p>
<h5 id="读者-写者问题">读者-写者问题</h5>
<p>「读者-写者」，它为数据库访问建立了一个模型。读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。</p>
<p>问题描述：</p>
<ul>
<li>「读-读」允许：同一时刻，允许多个读者同时读</li>
<li>「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写</li>
<li>「写-写」互斥：没有其他写者时，写者才能写</li>
</ul>
<p><strong>方案一，信号量——读者优先/写者优先</strong></p>
<p>读者有多个，对读者计数</p>
<p>写者只有一个，设立互斥锁信号量，</p>
<p>读写互斥，有写不能有读，有读不能有写。</p>
<p>读者优先：</p>
<ul>
<li>信号量 <code>wMutex</code>：控制写操作的互斥信号量，初始值为 1
；</li>
<li>读者计数 <code>rCount</code>：正在进行读操作的读者个数，初始化为
0；</li>
<li>信号量 <code>rCountMutex</code>：控制对 rCount
读者计数器的互斥修改，初始值为 1；</li>
</ul>
<p><img src="图解系统学习笔记/32-读者写者-方案一示例.jpg" alt="img" style="zoom:25%;"></p>
<p>写者优先：</p>
<ul>
<li>信号量 <code>rMutex</code>：控制读者进入的互斥信号量，初始值为
1；</li>
<li>信号量 <code>wDataMutex</code>：控制写者写操作的互斥信号量，初始值为
1；</li>
<li>写者计数 <code>wCount</code>：记录写者数量，初始值为 0；
——写者优先的关键</li>
<li>信号量 <code>wCountMutex</code>：控制 wCount 互斥修改，初始值为
1；</li>
</ul>
<p><img src="图解系统学习笔记/33-读者写者-方案二示例.jpg" alt="img" style="zoom:25%;"></p>
<p><strong>方案三：公平策略</strong></p>
<ul>
<li>优先级相同；</li>
<li>写者、读者互斥访问；</li>
<li>只能一个写者访问临界区；</li>
<li>可以有多个读者同时访问临界资源；</li>
</ul>
<p>定义全局信号量flag</p>
<p><img src="图解系统学习笔记/34-读者写者-方案三示例.jpg" alt="img" style="zoom:25%;"></p>
<ul>
<li>flag信号量它让读者和写者产生<strong>排队</strong>，不像方案一，读者后续进来，也会优先排队，排在读者序列，永远都是写者最后执行结束。但加了flag，保证了写者和读者竞争的公平性。</li>
<li>写者与写者之间的互斥通过<code>wDataMutex</code>控制</li>
<li>读者与写者阻塞也靠<code>wDataMutex</code></li>
</ul>
<h2 id="锁-1">锁</h2>
<h3 id="互斥锁与自旋锁">互斥锁与自旋锁</h3>
<p>最底层的两种锁，高级的锁都是基于互斥 + 自旋锁实现。</p>
<p>两者的区别：加锁失败后的处理过程不一样。</p>
<ul>
<li>互斥锁：加锁失败后，线程释放CPU，给其它线程</li>
<li>自旋锁：加锁失败后，线程忙等待，直到拿到锁</li>
</ul>
<p><strong>互斥锁</strong></p>
<p>独占锁，加锁失败后会阻塞，锁空闲的时候又会被唤醒继续抢锁。这些操作由操作系统内核实现，</p>
<p><img src="图解系统学习笔记/互斥锁工作流程.png" alt="img" style="zoom: 50%;"></p>
<ul>
<li>加锁失败：线程从用户态变为内核态，由内核帮我们唤醒线程</li>
<li>开销成本：两次线程上下文切换
<ul>
<li>加锁失败：运行态 -&gt; 休眠态</li>
<li>锁释放的唤醒：睡眠态 -&gt; 就绪态</li>
</ul></li>
</ul>
<p>建议使用场景：被锁住的代码执行时间短，就没必要用互斥锁</p>
<p><strong>自旋锁</strong></p>
<p>借助CPU提供的CAS原子指令，只在用户态完成线程的上下文切换</p>
<p>加锁步骤：</p>
<ol type="1">
<li>判断锁的状态，锁空闲，执行下一步</li>
<li>将锁设置为该线程持有</li>
</ol>
<p>以上俩步骤为原子指令</p>
<p>比如，设锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程
ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0)
则表示解锁操作。</p>
<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用
<code>while</code> 循环等待实现，不过最好是使用 CPU 提供的
<code>PAUSE</code>
指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>
<blockquote>
<p>注意：单核cpu环境下，需要CPU有中断处理的功能，因为自旋状态下的线程是不会释放CPU资源的，会造成其它线程饿死。</p>
</blockquote>
<h3 id="读写锁">读写锁</h3>
<p>作用：明确区分读写场景</p>
<p>应用场景：读多写少</p>
<p>工作原理：</p>
<ul>
<li>当写锁没有被线程持有，多个线程能并发获取读锁，提高读效率</li>
<li>当写锁被线程持有，剩下的读线程和写线程都会被阻塞，保证了数据一致性</li>
</ul>
<p><strong>读优先锁</strong></p>
<p><img src="图解系统学习笔记/读优先锁工作流程.png" alt="img" style="zoom:50%;"></p>
<p><strong>写优先锁</strong></p>
<p><img src="图解系统学习笔记/写优先锁工作流程.png" alt="img" style="zoom:50%;"></p>
<p>两种锁都会造成另一方的饥饿现象，因此采用公平策略最好：选择队列，先进来的无论读写，先工作。</p>
<h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3>
<p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p>
<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p>
<h4 id="在线文档案例">在线文档案例</h4>
<p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>
<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>
<p>怎么样才算发生冲突？这里举个例子，比如用户 A
先在浏览器编辑文档，之后用户 B
在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A
提交早，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B
之间并行修改的地方就会发生冲突。</p>
<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>
<ul>
<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>
<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号不一致则提交失败，如果版本号一致则修改成功，然后服务端版本号更新到最新的版本号。</li>
</ul>
<p>实际上，我们常见的 SVN 和 Git
也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>
<h3 id="死锁">死锁</h3>
<p>概念：两个（或者多个）线程互相等待对方的锁释放的场景。</p>
<p>死锁的条件：</p>
<ul>
<li><p>互斥：多个线程不能使用同一个资源</p></li>
<li><p>不剥夺：线程持有的资源未使用完不会释放也不会被剥夺</p></li>
<li><p>循环等待：多个线程获取资源的顺序构成环路</p>
<figure>
<img src="图解系统学习笔记/环路等待条件.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>请求与保持：线程拥有一个资源，还去请求另一个资源，但是又保持自己已有的资源不释放</p></li>
</ul>
<h4 id="避免死锁">避免死锁</h4>
<p>破坏其中一个条件，常用：</p>
<h5 id="资源有序分配法">资源有序分配法</h5>
<p>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源
A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源
A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B
总是以相同的顺序申请自己想要的资源。</p>
<h2 id="调度">调度</h2>
<h3 id="调度时机">调度时机</h3>
<p>涉及到进程状态变化，都会触发调度：</p>
<ul>
<li>运行 -&gt; 就绪</li>
<li>运行 -&gt; 阻塞</li>
<li>就绪 -&gt; 运行</li>
</ul>
<p>如果硬件时钟提供周期性中断，可以根据如何处理时钟中断
，把调度算法分为两类：</p>
<ul>
<li>抢占式：挑选一个进程，运行一段时间后终止。</li>
<li>非抢占式：挑选一个进程，直到该进程运行到阻塞（或者运行到结束）为止。</li>
</ul>
<h3 id="调度原则">调度原则</h3>
<p>原则：</p>
<ol type="1">
<li>提高CPU利用率：在发生IO请求的程序事件时，CPU必须将时间片交给其它程序执行，无需等待这个程序等待IO的时间</li>
<li>提高系统吞吐率：调度程序衡量长任务和短任务的执行数量</li>
<li>降低程序平均周转时间：进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间两个时间总和就称为周转时间。</li>
<li>就绪队列的进程不能等太久</li>
<li>交互式比较强的应用，提高响应率。</li>
</ol>
<p>量化：</p>
<ul>
<li><strong>CPU 利用率</strong>：调度程序应确保 CPU
是始终匆忙的状态，这可提高 CPU 的利用率</li>
<li><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU
完成进程的数量，长作业的进程会占用较长的 CPU
资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量</li>
<li><strong>周转时间</strong>：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好</li>
<li><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意</li>
<li><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<h4 id="先来先服务">先来先服务</h4>
<p><strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<figure>
<img src="图解系统学习笔记/24-先来先服务.jpg" alt="FCFS 调度算法">
<figcaption aria-hidden="true">FCFS 调度算法</figcaption>
</figure>
<p>长作业优先，不利于短作业。</p>
<h4 id="短作业优先">短作业优先</h4>
<figure>
<img src="图解系统学习笔记/25-最短作业优先算法.jpg" alt="SJF 调度算法">
<figcaption aria-hidden="true">SJF 调度算法</figcaption>
</figure>
<h4 id="高响应比">高响应比</h4>
<p>响应比计算公式：（等待时间 + 要求服务时间 ）/ 要求服务时间</p>
<p>每次进程调度时，计算每个进程的响应比数值，然后把响应比最高的进程投入运行。</p>
<p>本算法无法知道进程的要求服务时间，是一个理想算法。</p>
<h4 id="时间片轮转">时间片轮转</h4>
<p><img src="图解系统学习笔记/27-时间片轮询.jpg" alt="RR 调度算法" style="zoom:67%;"></p>
<p>每个进程分一个时间片，时间片执行完毕立刻切换其它进程，当然如果进程在这一个时间片内执行结束，CPU会立即切换其它进程，并为其分配新的时间片。</p>
<p>缺点：</p>
<ul>
<li>时间片过短，会导致频繁切换，影响系统性能</li>
<li>时间片过长，会产生饥饿现象</li>
</ul>
<p>一般来说，时间片设为 <code>20ms~50ms</code>
通常是一个比较合理的折中值。</p>
<h4 id="高优先级">高优先级</h4>
<p>进程的优先级：</p>
<ul>
<li>动态优先级：根据进程的运行状态分配优先级，如果进程运行时间长了，降低优先级;如果进程等待时间增加，升高其优先级</li>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
</ul>
<p>缺陷：</p>
<ul>
<li>饥饿现象：低优先级的进程可能永远不会执行。</li>
</ul>
<h4 id="多级反馈队列">多级反馈队列</h4>
<p>时间片轮转 + 最高优先级的综合实现。</p>
<ul>
<li>多级：多层级进程任务队列</li>
<li>反馈：有新的进程进入优先级高的队列，直接去服务新的进程。</li>
</ul>
<p>队列示意图：</p>
<p><img src="图解系统学习笔记/28-多级队列.jpg" alt="多级反馈队列" style="zoom:67%;"></p>
<p>工作流程：</p>
<ol type="1">
<li>设置多个队列，队列从1级 —— n级
优先级降低，但是每一级的时间片长度增加</li>
<li>新进程进入队列，首先进入一级队列执行，分配1级时间片，如果进程没有执行完，则进入下一级队列的队尾，以此类推，直到执行完毕</li>
<li>只有较高优先级的队列为空，才能执行低优先级队列。</li>
</ol>
<p>优点：</p>
<ol type="1">
<li>长短作业兼顾（长作业到后面时间片更久，短作业刚进来可以被先执行）</li>
<li>响应时间良好（兼顾了每一个进来的程序）</li>
</ol>
<h2 id="进程间的通信">进程间的通信</h2>
<h3 id="管道">管道</h3>
<h4 id="linux的-命令">Linux的 | 命令</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep mysql</span><br></pre></td></tr></table></figure>
<p>命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>：</p>
<ul>
<li>功能：将前一个命令的输出，作为后一个命令的输入</li>
<li>传输方向：管道传输数据单向</li>
<li>名称：没有名字，称为匿名管道</li>
</ul>
<p>命名管道：</p>
<p>创建： <code>mkfifo myPipe</code></p>
<p>管道也是文件，ls查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure>
<ul>
<li>p开头，就是pipe</li>
</ul>
<p>写入数据的时候，必须有一方来接收写入的数据，否则会阻塞。</p>
<p>匿名管道原理：</p>
<p><code>|</code> 进行了系统调用：<code>int pipe(int fd[2])</code></p>
<p><img src="图解系统学习笔记/5-管道-pipe.jpg" alt="img" style="zoom:50%;"></p>
<p>管道的本质：内核里的缓存</p>
<p>A|B模型：</p>
<p><img src="图解系统学习笔记/8-管道-pipe-shell.jpg" alt="img" style="zoom:50%;"></p>
<p>两个进程通信模型：</p>
<p><img src="图解系统学习笔记/6-管道-pipe-fork.jpg" alt="img" style="zoom: 50%;"></p>
<p>保证一读一写：</p>
<ul>
<li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li>
<li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
</ul>
<h3 id="消息队列">消息队列</h3>
<p>进程把要发送的数据封装成<strong>消息单元</strong>，放入消息队列，就可以返回了。</p>
<ul>
<li><strong>消息队列是保存在内核中的消息链表</strong></li>
</ul>
<p>优势：效率、响应能力都较出色</p>
<p>缺陷：通信不及时、消息体有大小限制</p>
<h3 id="共享内存">共享内存</h3>
<p>如果两个进程A和B想进行通信，A、B都有自己的虚拟内存空间，那就直接把这俩进程的虚拟内存映射到相同的物理内存上，两个进程通信的内容都在共享内存区域呈现。</p>
<p><img src="图解系统学习笔记/9-共享内存.jpg" alt="img" style="zoom:50%;"></p>
<ul>
<li>效率很高</li>
</ul>
<p>缺陷：可能会发生写写冲突</p>
<h3 id="信号量-1">信号量</h3>
<p>概念：信号量相当于整型的计数器</p>
<p>作用：用于实现进程间的同步与互斥，并不缓存进程之间的通信数据。</p>
<p>控制信号量的方式：</p>
<ul>
<li>P操作：信号量-1，减后如果信号量 &lt;
0，则表示当前资源被占用进程需阻塞等待；相减后如果信号量 &gt;=
0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>V操作：信号量+1，相加后如果信号量 &lt;=
0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量
&gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<h4 id="信号量初值">信号量初值</h4>
<p>信号量初始化为1：</p>
<p>A、B进程访问资源：</p>
<ul>
<li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为
1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A
就可以访问共享内存。</li>
<li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了
-1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li>
<li><strong>直到进程 A 访问完共享内存，才会执行 V
操作</strong>，<strong>使得信号量恢复为 0，接着就会唤醒阻塞中的线程
B</strong>，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行
V 操作，使信号量恢复到初始值 1。</li>
</ul>
<p>结论：信号量初值为1，相当于<strong>互斥信号量</strong></p>
<p>信号量初值为0：</p>
<p><img src="图解系统学习笔记/11-信号量-同步.jpg" alt="img" style="zoom:67%;"></p>
<ul>
<li>如果进程B先于A执行，P操作结束后，信号量为-1，表示A未生产数据，B阻塞</li>
<li>A执行后，触发V操作，信号量+1，这时B会被唤醒，读取数据</li>
</ul>
<p>结论：信号量为0，相当于<strong>同步信号量</strong></p>
<h3 id="信号">信号</h3>
<p>应用于非常规情况的工作模式，linux常用信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<p>通信机制：异步</p>
<p>用户进程对信号的处理：</p>
<p><strong>1.执行默认操作</strong>。Linux
对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM
信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即
<code>SIGKILL</code> 和
<code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
<h3 id="socket网络通信">Socket网络通信</h3>
<p>作用：跨网络与其它主机通信</p>
<p>系统调用：<code>int socket(int domain, int type, int protocal)</code></p>
<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于
IPV6、AF_LOCAL/AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应
TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW
表示的是原始套接字；</li>
<li>protocal
参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol
目前一般写成 0 即可；</li>
</ul>
<p>socket的类型决定，通信方式也不同：</p>
<ul>
<li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和
SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和
SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地
socket；</li>
</ul>
<p>基于TCP通信模型：</p>
<p><img src="图解系统学习笔记/12-TCP编程模型.jpg" alt="img" style="zoom:50%;"></p>
<p>基于UDP通信模型：</p>
<p><img src="图解系统学习笔记/13-UDP编程模型.jpg" alt="img" style="zoom: 67%;"></p>
<h2 id="常见面试题">常见面试题</h2>
<h1 id="调度算法-1">调度算法</h1>
<h2 id="内存页面置换算法">内存页面置换算法</h2>
<p>缺页中断的概念：</p>
<p>当 CPU
访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。</p>
<p>与一般中断的区别：</p>
<ul>
<li>缺页中断在<strong>指令执行期间</strong>产生和处理中断信号，而一般中断在一条<strong>指令执行完成</strong>后检查和处理中断信号。</li>
<li>缺页中断返回到该指令的开始<strong>重新执行该指令</strong>，而一般中断返回回到该指令的<strong>下一个指令</strong>执行。</li>
</ul>
<p><img src="图解系统学习笔记/缺页异常流程.png" alt="缺页中断的处理流程" style="zoom: 50%;"></p>
<p>假如第三、四步，找不到对应的页表，就会采用页面置换，将要访问的页从磁盘里换进来。</p>
<p>页表项通常有如下图的字段：</p>
<figure>
<img src="图解系统学习笔记/页表项字段.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>那其中：</p>
<ul>
<li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li>
<li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li>
<li><em>修改位</em>：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。</li>
<li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li>
</ul>
<p><img src="图解系统学习笔记/虚拟内存管理流程.png" alt="虚拟内存的流程" style="zoom: 50%;"></p>
<h3 id="最佳页面置换算法">最佳页面置换算法</h3>
<p>算法思想：发生缺页时，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
<figure>
<img src="图解系统学习笔记/最优置换算法.png" alt="最佳页面置换算法">
<figcaption aria-hidden="true">最佳页面置换算法</figcaption>
</figure>
<p>缺陷：</p>
<ul>
<li>理想算法，无法实现，最佳页面置换算法作用是为了衡量其它算法的效率，其它算法效率越接近该算法的效率，那么说明其它算法是高效的。</li>
</ul>
<h3 id="先进先出置换算法">先进先出置换算法</h3>
<p>算法思想：发生缺页时，选择在内存中驻留时间最长的页进行置换</p>
<figure>
<img src="图解系统学习笔记/FIFO置换算法.png" alt="先进先出置换算法">
<figcaption aria-hidden="true">先进先出置换算法</figcaption>
</figure>
<p>缺陷：</p>
<ul>
<li>效率低</li>
</ul>
<h3 id="最近最久未使用置换算法">最近最久未使用置换算法</h3>
<p>算法思想：发生缺页时，选择最长时间（相对当前时刻）没有访问的页面进行切换</p>
<figure>
<img src="图解系统学习笔记/LRU置换算法.png" alt="最近最久未使用的置换算法">
<figcaption aria-hidden="true">最近最久未使用的置换算法</figcaption>
</figure>
<p>缺陷：</p>
<ul>
<li>实现难：底层需要实现双向链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</li>
<li>开销大：每次访问内存，都要更新一遍链表。</li>
</ul>
<h3 id="时钟页面置换算法">时钟页面置换算法</h3>
<p>算法思想：结合LRU +
FIFO，将页面保存到一个环形链表中，用一个指针指向最老的页面。</p>
<p>当<strong>发生缺页中断</strong>时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0
就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1
就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0
的页面为止；</li>
</ul>
<p>不发生缺页中断，遇到访问的页面在内存中，那就将这个页面的访问位置于1。</p>
<p><img src="图解系统学习笔记/时钟置换算法.png" alt="时钟页面置换算法" style="zoom:50%;"></p>
<h3 id="最不常用置换算法">最不常用置换算法</h3>
<p>算法思想：发生缺页时，将最近访问次数最少的页面置换掉。</p>
<p>实现方式：对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加
1。</p>
<p>缺陷：</p>
<ul>
<li>无时间维度的误判：有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</li>
<li>计数器成本高：</li>
</ul>
<h2 id="磁盘调度算法寻道">磁盘调度算法——寻道</h2>
<p>磁盘结构：</p>
<p><img src="图解系统学习笔记/磁盘结构.jpg" alt="磁盘的结构" style="zoom:67%;"></p>
<ul>
<li>右边盘片的结构：盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是
<code>512</code>
字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图中间。</li>
</ul>
<h3 id="先来先服务-1">先来先服务</h3>
<p>磁道请求序列：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>那么，磁盘的写入顺序是从左到右，如下图：</p>
<p><img src="图解系统学习笔记/磁盘调度-先来先服务.png" alt="先来先服务" style="zoom:67%;"></p>
<p>缺点：</p>
<ul>
<li>寻道时间过长，效率低下</li>
</ul>
<h3 id="最短寻道时间优先">最短寻道时间优先</h3>
<p>最短寻道时间优先（<em>Shortest Seek
First，SSF</em>）算法的工作方式是，<strong>优先选择从当前磁头位置所需寻道时间最短的请求</strong>（也就是离磁头最近的请求优先处理）。</p>
<p>磁道请求序列：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>那么，那么根据距离磁头（ 53
位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</p>
<p>65，67，37，14，98，122，124，183</p>
<p><img src="图解系统学习笔记/磁盘调度-最短寻道时间优先.png" alt="最短寻道时间优先" style="zoom: 67%;"></p>
<p>缺陷：</p>
<ul>
<li>饥饿问题：动态请求过程中，如果一直请求靠近磁头的磁道，那远距离的磁道请求就得不到响应。</li>
</ul>
<h3 id="扫描scan电梯算法">扫描SCAN（电梯）算法</h3>
<p>算法思想：先向一个方向工作，遇到<strong>该方向上的最后一个磁道</strong>时，调换方向。</p>
<p>磁道请求序列：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</p>
<p>37，14，<code>0</code>，65，67，98，122，124，183</p>
<p><img src="图解系统学习笔记/磁盘调度-扫描算法.png" alt="扫描算法" style="zoom:67%;"></p>
<p>缺陷：</p>
<ul>
<li>响应不均匀：中间的磁道比较占便宜。</li>
</ul>
<h3 id="循环扫描c-scan算法">循环扫描C-SCAN算法</h3>
<p>算法思想：<strong>单向请求（只响应一个方向的请求）</strong>，只有磁头朝某个设定方向时，才会执行寻道请求任务，回来的过程中不处理任务，而是快速回到起始位置，继续进行下一轮的扫描。</p>
<p>磁道请求序列：</p>
<p>98，183，37，122，14，124，65，67</p>
<p>假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</p>
<p>65，67，98，122，124，183，<code>199</code>，<code>0</code>，14，37</p>
<p><img src="图解系统学习笔记/磁盘调度-C-SCAN算法.png" alt="循环扫描算法" style="zoom:67%;"></p>
<h3 id="looc与c-look算法">LOOC与C-LOOK算法</h3>
<p>为了优化扫描算法产生的，针对 SCAN 算法的优化则叫 LOOK
算法，针对C-SCAN 算法的优化则叫 C-LOOK。</p>
<p>优化思路：<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></p>
<p>LOOK：磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</p>
<p><img src="图解系统学习笔记/磁盘调度-LOOK算法.png" alt="LOOK 算法" style="zoom:67%;"></p>
<p>C-LOOK：磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</p>
<p><img src="图解系统学习笔记/磁盘调度-LOOK算法-169805346460716.png" alt="LOOK 算法" style="zoom:67%;"></p>
<h1 id="文件系统">文件系统</h1>
<h2 id="基本组成">基本组成</h2>
<p>文件系统概念：文件系统是操作系统中<strong>负责管理持久数据的子系统</strong>，负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p>
<p>基本数据单位：文件</p>
<p>文件系统的目的：组织、管理这些文件</p>
<p>Linux为每个文件分配两个数据结构：</p>
<ul>
<li>索引结点：也就是 <em>inode</em>，用来记录文件的元信息，比如 inode
编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</li>
<li>目录项：也就是
<em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li>
</ul>
<p>目录项与索引结点的关系：<strong>多对一</strong>，因为一个文件可能有多个别名。但是指向这个文件的指针只有一个（索引节点）。</p>
<h3 id="文件在磁盘的存储形式">文件在磁盘的存储形式</h3>
<p>磁盘最小的读写单位：磁盘扇区，每个扇区只有512B。</p>
<p>文件系统从磁盘最小读取单位：文件系统将<strong>磁盘多个扇区组成一个大的逻辑块</strong>，linux中逻辑块大小为4KB，一次性能读8个扇区。</p>
<p><img src="图解系统学习笔记/目录项和索引关系图-16985863111181.png" alt="目录项和索引关系图" style="zoom:67%;"></p>
<p>磁盘格式化后的区域：</p>
<ul>
<li><strong>超级块</strong>：用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。
<ul>
<li>加载内存时机：文件系统挂载时</li>
</ul></li>
<li><strong>索引节点区</strong>：用来存储索引节点；
<ul>
<li>加载内存时机：文件被访问时</li>
</ul></li>
<li><strong>数据块区</strong>：用来存储文件或目录数据；</li>
</ul>
<h2 id="虚拟文件系统">虚拟文件系统</h2>
<p>由于操作系统管理的文件系统众多，如磁盘文件系统、网络文件系统等等......
为了方便管理，对用户提供一个统一接口，于是在用户层与文件系统层添加了一层中间件，这个中间件叫做虚拟文件系统<strong>（*Virtual
File System，VFS*）。</strong></p>
<p>在 Linux
文件系统中，用户空间、系统调用、虚拟文件系统、缓存、文件系统以及存储之间的关系如下图：</p>
<p><img src="图解系统学习笔记/虚拟文件系统.png" alt="img" style="zoom: 50%;"></p>
<p>Linux
支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：</p>
<ul>
<li><em>磁盘的文件系统</em>，它是直接把数据存储在磁盘中，比如 Ext
2/3/4、XFS 等都是这类文件系统。</li>
<li><em>内存的文件系统</em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的
<code>/proc</code> 和 <code>/sys</code>
文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li>
<li><em>网络的文件系统</em>，用来访问其他计算机主机数据的文件系统，比如
NFS、SMB 等等。</li>
</ul>
<h2 id="文件的使用">文件的使用</h2>
<p>文件系统基本操作（读写）单位：数据块</p>
<p>操作一个文件的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(name, flag); # 打开文件</span><br><span class="line">...</span><br><span class="line">write(fd,...);         # 写数据</span><br><span class="line">...</span><br><span class="line">close(fd);             # 关闭文件</span><br></pre></td></tr></table></figure>
<ul>
<li>首先用 <code>open</code>
<strong>系统调用</strong>打开文件，<code>open</code>
的参数中包含文件的路径名和文件名。</li>
<li>使用 <code>write</code> 写数据，其中 <code>write</code> 使用
<code>open</code>
所返回的<strong>文件描述符</strong>，并不使用文件名作为参数。</li>
<li>使用完文件后，要用 <code>close</code>
系统调用关闭文件，避免资源的泄露。</li>
</ul>
<p>打开文件后，操作系统会<strong>跟踪</strong>这个文件，也就是在进程中创建并维护一个打开文件表，文件表的每一项叫做<strong>文件描述符</strong>。</p>
<p>文件描述符中打开文件的状态和信息：</p>
<ul>
<li>文件指针：系统跟踪<strong>上次读写位置</strong>作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>
<li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为
0 时，系统关闭文件，删除该条目；</li>
<li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li>
<li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的
I/O 请求；</li>
</ul>
<p>读文件和写文件的过程：</p>
<ul>
<li>当用户进程从文件读取 1
个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。</li>
<li>当用户进程把 1
个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。</li>
</ul>
<h2 id="文件的存储">文件的存储</h2>
<h3 id="连续空间存放方式">连续空间存放方式</h3>
<p>概念：文件存放在磁盘<strong>连续</strong>的存储空间，但是需要事先知道文件的大小。</p>
<p>文件头：类似linux的inode</p>
<ul>
<li>起始块的位置</li>
<li>文件长度</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.png" alt="连续空间存放方式" style="zoom:67%;"></p>
<p><strong>缺陷</strong></p>
<p>磁盘空间碎片：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87.png" alt="磁盘碎片" style="zoom:50%;"></p>
<ul>
<li>可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。</li>
</ul>
<p>文件长度不易扩展：</p>
<p>优点：读写效率高。</p>
<h3 id="非连续空间存放方式">非连续空间存放方式</h3>
<h4 id="链表方式">链表方式</h4>
<p>链表的方式存放是<strong>离散的，不连续的</strong>，可以<strong>消除磁盘碎片</strong>，大大提高磁盘空间的利用率，同时<strong>文件的长度可以动态扩展</strong>。</p>
<h5 id="隐式链表">隐式链表</h5>
<p><img src="图解系统学习笔记/非连续空间存放方式-链表方式.png" alt="隐式链表" style="zoom:67%;"></p>
<p>文件头包含文件数据块的第一块和最后一块的位置，每个数据块要多留出一个指针空间，用来存放下一个数据块的位置。</p>
<p>缺点：</p>
<ul>
<li>查询效率低：无法直接访问数据块，只能顺序遍历</li>
<li>不稳定：链表指针因为系统原因损坏，就会导致文件内容缺失</li>
</ul>
<h5 id="显式链接">显式链接</h5>
<p>取出每个磁盘块的指针，放到内存的一个表中，这个表的每个表项存放每个数据块指向下一个数据块的指针。</p>
<p>工作形式：</p>
<p>文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块
6、3、11 和 14 。利用下图中的表，可以从第 4
块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6
块开始，顺着链走到最后，也能够找出文件 B
的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1
）结束。内存中的这样一个表格称为<strong>文件分配表（*File Allocation
Table，FAT*）</strong>。</p>
<p><img src="图解系统学习笔记/文件分配表.png" alt="显式链接" style="zoom:50%;"></p>
<p>不适用大磁盘的情况：对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2
亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4
个字节，那这张表要占用 800MB 内存，很显然 FAT
方案对于大磁盘而言不太合适。</p>
<h4 id="索引方式">索引方式</h4>
<p>弥补了链表的方式不能直接访问的缺点。</p>
<p>实现：为每个文件创建一个<strong>索引数据块</strong>，存放的是<strong>指向每一个文件数据块的指针</strong>列表。</p>
<p><img src="图解系统学习笔记/非连续空间存放方式-索引方式.png" alt="索引的方式" style="zoom:67%;"></p>
<p>优点：</p>
<ul>
<li>文件的创建、增大、缩小很方便；</li>
<li>不会有碎片的问题；</li>
<li>支持顺序读写和随机读写；</li>
</ul>
<p>缺陷：</p>
<ul>
<li>空间开销</li>
</ul>
<h5 id="解决大文件存储">解决大文件存储</h5>
<p>大文件存储，可能要多个索引块去存放索引信息。</p>
<h6 id="链表索引">链表+索引</h6>
<p>实现：索引数据块留出一个指向下一个索引数据块的指针。</p>
<p><img src="图解系统学习笔记/链式索引块.png" alt="链式索引块" style="zoom:67%;"></p>
<h6 id="索引索引">索引+索引</h6>
<p>实现：多级索引块，一级索引块存二级索引块的地址...依此类推。</p>
<p><img src="图解系统学习笔记/多级索引块.png" alt="多级索引块" style="zoom:67%;"></p>
<h2 id="空闲空间管理">空闲空间管理</h2>
<h3 id="空闲表法">空闲表法</h3>
<p>为所有空闲空间创建一个表，表内容包含第一个空闲块号的位置，以及空间的空闲块总个数。</p>
<p><img src="图解系统学习笔记/空闲表法.png" alt="空闲表法" style="zoom: 50%;"></p>
<p>请求分配磁盘空间时，会按照顺序遍历空闲表，直到找到合适的空间。</p>
<p>当用户撤销空间时，也要遍历空闲表，然后将新空出来的空闲块信息添加到表中。</p>
<p>缺陷：</p>
<ul>
<li>空闲区数量多，尤其是小碎片级别的空闲区，会大量占用表空间。</li>
</ul>
<h3 id="空闲链表法">空闲链表法</h3>
<p>每个空闲块有一个链表指向下一个空闲块，</p>
<p><img src="图解系统学习笔记/空闲块链表.png" alt="空闲链表法" style="zoom:67%;"></p>
<p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。</p>
<p>缺陷：</p>
<ul>
<li>不支持随机访问：每当在链上增加或移动空闲块时需要做很多 I/O
操作，同时数据块的指针消耗了一定的存储空间。</li>
</ul>
<h3 id="位图法">位图法</h3>
<p>磁盘分为多个盘块，位图利用一个二进制位表示磁盘中一个盘块的状态。</p>
<p>当值为 0 时，表示对应的盘块空闲，值为 1
时，表示对应的盘块已分配。它形式如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure>
<p>Linux
文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于
inode 空闲块的管理，因为 inode
也是存储在磁盘的，自然也要有对其管理。</p>
<h2 id="文件系统的结构">文件系统的结构</h2>
<blockquote>
<p>Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux
内核会通过 inode 的位图找到空闲可用的
inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配。</p>
<p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块
4K，每位表示一个数据块，共可以表示 <code>4 * 1024 * 8 = 2^15</code>
个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为
<code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p>
<p>按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的
inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就
128M，这太少了，现在很多文件都比这个大。</p>
<p>「一个块的位图 + 一系列的块」 —— 块组</p>
</blockquote>
<h3 id="块组">块组</h3>
<p>Linux Ext2
整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：</p>
<p><img src="图解系统学习笔记/块组.png" alt="img" style="zoom:50%;"></p>
<p>块组的内容：</p>
<ul>
<li>超级块：包含的是文件系统的重要信息，比如 inode
总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>
<li>块组描述符：包含文件系统中各个块组的状态，比如块组中空闲块和 inode
的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li>数据位图和 inode 位图， 用于表示对应的数据块或 inode
是空闲的，还是被使用中。</li>
<li>inode 列表：包含了块组中所有的 inode，inode
用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li>数据块：包含文件的有用数据。</li>
</ul>
<p>块组中的重复信息：都是备份作用。</p>
<h2 id="目录的存储">目录的存储</h2>
<p>目录其实也是个文件，也有inode，但和普通文件不同，<strong>普通文件的数据块里面保存的是文件数据，而目录文件的数据块里面保存的是目录里面一项一项的文件信息。</strong></p>
<p><img src="图解系统学习笔记/目录哈希表.png" alt="目录格式哈希表" style="zoom:50%;"></p>
<p>哈希表的作用：</p>
<p>当目录有超级多的文件，想在这个目录下找文件，哈希表会大幅提高效率。</p>
<p>保存目录的格式改成<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p>
<h2 id="软链接和硬链接">软链接和硬链接</h2>
<p>链接的作用：给文件起别名</p>
<p>硬链接：</p>
<p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个
inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode
数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个
inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p><img src="图解系统学习笔记/硬链接-2.png" alt="硬链接" style="zoom:50%;"></p>
<p>软链接：</p>
<p>软链接相当于<strong>重新创建一个文件</strong>，这个文件有<strong>独立的
inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>。</p>
<p>所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p>
<p><img src="图解系统学习笔记/软链接.png" alt="软链接" style="zoom:50%;"></p>
<h2 id="文件io">文件IO</h2>
<h3 id="缓冲与非缓冲io">缓冲与非缓冲IO</h3>
<p>区别：<strong>是否利用标准库缓存</strong>。</p>
<p>概念：</p>
<ul>
<li>缓冲IO：利用标准库缓存实现文件加速访问，然后<strong>通过标准库进行系统调用</strong>访问文件。</li>
<li>非缓冲IO：直接通过系统调用访问文件，不经过标准库缓存。</li>
</ul>
<p>缓冲 = 标准库内部实现的缓冲</p>
<p>很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，<strong>减少系统调用的次数</strong>，毕竟系统调用是有
CPU 上下文切换的开销的。</p>
<h3 id="直接与非直接io">直接与非直接IO</h3>
<p>区别：<strong>是否利用操作系统的缓存</strong></p>
<p>概念：</p>
<ul>
<li>直接IO：不会发生<strong>内核缓存和用户程序之间的复制</strong>，
直接经过文件系统访问磁盘。</li>
<li>间接IO
<ul>
<li>读操作：数据从内核缓存 拷贝给 用户程序</li>
<li>写操作：数据从用户程序 拷贝给
内核缓存，再<strong>由内核决定</strong>什么时候写入数据到磁盘。
<ul>
<li>写入时机：
<ul>
<li>在调用 <code>write</code>
的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>
<li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li>
<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>
<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>启动使用直接IO的方式：在使用文件操作类的系统调用函数时，指定
<code>O_DIRECT</code> 标志。</p>
<h3 id="阻塞与非阻塞io">阻塞与非阻塞IO</h3>
<h4 id="阻塞io">阻塞IO</h4>
<p>用户执行read：线程会被阻塞，一直等到<strong>内核数据准备好</strong>，并把<strong>数据从内核缓冲区拷贝到应用程序的缓冲区</strong>中，当拷贝过程完成，<code>read</code>
才会返回。</p>
<p>等待关键：</p>
<ul>
<li>内核数据准备好</li>
<li>内核把数据从内核缓冲区拷贝到应用程序的缓冲区</li>
</ul>
<h4 id="非阻塞io">非阻塞IO</h4>
<p>用户执行read：<strong>数据未准备好的情况</strong>下立即返回，可以继续往下执行，此时应用程序不断<strong>轮询内核</strong>，直到内核把数据准备好，凡事发生必有利于我，一切阻碍我的事物必将成为我前进的阶梯。</p>
<p><img src="图解系统学习笔记/非阻塞 I_O .png" alt="非阻塞 I/O" style="zoom: 67%;"></p>
<ul>
<li>注意：最后一次调用内核时，这时内核把数据准备好了，随后read线程需要<strong>等待</strong>数据从内核拷贝到应用进程，拷贝完成后返回给用户进程。
这个过程是同步的。</li>
</ul>
<p>启动非阻塞IO的方式：访问管道或 socket 时，设置
<code>O_NONBLOCK</code> 标志</p>
<blockquote>
<p>为了解决这种傻乎乎轮询方式，于是 <strong>I/O
多路复用</strong>技术就出来了，如 select、poll，它是通过 I/O
事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。</p>
<p>这个做法大大改善了 CPU 的利用率，因为当调用了 I/O
多路复用接口，如果没有事件发生，那么当前线程就会发生阻塞，这时 CPU
会切换其他线程执行任务，等内核发现有事件到来的时候，会唤醒阻塞在 I/O
多路复用接口的线程，然后用户可以进行后续的事件处理。</p>
<p>整个流程要比阻塞 IO 要复杂，似乎也更浪费性能。但 <strong>I/O
多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的
IO 请求</strong>（参见：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">I/O
多路复用：select/poll/epoll (opens new window)</a>）。用户可以注册多个
socket，然后不断地调用 I/O 多路复用接口读取被激活的
socket，即可达到在同一个线程内同时处理多个 IO
请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
</blockquote>
<h4 id="select-io-多路复用">select I/O 多路复用</h4>
<p><img src="图解系统学习笔记/基于非阻塞 I_O 的多路复用.png" alt="I/O 多路复用" style="zoom:67%;"></p>
<p>无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O
的多路复用都是<strong>同步调用</strong>。因为它们在 read
调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要<strong>等待</strong>的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read
调用就会在这个同步过程中等待比较长的时间。</p>
<h3 id="异步io">异步IO</h3>
<p><img src="图解系统学习笔记/异步 I_O.png" alt="异步 I/O" style="zoom:50%;"></p>
<h2 id="page-cache">Page Cache</h2>
<p>page cache模型图：</p>
<p><img src="图解系统学习笔记/72568a29816fa9b505f15edac68adee2.jpeg" alt="img" style="zoom: 50%;"></p>
<p>查看系统page cache：</p>
<h3 id="page与page-cache">Page与Page Cache</h3>
<p>page 是内存管理分配的基本单位， <strong>Page Cache 由多个 page
构成。但并不是所有 page 都被组织为 Page Cache</strong>。</p>
<p>Linux 系统上供用户可访问的内存分为两个类型，即：</p>
<ul>
<li>File-backed pages：文件备份页也就是 Page Cache 中的
page，对应于磁盘上的若干数据块；对于这些页最大的问题是脏页回盘；</li>
<li>Anonymous
pages：匿名页不对应磁盘上的任何磁盘数据块，它们是进程的运行是内存空间（例如方法栈、局部变量表等属性）；</li>
</ul>
<h3 id="swap-与-缺页中断">Swap 与 缺页中断</h3>
<p><strong>Swap机制</strong>：当物理内存不够用，内存管理单元（Memory
Mangament
Unit，MMU）需要提供<strong>调度算法</strong>来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。</p>
<p>缺页中断：当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。</p>
<p>swap的作用：对于有发生<strong>内存泄漏</strong>几率的应用程序（进程），Swap
交换分区更是重要，这可以确保内存泄露不至于导致物理内存不够用，最终导致系统崩溃。</p>
<p>Linux 通过一个 swappiness 参数来控制 Swap 机制：这个参数值可为
0-100，控制系统 swap 的优先级：</p>
<ul>
<li>高数值：较高频率的 swap，进程不活跃时主动将其转换出物理内存。</li>
<li>低数值：较低频率的
swap，这可以确保交互式不因为内存空间频繁地交换到磁盘而提高响应延迟。</li>
</ul>
<p>Page Cache 的一部分，SwapCached：</p>
<p>当匿名页（Inactive(anon) 以及 Active(anon)）先被交换（swap
out）到磁盘上后，然后再加载回（swap in）内存中，由于读入到内存后原来的
Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于
Page Cache。</p>
<p><img src="图解系统学习笔记/cbba24cac4668625c4e32d8cf641cf9c.jpeg" alt="图片" style="zoom:67%;"></p>
<h3 id="buffer-cache">Buffer Cache</h3>
<p><strong>Page Cache 用于缓存文件的页数据，buffer cache
用于缓存块设备（如磁盘）的块数据。</strong></p>
<ul>
<li>页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；</li>
<li>块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。</li>
</ul>
<p>加速数据IO：</p>
<ul>
<li>写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储
flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux
默认情况下不采用）；</li>
<li>读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。<strong>操作系统总是积极地将所有空闲内存都用作
Page Cache 和 buffer cache</strong>，当内存不够用时也会用 LRU
等算法淘汰缓存页。</li>
</ul>
<p><img src="图解系统学习笔记/c81ffa0b7d11506ffad3c33001385444.jpeg" alt="图片" style="zoom:50%;"></p>
<p>Page Cache 中的每个文件都是一棵基数树（radix
tree，本质上是多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见英文维基，这里就不细说了。</p>
<p><img src="图解系统学习笔记/cfda154558181c4af27a34c1d4a97552.jpeg" alt="图片" style="zoom:67%;"></p>
<h3 id="预读">预读</h3>
<p>操作系统为基于 Page Cache
的读缓存机制提供<strong>预读机制</strong>（PAGE_READAHEAD），一个例子是：</p>
<ul>
<li>用户线程仅仅请求读取磁盘上文件 A 的 offset 为 0-3KB
范围内的数据，由于磁盘的基本读写单位为
block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page
中装下。</li>
<li>但是操作系统出于<strong>局部性原理</strong>会选择将磁盘块 offset
[4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB)
都加载到内存，于是额外在内存中申请了 3 个 page；</li>
</ul>
<p><img src="图解系统学习笔记/ae8252378169c8c14b8b9907983f7d8b-20230309235145646.png" alt="img" style="zoom:67%;"></p>
<h3 id="page-cache-与文件持久化的一致性可靠性">Page Cache
与文件持久化的一致性&amp;可靠性</h3>
<p>文件 = 数据 + 元数据</p>
<ul>
<li>元数据：文件头信息</li>
</ul>
<p>要保证这俩数据的一致性。</p>
<p>当前 Linux 下以两种方式实现文件一致性：</p>
<ol type="1">
<li><strong>Write
Through（写穿）</strong>：向用户层提供特定接口，<strong>应用程序</strong>可<strong>主动</strong>调用接口来保证文件一致性；</li>
<li><strong>Write
back（写回）</strong>：系统中存在<strong>定期任务</strong>（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的
Linux 一致性方案；</li>
</ol>
<p>上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：</p>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">fsync(int fd)</td>
<td style="text-align: left;">fsync(fd)：将 fd
代表的文件的脏数据和脏元数据全部刷新至磁盘中。</td>
</tr>
<tr class="even">
<td style="text-align: left;">fdatasync(int fd)</td>
<td style="text-align: left;">fdatasync(fd)：将 fd
代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sync()</td>
<td style="text-align: left;">sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>创建的针对回写任务的内核线程数由系统中持久存储设备决定，为每个存储设备创建单独的刷新线程；</li>
<li>关于多线程的架构问题，Linux 内核采取了 <code>Lighthttp</code>
的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。</li>
<li>刷新线程刷新设备上脏页面大致设计如下：
<ul>
<li>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode
节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；</li>
<li>系统中存在多个回写时机
<ul>
<li>第一是应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等）</li>
<li>第二管理线程周期性地唤醒设备上的回写线程进行回写</li>
<li>第三是某些应用程序/内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要</li>
</ul></li>
</ul></li>
</ol>
<h1 id="设备管理">设备管理</h1>
<h2 id="设备控制器">设备控制器</h2>
<p>电脑设备可以接非常多的输入输出设备，比如键盘、鼠标、显示器、网卡、硬盘、打印机、音响等等，每个设备的用法和功能都不同操作系统是如何把这些输入输出设备统一管理的呢?</p>
<p>为了<strong>屏蔽设备之间的差异</strong>，每个设备都有一个叫<strong>设备控制器（*Device
Control*）</strong> 的组件：</p>
<p><img src="图解系统学习笔记/I_O系统结构.png" alt="计算机 I/O 系统结构" style="zoom:50%;"></p>
<p>设备控制器的组成：</p>
<ul>
<li>芯片：执行自己的逻辑</li>
<li>寄存器：与CPU通信
<ul>
<li>通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。</li>
<li>通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</li>
</ul></li>
</ul>
<p>控制器里的寄存器：</p>
<p><img src="图解系统学习笔记/设备控制器.png" alt="img" style="zoom:67%;"></p>
<ul>
<li><em>数据寄存器</em>：CPU 向 I/O
设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个
H 字符给到对应的 I/O 设备。</li>
<li><em>命令寄存器</em>：CPU 发送一个命令，告诉 I/O
设备，要进行输入/输出操作，于是就会交给 I/O
设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。</li>
<li><em>状态寄存器</em>：目的是告诉 CPU
，现在已经在工作或工作已经完成，如果已经在工作状态，CPU
再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU
才能发送下一个字符和命令。</li>
</ul>
<h2 id="io控制方式">I/O控制方式</h2>
<h2 id="设备驱动程序">设备驱动程序</h2>
<h2 id="通用块层">通用块层</h2>
<h2 id="存储系统io软件分层">存储系统IO软件分层</h2>
<h2 id="键入字母的流程">键入字母的流程</h2>
<h1 id="网络系统">网络系统</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2023/09/21/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://vlsmhd.github.io/2023/09/21/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/26/git%E5%AD%A6%E4%B9%A0/" title="git学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">git学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/10/jenkins/" title="jenkins"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">jenkins</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="操作系统导论——学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-14</div><div class="title">操作系统导论——学习笔记</div></div></a></div><div><a href="/2023/04/04/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" title="Leetcode-Hot100-15. 三数之和"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">Leetcode-Hot100-15. 三数之和</div></div></a></div><div><a href="/2023/04/01/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/" title="Leetcode-Hot100-22.括号生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">Leetcode-Hot100-22.括号生成</div></div></a></div><div><a href="/2023/04/03/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" title="Leetcode-Hot100-226. 翻转二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Leetcode-Hot100-226. 翻转二叉树</div></div></a></div><div><a href="/2023/03/31/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" title="Leetcode-Hot100-3.无重复字符的最长子串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-31</div><div class="title">Leetcode-Hot100-3.无重复字符的最长子串</div></div></a></div><div><a href="/2023/05/04/Leetcode-Hot100-105.-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" title="Leetcode-Hot100-105. 从前序与中序遍历序列构造二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-04</div><div class="title">Leetcode-Hot100-105. 从前序与中序遍历序列构造二叉树</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">硬件结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-number">2.1.</span> <span class="toc-text">内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.</span> <span class="toc-text">linux设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#multitask"><span class="toc-number">2.2.1.</span> <span class="toc-text">MultiTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smp"><span class="toc-number">2.2.2.</span> <span class="toc-text">SMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elf"><span class="toc-number">2.2.3.</span> <span class="toc-text">ELF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monolithic-kernel"><span class="toc-number">2.2.4.</span> <span class="toc-text">Monolithic Kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.</span> <span class="toc-text">windows设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">3.2.</span> <span class="toc-text">内存分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-number">3.3.</span> <span class="toc-text">内存分页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tlb"><span class="toc-number">3.3.2.</span> <span class="toc-text">TLB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">段页式内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%90%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">内存达到上限的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">内存分配的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">3.5.2.</span> <span class="toc-text">可以被回收的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">降低内存回收带来的性能影响</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%96%87%E4%BB%B6%E9%A1%B5%E5%92%8C%E5%8C%BF%E5%90%8D%E9%A1%B5%E7%9A%84%E5%9B%9E%E6%94%B6%E5%80%BE%E5%90%91"><span class="toc-number">3.5.2.1.1.</span> <span class="toc-text">调整文件页和匿名页的回收倾向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E6%97%A9%E8%A7%A6%E5%8F%91-kswapd-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98"><span class="toc-number">3.5.2.1.2.</span> <span class="toc-text">尽早触发 kswapd
内核线程异步回收内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#numa-%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">3.5.2.1.3.</span> <span class="toc-text">NUMA 架构下的内存回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#smp%E6%9E%B6%E6%9E%84"><span class="toc-number">3.5.2.1.3.1.</span> <span class="toc-text">SMP架构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#numa%E6%9E%B6%E6%9E%84"><span class="toc-number">3.5.2.1.3.2.</span> <span class="toc-text">NUMA架构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%A2%ABoom%E6%9D%80%E6%AD%BB"><span class="toc-number">3.5.3.</span> <span class="toc-text">如何保证进程不被OOM杀死</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">进程控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.3.</span> <span class="toc-text">进程的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%A4%E9%86%92"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">唤醒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">4.1.4.</span> <span class="toc-text">进程上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">多线程冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%8D%8F%E4%BD%9C"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">竞争与协作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text">同步</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">互斥和同步的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.2.2.2.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.2.2.3.</span> <span class="toc-text">生产者消费者问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90"><span class="toc-number">4.2.2.3.1.</span> <span class="toc-text">哲学家就餐</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.2.3.2.</span> <span class="toc-text">读者-写者问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81-1"><span class="toc-number">4.3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.3.1.</span> <span class="toc-text">互斥锁与自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.3.3.</span> <span class="toc-text">乐观锁与悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">在线文档案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">4.3.4.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9C%89%E5%BA%8F%E5%88%86%E9%85%8D%E6%B3%95"><span class="toc-number">4.3.4.1.1.</span> <span class="toc-text">资源有序分配法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">4.4.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="toc-number">4.4.1.</span> <span class="toc-text">调度时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="toc-number">4.4.2.</span> <span class="toc-text">调度原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">先来先服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">短作业优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">高响应比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">时间片轮转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.4.3.5.</span> <span class="toc-text">高优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-number">4.4.3.6.</span> <span class="toc-text">多级反馈队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">4.5.</span> <span class="toc-text">进程间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">4.5.1.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E7%9A%84-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">Linux的 | 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.5.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">4.5.3.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="toc-number">4.5.4.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%9D%E5%80%BC"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">信号量初值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.5.5.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">4.5.6.</span> <span class="toc-text">Socket网络通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="toc-number">5.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">内存页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">最佳页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">先进先出置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">最近最久未使用置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">时钟页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.5.</span> <span class="toc-text">最不常用置换算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AF%BB%E9%81%93"><span class="toc-number">5.2.</span> <span class="toc-text">磁盘调度算法——寻道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">先来先服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">5.2.2.</span> <span class="toc-text">最短寻道时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8Fscan%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text">扫描SCAN（电梯）算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8Fc-scan%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.4.</span> <span class="toc-text">循环扫描C-SCAN算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#looc%E4%B8%8Ec-look%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.5.</span> <span class="toc-text">LOOC与C-LOOK算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">6.1.</span> <span class="toc-text">基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%9C%A8%E7%A3%81%E7%9B%98%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">文件在磁盘的存储形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.2.</span> <span class="toc-text">虚拟文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">文件的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.4.</span> <span class="toc-text">文件的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">连续空间存放方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">非连续空间存放方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">链表方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">6.4.2.1.1.</span> <span class="toc-text">隐式链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">6.4.2.1.2.</span> <span class="toc-text">显式链接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">索引方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%A4%A7%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">6.4.2.2.1.</span> <span class="toc-text">解决大文件存储</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">6.4.2.2.1.1.</span> <span class="toc-text">链表+索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B4%A2%E5%BC%95"><span class="toc-number">6.4.2.2.1.2.</span> <span class="toc-text">索引+索引</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">6.5.1.</span> <span class="toc-text">空闲表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">6.5.2.</span> <span class="toc-text">空闲链表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="toc-number">6.5.3.</span> <span class="toc-text">位图法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.6.</span> <span class="toc-text">文件系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BB%84"><span class="toc-number">6.6.1.</span> <span class="toc-text">块组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.7.</span> <span class="toc-text">目录的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">6.8.</span> <span class="toc-text">软链接和硬链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6io"><span class="toc-number">6.9.</span> <span class="toc-text">文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2io"><span class="toc-number">6.9.1.</span> <span class="toc-text">缓冲与非缓冲IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5io"><span class="toc-number">6.9.2.</span> <span class="toc-text">直接与非直接IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9Eio"><span class="toc-number">6.9.3.</span> <span class="toc-text">阻塞与非阻塞IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9Eio"><span class="toc-number">6.9.3.1.</span> <span class="toc-text">阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9Eio"><span class="toc-number">6.9.3.2.</span> <span class="toc-text">非阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">6.9.3.3.</span> <span class="toc-text">select I&#x2F;O 多路复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5io"><span class="toc-number">6.9.4.</span> <span class="toc-text">异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#page-cache"><span class="toc-number">6.10.</span> <span class="toc-text">Page Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#page%E4%B8%8Epage-cache"><span class="toc-number">6.10.1.</span> <span class="toc-text">Page与Page Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap-%E4%B8%8E-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">6.10.2.</span> <span class="toc-text">Swap 与 缺页中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer-cache"><span class="toc-number">6.10.3.</span> <span class="toc-text">Buffer Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB"><span class="toc-number">6.10.4.</span> <span class="toc-text">预读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#page-cache-%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">6.10.5.</span> <span class="toc-text">Page Cache
与文件持久化的一致性&amp;可靠性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">设备控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82"><span class="toc-number">7.4.</span> <span class="toc-text">通用块层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9Fio%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82"><span class="toc-number">7.5.</span> <span class="toc-text">存储系统IO软件分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%85%A5%E5%AD%97%E6%AF%8D%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.6.</span> <span class="toc-text">键入字母的流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.</span> <span class="toc-text">网络系统</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/08/leetcode%E6%95%B0%E5%AD%A6%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode数学题目专项训练">leetcode数学题目专项训练</a><time datetime="2023-11-08T01:18:07.132Z" title="发表于 2023-11-08 09:18:07">2023-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/06/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode字符串题目专项训练">leetcode字符串题目专项训练</a><time datetime="2023-11-06T03:35:20.394Z" title="发表于 2023-11-06 11:35:20">2023-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="并发编程设计模式">并发编程设计模式</a><time datetime="2023-11-04T07:19:35.683Z" title="发表于 2023-11-04 15:19:35">2023-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/04/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" title="JUC并发编程应用场景">JUC并发编程应用场景</a><time datetime="2023-11-04T06:48:15.410Z" title="发表于 2023-11-04 14:48:15">2023-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/29/leetcode%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode贪心题目专项训练">leetcode贪心题目专项训练</a><time datetime="2023-10-29T09:43:44.750Z" title="发表于 2023-10-29 17:43:44">2023-10-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>