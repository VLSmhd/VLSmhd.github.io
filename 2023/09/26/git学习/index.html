<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>git学习 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="git核心概念 版本控制 版本控制是一种记录文件内容变化，以便查阅特定版本修订情况的系统。 作用：方便回溯版本。 本地版本控制系统 在本地利用数据库存储文件历次版本之间的差异。  集中化版本控制系统 集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。   集中化的版本控制系统">
<meta property="og:type" content="article">
<meta property="og:title" content="git学习">
<meta property="og:url" content="https://vlsmhd.github.io/2023/09/26/git%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="git核心概念 版本控制 版本控制是一种记录文件内容变化，以便查阅特定版本修订情况的系统。 作用：方便回溯版本。 本地版本控制系统 在本地利用数据库存储文件历次版本之间的差异。  集中化版本控制系统 集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。   集中化的版本控制系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-09-26T08:06:58.379Z">
<meta property="article:modified_time" content="2023-12-04T14:56:54.055Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2023/09/26/git%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'git学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-04 22:56:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">76</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">git学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-26T08:06:58.379Z" title="发表于 2023-09-26 16:06:58">2023-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-04T14:56:54.055Z" title="更新于 2023-12-04 22:56:54">2023-12-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/">git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="git学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="git核心概念">git核心概念</h1>
<h2 id="版本控制">版本控制</h2>
<p>版本控制是一种<strong>记录文件内容变化，以便查阅特定版本修订情况</strong>的系统。</p>
<p>作用：方便回溯版本。</p>
<h3 id="本地版本控制系统">本地版本控制系统</h3>
<p>在本地利用数据库存储文件历次版本之间的差异。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/tools/git/%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" alt="本地版本控制系统" style="zoom:80%;" /></p>
<h3 id="集中化版本控制系统">集中化版本控制系统</h3>
<p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<figure>
<img
src="https://oss.javaguide.cn/github/javaguide/tools/git/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png"
alt="集中化的版本控制系统" />
<figcaption aria-hidden="true">集中化的版本控制系统</figcaption>
</figure>
<p>会出现的问题：</p>
<ul>
<li>单点故障：中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。</li>
<li>断网：<strong>必须联网才能工作：</strong> 受网络状况、带宽影响</li>
</ul>
<h3 id="分布式版本控制系统">分布式版本控制系统</h3>
<p>（Distributed Version Control System，简称 DVCS），git属于这个。</p>
<p>特点：客户端不只提取最新版本的文件快照，而是<strong>把整个代码仓库复制下来</strong></p>
<p><img src="分布式版本控制系统.png" alt="分布式版本控制系统" style="zoom:80%;" /></p>
<p>优势：</p>
<ul>
<li>不用联网：每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了</li>
<li>中央服务器：方便交换大家的修改。</li>
</ul>
<h2 id="git">git</h2>
<blockquote>
<p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper
来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux
内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper
的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用
BitKeeper
时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。</p>
</blockquote>
<h3 id="与其它版本管理工具的区别">与其它版本管理工具的区别</h3>
<p>大部分版本管理工具都是基于<strong>差异比较</strong>来对待数据，以文件变更列表的形式存储信息。</p>
<p><img src="2019-3deltas.png" alt="img" style="zoom: 80%;" /></p>
<p>原理：每提交一个修改，记录增量以△标记。</p>
<p>如何得到最终版本：遍历链表把全部增量添加到初始文件中。</p>
<p>缺陷：遍历链表耗时。</p>
<p>git采用<strong>快照流</strong>的形式，对待每一版本数据：</p>
<p>每次你提交更新，或在 Git
中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。</p>
<figure>
<img src="2019-3snapshots.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>Version 2：FileA和C更改，B没更改，但是也会把B快照记录下来。</li>
</ul>
<h3 id="git的状态及工作区">git的状态及工作区</h3>
<ol type="1">
<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>
<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>
<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
</ol>
<p>工作区：</p>
<p><strong>Git 仓库(.git directory)</strong>、<strong>工作目录(Working
Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>
<figure>
<img src="2019-3areas.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>工作流程：</p>
<ol type="1">
<li>在工作目录修改文件</li>
<li>将文件的快照暂存到暂存区域</li>
<li>提交更新，提交到git仓库</li>
</ol>
<h1 id="git使用">git使用</h1>
<h2 id="基础命令">基础命令</h2>
<h3 id="获取git仓库">获取git仓库</h3>
<p>现有目录初始化仓库：进入某一项目目录，输入<code>git init</code>，该命令将创建一个名为
<code>.git</code> 的子目录。</p>
<p>从服务器克隆一个现有的git仓库：<code>git clone</code></p>
<p>定义本地仓库的名字: <code>git clone [url] directoryname</code></p>
<h3 id="记录每次更新到仓库">记录每次更新到仓库</h3>
<ol type="1">
<li><strong>检测当前文件状态</strong> : <code>git status</code></li>
<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code>
(针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有
.txt 文件）</li>
<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>
<li><strong>提交更新:</strong> <code>git commit -m "代码提交信息"</code>
（每次准备提交前，先用 <code>git status</code>
看下，是不是都已暂存起来了， 然后再运行提交命令
<code>git commit</code>）</li>
<li><strong>跳过使用暂存区域更新的方式</strong> :
<code>git commit -a -m "代码提交信息"</code>。 <code>git commit</code>
加上 <code>-a</code> 选项，Git
就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过
<code>git add</code> 步骤。</li>
<li><strong>移除文件</strong>：<code>git rm filename</code>
（从暂存区域移除，然后提交。）</li>
<li><strong>对文件重命名</strong>：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code>
这三条命令的集合)</li>
</ol>
<h4 id="git-commit">Git Commit</h4>
<p>Git
仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样。</p>
<p>Git
希望<strong>提交记录尽可能地轻量</strong>，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p>
<p>提交结点链表：</p>
<figure>
<img src="image-20230926174535281.png" alt="image-20230926174535281" />
<figcaption aria-hidden="true">image-20230926174535281</figcaption>
</figure>
<p>每一次git
commit，都会创建一个cx结点，结点的parent指针指向上次提交的结点。</p>
<h3 id="推送改到远程仓库">推送改到远程仓库</h3>
<ul>
<li>如果你还没有克隆现有仓库，并<strong>欲将你的仓库连接到某个远程服务器</strong>，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code>
<ul>
<li>比如我们要让本地的一个仓库和 GitHub
上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code></li>
</ul></li>
<li>将这些改动提交到远端仓库：<code>git push origin master</code>
(可以把 <em>master</em> 换成你想要推送的任何分支)</li>
</ul>
<h3 id="远程仓库的移除重命名">远程仓库的移除、重命名</h3>
<ul>
<li>将 test 重命名为
test1：<code>git remote rename test test1</code></li>
<li>移除远程仓库 test1:<code>git remote rm test1</code></li>
</ul>
<h3 id="查看提交历史">查看提交历史</h3>
<p>列出所有更新：<code>git log</code></p>
<p>查看某个人的：<code>git log --author=bob</code></p>
<h3 id="撤销操作">撤销操作</h3>
<p>重新提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>取消暂存的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure>
<p>撤消对文件的修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --filename</span><br></pre></td></tr></table></figure>
<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>
<h3 id="分支操作">分支操作</h3>
<p>在创建仓库的时候，<em>master</em>
是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。我们通常在开发新功能、修复一个紧急
bug
等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>
<p>建议：多用分支、早用分支</p>
<p><strong>操作演示：</strong></p>
<ol type="1">
<li>初始状态：</li>
</ol>
<p>两次提交，主分支指向最新的提交</p>
<figure>
<img src="image-20230926175007156.png" alt="image-20230926175007156" />
<figcaption aria-hidden="true">image-20230926175007156</figcaption>
</figure>
<ol start="2" type="1">
<li>创建一个名字叫做 newImage 的分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch newImage</span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20230926175037271.png" alt="image-20230926175037271" />
<figcaption aria-hidden="true">image-20230926175037271</figcaption>
</figure>
<ul>
<li>新建的分支都会指向主节点在指向的提交。</li>
</ul>
<ol start="3" type="1">
<li><p>不切换分支提交一份代码</p>
<figure>
<img src="image-20230926194924511.png" alt="image-20230926194924511" />
<figcaption aria-hidden="true">image-20230926194924511</figcaption>
</figure></li>
</ol>
<ul>
<li>因为本次提交是在主分支的提交，所以仅有main指向最新的提交C2、</li>
</ul>
<ol start="4" type="1">
<li><p>切换分支再提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout newImage;</span><br><span class="line"></span><br><span class="line">git commit;</span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20230926195054090.png" alt="image-20230926195054090" />
<figcaption aria-hidden="true">image-20230926195054090</figcaption>
</figure></li>
</ol>
<p>注意：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code>
的新命令，最终会取代 <code>git checkout</code>，因为
<code>checkout</code>
作为单个命令有点超载（它承载了很多独立的功能）。</p>
<p>把新建的分支删掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure>
<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<h4 id="分支合并">分支合并</h4>
<h5 id="git-merge">git merge</h5>
<ul>
<li>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent
节点。翻译成自然语言相当于：“我要把这两个 parent
节点本身及它们所有的祖先都包含进来。”</li>
</ul>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230926204311275.png" alt="image-20230926204311275" style="zoom:80%;" /></p></li>
<li><p>合并bugFix到main</p>
<p>当前所在分支：main</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure>
<p><img src="image-20230926204406178.png" alt="image-20230926204406178" style="zoom:80%;" /></p></li>
</ol>
<ul>
<li>C2和C3合并成C4，然后main指向C4</li>
<li><code>main</code> 现在指向了一个拥有两个 parent
节点的提交记录。假如从 <code>main</code>
开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着
<code>main</code> 包含了对代码库的所有修改。</li>
</ul>
<ol start="3" type="1">
<li><p>再把main合并到bugFix</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//合并到哪，切换分支到哪</span><br><span class="line">git checkout bugFix;</span><br><span class="line">//把main合并过来</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure>
<p><img src="image-20230926204647629.png" alt="image-20230926204647629" style="zoom:80%;" /></p></li>
</ol>
<ul>
<li>因为main继承bugFix，把 <code>bugFix</code> 移动到 <code>main</code>
所指向的那个提交记录即可。</li>
</ul>
<h5 id="git-rebase">git rebase</h5>
<p>概念：Rebase
实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>优势：可以创造更线性的提交历史。如果只允许使用 Rebase
的话，代码库的提交历史将会变得异常清晰。</p>
<p>语法：</p>
<p><code>git rebase A B</code>：把分支B移到A上。</p>
<p><code>git rebase A</code>：把A移到HEAD所在地方</p>
<p>rebase可以理解为：改变基地到...</p>
<p>案例：</p>
<ol type="1">
<li><p>初始化：</p>
<p><img src="image-20230926205410807.png" alt="image-20230926205410807" style="zoom:80%;" /></p></li>
</ol>
<p>目标：把 bugFix 分支里的工作直接移到 main
分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。</p>
<ol start="2" type="1">
<li><p>合并到main</p>
<p>当前所在分支：bugFix</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure>
<p><img src="image-20230926205618554.png" alt="image-20230926205618554" style="zoom:80%;" /></p></li>
</ol>
<ul>
<li>现在 bugFix 分支上的工作在 main
的最顶端，同时我们也得到了一个更线性的提交序列。</li>
<li>提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase
到 main 分支上的 C3 的副本。</li>
</ul>
<ol start="3" type="1">
<li><p>切换分支到main，把main更新到bugFix上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure>
<p><img src="image-20230926205903609.png" alt="image-20230926205903609" style="zoom:80%;" /></p></li>
</ol>
<h2 id="高级特性">高级特性</h2>
<h3 id="分离head">分离head</h3>
<p>HEAD 是一个对当前所在分支的符号引用 ——
也就是<strong>指向你正在其基础上进行工作的提交记录</strong>。</p>
<p>head总是指向当前分支上最近一次提交记录，通常情况指向分支名。</p>
<p>案例：</p>
<p>从main分离出去：</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230927143659502.png" alt="image-20230927143659502" style="zoom:80%;" /></p></li>
<li><p>开始分离</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1</span><br></pre></td></tr></table></figure>
<p><img src="image-20230927143728033.png" alt="image-20230927143728033" style="zoom:80%;" /></p></li>
</ol>
<h3 id="相对引用移动">相对引用——移动</h3>
<p>为什么引入相对引用：通过哈希值指定提交记录不方便，还要git
log查看一长串的字符。</p>
<p>使用：</p>
<ul>
<li>使用 <code>^</code> 向上移动 1 个提交记录
<ul>
<li><code>^</code>加在引用名称的后面，表示寻找这个提交记录的<code>parent</code>结点</li>
</ul></li>
<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如
<code>~3</code></li>
</ul>
<p>案例1：向上移动一个提交记录</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230927144208639.png" alt="image-20230927144208639" style="zoom:80%;" /></p></li>
<li><p>向上移动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^</span><br></pre></td></tr></table></figure>
<p><img src="image-20230927144503570.png" alt="image-20230927144503570" style="zoom:80%;" /></p></li>
</ol>
<ul>
<li>这里HEAD会自动分离</li>
</ul>
<p>案例2：使用head作为相对引用的指针参照</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230927144644440.png" alt="image-20230927144644440" style="zoom:80%;" /></p></li>
<li><p>分离head、向上移动一位</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout c3</span><br><span class="line"></span><br><span class="line">git checkout HEAD^</span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20230927144805362.png" alt="image-20230927144805362" />
<figcaption aria-hidden="true">image-20230927144805362</figcaption>
</figure></li>
</ol>
<p>案例3：强制修改分支位置</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230927145227852.png" alt="image-20230927145227852" style="zoom:80%;" /></p></li>
<li><p>移动分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//让main分支回退HEAD所在结点处三个版本</span><br><span class="line">git branch -f main HEAD^3</span><br></pre></td></tr></table></figure>
<p><img src="image-20230927145312813.png" alt="image-20230927145312813" style="zoom:80%;" /></p></li>
</ol>
<h3 id="撤销变更">撤销变更</h3>
<p>方法：</p>
<ul>
<li>git reset：把分支回退几个提交记录</li>
<li>git
revert：向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</li>
</ul>
<p>案例1：reset实战</p>
<ol type="1">
<li><p>初始化：</p>
<p><img src="image-20230927145909531.png" alt="image-20230927145909531" style="zoom:80%;" /></p></li>
<li><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~1</span><br></pre></td></tr></table></figure>
<p><img src="image-20230927150014697.png" alt="image-20230927150014697" style="zoom:80%;" /></p></li>
</ol>
<p>案例2：revert实战</p>
<ol type="1">
<li><p>初始化：</p>
<p><img src="image-20230927150413680.png" alt="image-20230927150413680" style="zoom:80%;" /></p></li>
<li><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD/C2</span><br></pre></td></tr></table></figure>
<p><img src="image-20230927150456259.png" alt="image-20230927150456259" style="zoom:80%;" /></p></li>
</ol>
<ul>
<li>新提交记录 <code>C2'</code>
相当于一个<strong>更改</strong>：用来撤销 <code>C2</code> 这个提交
，因此C2' = C1</li>
</ul>
<h3 id="移动提交记录">移动提交记录</h3>
<h4 id="整理提交记录">整理提交记录</h4>
<ul>
<li><code>git cherry-pick &lt;提交号&gt;...</code>：将一些提交(提交树上任何地方)复制到当前所在的位置（<code>HEAD</code>）下面</li>
</ul>
<p>案例：将 <code>side</code> 分支上的工作复制到 <code>main</code>
分支</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230930181312137.png" alt="image-20230930181312137" style="zoom:67%;" /></p></li>
<li><p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20230930181415507.png" alt="image-20230930181415507" />
<figcaption aria-hidden="true">image-20230930181415507</figcaption>
</figure></li>
</ol>
<p>可以看到，把side分支上的C2、C4提交记录直接按命令输入顺序复制到main（当前head所在的分支上）上了。</p>
<h4 id="交互式rebase">交互式rebase</h4>
<p>在清楚提交记录名称（C2、C4...）的情况下，使用cherry-pick可以，在未知情的情况下，利用交互式rebase：用带参数
<code>--interactive</code> 的 rebase 命令。</p>
<ul>
<li>在命令后增加了这个选项, Git 会打开一个 UI
界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</li>
<li>可以缩写为 <code>-i</code></li>
</ul>
<p>UI界面操作：</p>
<ul>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换 <code>pick</code>
的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。
遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。</li>
</ul>
<p>案例：</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20230930182821022.png" alt="image-20230930182821022" style="zoom:67%;" /></p></li>
<li><p>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>
<p><img src="image-20230930182907601.png" alt="image-20230930182907601" style="zoom: 67%;" /></p></li>
<li><p>结果（自定义）</p>
<p><img src="image-20230930182936362.png" alt="image-20230930182936362" style="zoom:67%;" /></p></li>
</ol>
<h3 id="只提取一个提交记录">只提取一个提交记录</h3>
<blockquote>
<p>开发场景：我正在解决某个特别棘手的
Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个
Bug 的根本原因。最后就差把 <code>bugFix</code> 分支里的工作合并回
<code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到
<code>main</code> 分支上，但这样的话 <code>main</code>
分支就会包含我这些调试语句了。</p>
</blockquote>
<p>更好的解决方法：</p>
<p>让 Git
复制解决问题的那一个提交记录就可以了，把那个提交记录合并到main就可以。命令如下：</p>
<ul>
<li><code>git rebase -i</code></li>
<li><code>git cherry-pick</code></li>
</ul>
<h3 id="提交的技巧">提交的技巧</h3>
<p>开发场景1：你之前在 <code>newImage</code>
分支上进行了一次提交，然后又基于它创建了 <code>caption</code>
分支，然后又提交了一次。此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下
<code>newImage</code>
中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>使用<code>git rebase -i</code>步骤：</p>
<ul>
<li>先用 <code>git rebase -i</code>
将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>
<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>
<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>
<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法）</li>
</ul>
<p>案例1：用 <code>git rebase -i</code></p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231004175032221.png" alt="image-20231004175032221" style="zoom:67%;" /></p></li>
<li><p>git rebase -i调整</p>
<figure>
<img src="image-20231004175800640.png" alt="image-20231004175800640" />
<figcaption aria-hidden="true">image-20231004175800640</figcaption>
</figure>
<p>复制两次</p></li>
<li><p>移动main到caption</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase C3<span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>目标结果</p>
<p><img src="image-20231004175107960.png" alt="image-20231004175107960" style="zoom: 80%;" /></p></li>
</ol>
<p>案例2：使用git cherry-pick</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231004180311310.png" alt="image-20231004180311310" style="zoom:67%;" /></p></li>
<li><p>复制C2、C3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick C2</span><br><span class="line">git checkout c1</span><br><span class="line">git cherry-pick C2 C3</span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20231004185159887.png" alt="image-20231004185159887" />
<figcaption aria-hidden="true">image-20231004185159887</figcaption>
</figure></li>
<li><p>移动main到head</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD</span><br></pre></td></tr></table></figure></li>
<li><p>目标结果：</p>
<p><img src="image-20231004180338649.png" alt="image-20231004180338649" style="zoom:67%;" /></p></li>
</ol>
<h3 id="git-tag">git tag</h3>
<p><em>永远</em>指向某个提交记录的标识，比如软件发布新的大版本，或者是修正一些重要的
Bug 或是增加了某些新特性。</p>
<blockquote>
<p>是提交树上的一个锚点，标识了某个特定的位置。</p>
</blockquote>
<p>语法：<code>git tag 名称 提交</code></p>
<p>案例：</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231007231130175.png" alt="image-20231007231130175" style="zoom:67%;" /></p></li>
<li><p>执行语法：</p>
<figure>
<img src="image-20231007232054050.png" alt="image-20231007232054050" />
<figcaption aria-hidden="true">image-20231007232054050</figcaption>
</figure></li>
<li><p>结果：</p>
<p><img src="image-20231007232106504.png" alt="image-20231007232106504" style="zoom:80%;" /></p></li>
</ol>
<h3 id="git-describe">git Describe</h3>
<p>Git
专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），就是
<code>git describe</code></p>
<ul>
<li><code>git bisect</code>：一个查找产生 Bug 的提交记录的指令</li>
</ul>
<p>语法规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;ref&gt;</code> 是<strong>任何能被 Git
识别成提交记录的引用</strong>，如果你没有指定的话，Git
会使用你目前所在的位置（<code>HEAD</code>）</li>
</ul>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tag</code> 表示的是离 <code>ref</code> 最近的标签</li>
<li><code>numCommits</code> 是表示这个 <code>ref</code> 与
<code>tag</code> 相差有多少个提交记录</li>
<li><code>hash</code> 表示的是你所给定的 <code>ref</code>
所表示的提交记录哈希值的前几位</li>
</ul>
<p>案例：</p>
<p><img src="image-20231008225829759.png" alt="image-20231008225829759" style="zoom: 80%;" /></p>
<p><code>git describe main</code> 会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1_2_gC2</span><br></pre></td></tr></table></figure>
<p><code>git describe side</code> 会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v2_1_gC4</span><br></pre></td></tr></table></figure>
<h3 id="多分支rebase">多分支rebase</h3>
<p>案例：</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231009131401336.png" alt="image-20231009131401336" style="zoom:67%;" /></p></li>
<li><p>命令</p>
<figure>
<img src="image-20231009131329216.png" alt="image-20231009131329216" />
<figcaption aria-hidden="true">image-20231009131329216</figcaption>
</figure>
<p>简洁版</p>
<figure>
<img src="image-20231009132036143.png" alt="image-20231009132036143" />
<figcaption aria-hidden="true">image-20231009132036143</figcaption>
</figure></li>
<li><p>结果</p>
<p><img src="image-20231009131256122.png" alt="image-20231009131256122" style="zoom:67%;" /></p></li>
</ol>
<h3 id="选择parent提交记录">选择parent提交记录</h3>
<p>案例1：</p>
<p><img src="image-20231010131119309.png" alt="image-20231010131119309" style="zoom: 80%;" /></p>
<p>执行代码1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^</span><br></pre></td></tr></table></figure>
<p><img src="image-20231010131812799.png" alt="image-20231010131812799" style="zoom:67%;" /></p>
<p>执行代码2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^2</span><br></pre></td></tr></table></figure>
<p><img src="image-20231010132028173.png" alt="image-20231010132028173" style="zoom:67%;" /></p>
<p>用 <code>^</code> 和 <code>~</code> 可以自由地在提交树中移动：</p>
<p><img src="image-20231010132208452.png" alt="image-20231010132208452" style="zoom:67%;" /></p>
<p>git checkout HEAD~;</p>
<p>git checkout HEAD^2;</p>
<p>git checkout HEAD~2;</p>
<p>以上三段代码缩减为：git checkout HEAD<sub>^2</sub>2</p>
<p><img src="image-20231010132153825.png" alt="image-20231010132153825" style="zoom:67%;" /></p>
<h3 id="分支提交分发">分支提交分发</h3>
<p>案例：</p>
<p><code>main</code> 分支是比 <code>one</code>、<code>two</code> 和
<code>three</code> 要多几个提交。出于某种原因，我们需要把
<code>main</code>
分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p>
<p><code>one</code> 需要重新排序并删除 <code>C5</code>，<code>two</code>
仅需要重排排序，而 <code>three</code> 只需要提交一次。</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231011124801130.png" alt="image-20231011124801130" style="zoom:67%;" /></p></li>
<li><p>执行代码</p>
<figure>
<img src="image-20231011131018723.png" alt="image-20231011131018723" />
<figcaption aria-hidden="true">image-20231011131018723</figcaption>
</figure></li>
<li><p>结果</p>
<p><img src="image-20231011124816572.png" alt="image-20231011124816572" style="zoom:67%;" /></p></li>
</ol>
<h2 id="git远程仓库">git远程仓库</h2>
<h3 id="git-clone">git clone</h3>
<h3 id="远程分支">远程分支</h3>
<p><code>git clone</code>后，本地仓库多了一个名为 <code>o/main</code>
的分支, 这种类型的分支就叫<strong>远程</strong>分支。</p>
<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别
—— 这是你与别人分享工作成果前至关重要的一步.</p>
<ul>
<li>远程分支有一个特别的属性，在你切换到远程分支时，<strong>自动进入分离
HEAD 状态</strong>。</li>
</ul>
<p><code>o/</code>的含义：</p>
<p>远程分支有一个命名规范 —— 它们的格式是:</p>
<ul>
<li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li>
</ul>
<p>o就代表远程分支名字标识：</p>
<ul>
<li>大多数的开发人员会将它们主要的远程仓库命名为
<code>origin</code>，并不是 <code>o</code>。这是因为当你用
<code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为
<code>origin</code> 了</li>
</ul>
<p>案例：</p>
<p>初始化：</p>
<p><img src="image-20231012131127515.png" alt="image-20231012131127515" style="zoom:67%;" /></p>
<p>main分支提交一次：</p>
<p>o/main分支提交一次：</p>
<figure>
<img src="image-20231012131530907.png" alt="image-20231012131530907" />
<figcaption aria-hidden="true">image-20231012131530907</figcaption>
</figure>
<p>结果：</p>
<p><img src="image-20231012131436492.png" alt="image-20231012131436492" style="zoom:67%;" /></p>
<h3 id="git-fetch">git fetch</h3>
<p>作用：从远程仓库中获取数据，并且远程分支也会更新并反映最新的远程仓库。</p>
<ul>
<li>从远程仓库下载本地仓库中缺失的提交记录</li>
<li>更新远程分支指针(如 <code>o/main</code>)</li>
<li>该命令不会改变本地仓库的任何东西</li>
</ul>
<blockquote>
<p>通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议)
与远程仓库通信。</p>
</blockquote>
<h4 id="参数">参数</h4>
<p>抓取特定分支到本地远程分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure>
<p>Git 会到远程仓库的 <code>foo</code>
分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code>
上。</p>
<p>抓取特定分支到本地分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin &lt;<span class="built_in">source</span>&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>source</code>
现在指的是远程仓库中的位置，如果不指定，会在本地创建一个分支destination</li>
<li><code>&lt;destination&gt;</code>
才是要放置提交的本地仓库的位置。</li>
</ul>
<h4 id="案例">案例</h4>
<p>1、不带参数</p>
<ol type="1">
<li><p>初始化</p>
<p>左本地、右远程</p></li>
</ol>
<p><img src="image-20231014152429027.png" alt="image-20231014152429027" style="zoom: 67%;" /></p>
<ol start="2" type="1">
<li><p>使用命令 git fetch</p>
<p><img src="image-20231014152523450.png" alt="image-20231014152523450" style="zoom:67%;" /></p>
<p>C2、C3已被下载到本地仓库，远程分支o/main移动到最新提交记录</p></li>
</ol>
<p>2、抓取远程特定分支的提交，但不更新本地分支</p>
<ol type="1">
<li>初始化</li>
</ol>
<p><img src="image-20231026114018903.png" alt="image-20231026114018903" style="zoom:67%;" /></p>
<ol start="2" type="1">
<li><p>执行： <code>git fetch origin foo</code></p>
<p><img src="image-20231026114357313.png" alt="image-20231026114357313" style="zoom:67%;" /></p></li>
</ol>
<p>3、抓取远程分支到本地分支，更新本地分支</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231026130209205.png" alt="image-20231026130209205" style="zoom:67%;" /></p></li>
<li><p>执行命令：<code>fit fetch origin foo~1:bar</code></p>
<p><img src="image-20231026130534290.png" alt="image-20231026130534290" style="zoom:67%;" /></p></li>
</ol>
<ul>
<li>即使本地没有bar分支，git也会自动创建一个分支出来</li>
</ul>
<h3 id="git-pull">git pull</h3>
<p>先抓取更新再合并，是基本常用操作，相当于<code>git fetch + git merge</code></p>
<p>合并为一个命令：<code>git pull</code></p>
<h4 id="参数-1">参数</h4>
<p><code>git pull origin foo</code> 相当于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo; git merge o/foo</span><br></pre></td></tr></table></figure>
<p><code>git pull origin bar~1:bugFix</code> 相当于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure>
<h4 id="案例-1">案例</h4>
<p>1、不带参数</p>
<ol type="1">
<li><p>初始化</p>
<p>左本地、右远程</p>
<p><img src="image-20231015125528962.png" alt="image-20231015125528962" style="zoom:67%;" /></p></li>
<li><p>执行git pull</p></li>
<li><p>本地分支结果：</p>
<p><img src="image-20231015125629419.png" alt="image-20231015125629419" style="zoom:67%;" /></p></li>
</ol>
<p>2、带有参数</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231026142851130.png" alt="image-20231026142851130" style="zoom:67%;" /></p></li>
<li><p>执行命令：<code>git pull origin main:foo</code></p>
<p><img src="image-20231026142931565.png" alt="image-20231026142931565" style="zoom:67%;" /></p></li>
</ol>
<ul>
<li>它先在本地创建了一个叫 <code>foo</code> 的分支，从远程仓库中的 main
分支中下载提交记录，并合并到 <code>foo</code>，然后再 merge
到我们的当前所在的分支 <code>bar</code> 上。</li>
</ul>
<h3 id="git-push">git push</h3>
<p><code>git push</code>
负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦
<code>git push</code> 完成,
你的朋友们就可以从这个远程仓库下载你分享的成果了。</p>
<blockquote>
<p><em>注意 —— <code>git push</code> 不带任何参数时的行为与 Git
的一个名为 <code>push.default</code>
的配置有关。它的默认值取决于你正使用的 Git
的版本，但是在教程中我们使用的是 <code>upstream</code>。
这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</em></p>
</blockquote>
<h4 id="参数-2">参数</h4>
<p>未指定参数时的行为： Git 是通过当前所在分支的属性来确定远程仓库以及要
push 的目的地的。</p>
<p>带有参数：<code>git push &lt;remote&gt; &lt;place&gt;</code></p>
<ul>
<li>remote：远程仓库名</li>
<li>place：告诉git提交记录来自本地的哪个分支，要推送到远程的哪个分支下。</li>
</ul>
<p>如果要同时指定本地分支和远程其它分支，命令如下：</p>
<p><code>git push origin &lt;source&gt;:&lt;destination&gt;</code></p>
<ul>
<li>source：可以是任何git能识别的位置，如果没有source，那就会把本地和远程的destination分支一并删除</li>
</ul>
<h4 id="案例-2">案例</h4>
<p>1、普通提交</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231016191844111.png" alt="image-20231016191844111" style="zoom:67%;" /></p></li>
<li><p>执行 git push</p>
<p><img src="image-20231016191921287.png" alt="image-20231016191921287" style="zoom:67%;" /></p>
<ul>
<li>本地分支的C2被远程分支接收，远程分支的main分支移动到C2，同时本地的o/main远程分支也会移动到C2.</li>
</ul></li>
</ol>
<p>2、指定远程分支、本地起始位置提交</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231026112610484.png" alt="image-20231026112610484" style="zoom:67%;" /></p></li>
<li><p>执行命令：<code>git push origin foo^:main</code></p>
<p><img src="image-20231026112653938.png" alt="image-20231026112653938" style="zoom:67%;" /></p></li>
</ol>
<p>3、指定不存在的远程分支提交</p>
<ol type="1">
<li><p>初始化</p>
<p><img src="image-20231026112833724.png" alt="image-20231026112833724" style="zoom:67%;" /></p></li>
<li><p>执行命令：<code>git push origin main:newBranch</code></p>
<p><img src="image-20231026112847598.png" alt="image-20231026112847598" style="zoom:67%;" /></p></li>
<li></li>
</ol>
<h3 id="偏离的提交历史">偏离的提交历史</h3>
<h4 id="情景描述">情景描述</h4>
<p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是
，<strong>你的同事这周写了一堆代码，还改了许多你的功能中使用的
API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库</strong>了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>
<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行
<code>git push</code>，Git
应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>
<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你
<code>push</code>
变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>
<p><img src="image-20231016192805874.png" alt="无法push的情况" style="zoom: 67%;" /></p>
<p>这种情况就无法push。</p>
<h4 id="解决">解决</h4>
<p>1、在push之前rebase：</p>
<p>对上图执行：</p>
<ol type="1">
<li><p>git fetch</p>
<p><img src="image-20231016193112280.png" alt="1" style="zoom: 67%;" /></p></li>
<li><p>git rebase o/main</p>
<p><img src="image-20231016193215680.png" alt="image-20231016193215680" style="zoom: 67%;" /></p></li>
<li><p>git push</p>
<p><img src="image-20231016193255128.png" alt="image-20231016193255128" style="zoom:67%;" /></p></li>
</ol>
<p>命令简写：<code>git pull --rebase  git push ;</code></p>
<p>2、利用merge</p>
<p>对上图执行：</p>
<ol type="1">
<li><p>git fetch</p>
<p><img src="image-20231016194113291.png" alt="image-20231016194113291" style="zoom: 67%;" /></p></li>
<li><p>git merge o/main</p>
<p><img src="image-20231016194138506.png" alt="image-20231016194138506" style="zoom:67%;" /></p></li>
<li><p>git push</p>
<p><img src="image-20231016194204792.png" alt="image-20231016194204792" style="zoom:67%;" /></p></li>
</ol>
<h3 id="锁定mainpull-request">锁定main——Pull Request</h3>
<p>远程服务器拒绝：</p>
<p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull
Request流程来合并修改。如果你直接提交(commit)到本地main,
然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<p>新建一个分支feature, 推送到远程服务器. 然后reset
main分支和远程服务器保持一致,
否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>
<p>案例：</p>
<ol type="1">
<li>初始化</li>
</ol>
<p><img src="image-20231019120859987.png" alt="image-20231019120859987" style="zoom:80%;" /></p>
<ol start="2" type="1">
<li><p>执行：</p>
<p>git reset --hard o/main</p>
<p><img src="image-20231019125155533.png" alt="image-20231019125155533" style="zoom:80%;" /></p>
<p>git checkout -b feature C2</p>
<p><img src="image-20231019130605870.png" alt="image-20231019130605870" style="zoom:80%;" /></p>
<p>git push origin feature</p>
<p><img src="image-20231019130645025.png" alt="image-20231019130645025" style="zoom:80%;" /></p></li>
</ol>
<h2 id="git远程高级操作">git远程高级操作</h2>
<h3 id="远程追踪">远程追踪</h3>
<p><code>main</code> 和 <code>o/main</code>
的关联关系就是由分支的“<code>remote tracking</code>”属性决定的。<code>main</code>
被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code>
分支指定了推送的目的地以及拉取后合并的目标。</p>
<p>好吧, 当你克隆仓库的时候, Git
就自动帮你把main分支的这个属性设置好了。当你克隆时, Git
会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如
<code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为
<code>main</code>。</p>
<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>
<p>这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</span><br></pre></td></tr></table></figure>
<p>自定义属性：</p>
<p>1、通过远程分支切换到一个新的分支，执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMain o/main</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个名为 <code>totallyNotMain</code> 的分支，它跟踪远程分支
<code>o/main</code>。</li>
</ul>
<p>2、使用分支命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main foo</span><br></pre></td></tr></table></figure>
<p>这样 <code>foo</code> 就会跟踪 <code>o/main</code> 了。如果当前就在
foo 分支上, 还可以省略 foo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main</span><br></pre></td></tr></table></figure>
<h4 id="案例-3">案例</h4>
<p>1、初始化</p>
<p><img src="image-20231024142941742.png" alt="image-20231024142941742" style="zoom:67%;" /></p>
<p>2、创建新追踪，提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b side o/main</span><br></pre></td></tr></table></figure>
<p><img src="image-20231024143848841.png" alt="image-20231024143848841" style="zoom:67%;" /></p>
<p>3、提交、修复偏离提交历史</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line"></span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>
<p><img src="image-20231024144247076.png" alt="image-20231024144247076" style="zoom:67%;" /></p>
<p>4、提交</p>
<p><img src="image-20231024144315511.png" alt="image-20231024144315511" style="zoom:67%;" /></p>
<h1 id="实践">实践</h1>
<p><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git
Branching</a></p>
<p>最后一章节</p>
<h2 id="推送主分支">推送主分支</h2>
<p>在大型项目中开发人员通常会在（从 <code>main</code>
上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把
side 分支推送到远程仓库），不过本节我们会深入一些.</p>
<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main
总是最新的，始终与远程分支 (o/main) 保持一致。</p>
<p>对于接下来这个工作流，我们集成了两个步骤：</p>
<ul>
<li>将特性分支集成到 <code>main</code> 上</li>
<li>推送并更新远程分支</li>
</ul>
<p>1、初始化</p>
<p><img src="image-20231022143618243.png" alt="image-20231022143618243" style="zoom:67%;" /></p>
<p>2、执行命令</p>
<ol type="1">
<li><p>先拿到远程最新的提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure></li>
<li><p>合并side1到远程分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase o/main side1</span><br></pre></td></tr></table></figure>
<p><img src="image-20231022144424900.png" alt="image-20231022144424900" style="zoom:67%;" /></p></li>
<li><p>合并side2到side1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase side1 side2</span><br></pre></td></tr></table></figure>
<p><img src="image-20231022144442911.png" alt="image-20231022144442911" style="zoom:67%;" /></p></li>
<li><p>合并side3到side2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase side2 side3</span><br></pre></td></tr></table></figure>
<p><img src="image-20231022144505996.png" alt="image-20231022144505996" style="zoom:67%;" /></p></li>
<li><p>main分支合并过来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase side3 main</span><br></pre></td></tr></table></figure>
<p><img src="image-20231022144955962.png" alt="image-20231022144955962" style="zoom:67%;" /></p></li>
<li><p>git push提交</p>
<p><img src="image-20231022145027210.png" alt="image-20231022145027210" style="zoom:67%;" /></p></li>
</ol>
<h2 id="合并远程仓库">合并远程仓库</h2>
<p>1、初始化</p>
<p><img src="image-20231023131945515.png" alt="image-20231023131945515" style="zoom:67%;" /></p>
<p>2、命令</p>
<ul>
<li>自拟版本：</li>
</ul>
<p><img src="image-20231023132542392.png" alt="image-20231023132542392" style="zoom:67%;" /></p>
<ul>
<li><p>简洁版本：</p>
<figure>
<img src="image-20231023132746822.png" alt="image-20231023132746822" />
<figcaption aria-hidden="true">image-20231023132746822</figcaption>
</figure></li>
</ul>
<p>3、最终结果</p>
<p><img src="image-20231023132608987.png" alt="image-20231023132608987" style="zoom:67%;" /></p>
<h2 id="绑定本地和远程分支">绑定本地和远程分支</h2>
<p>注意要有SSH认证。</p>
<p>本地库执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@&lt;你的用户名&gt;/&lt;仓库名&gt;.git</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2023/09/26/git%E5%AD%A6%E4%B9%A0/">https://vlsmhd.github.io/2023/09/26/git%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/26/maven%E5%AD%A6%E4%B9%A0/" title="maven学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">maven学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/21/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="图解系统学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图解系统学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">120</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">76</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#git%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">git核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">版本控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">本地版本控制系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">集中化版本控制系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">分布式版本控制系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git"><span class="toc-number">1.2.</span> <span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E5%AE%83%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">与其它版本管理工具的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">git的状态及工作区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">git使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96git%E4%BB%93%E5%BA%93"><span class="toc-number">2.1.1.</span> <span class="toc-text">获取git仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93"><span class="toc-number">2.1.2.</span> <span class="toc-text">记录每次更新到仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#git-commit"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Git Commit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E6%94%B9%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">2.1.3.</span> <span class="toc-text">推送改到远程仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%A7%BB%E9%99%A4%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">2.1.4.</span> <span class="toc-text">远程仓库的移除、重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="toc-number">2.1.5.</span> <span class="toc-text">查看提交历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.6.</span> <span class="toc-text">撤销操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.7.</span> <span class="toc-text">分支操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">分支合并</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#git-merge"><span class="toc-number">2.1.7.1.1.</span> <span class="toc-text">git merge</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#git-rebase"><span class="toc-number">2.1.7.1.2.</span> <span class="toc-text">git rebase</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BBhead"><span class="toc-number">2.2.1.</span> <span class="toc-text">分离head</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">相对引用——移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%8F%98%E6%9B%B4"><span class="toc-number">2.2.3.</span> <span class="toc-text">撤销变更</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">移动提交记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">整理提交记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8Frebase"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">交互式rebase</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">只提取一个提交记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">2.2.6.</span> <span class="toc-text">提交的技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-tag"><span class="toc-number">2.2.7.</span> <span class="toc-text">git tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-describe"><span class="toc-number">2.2.8.</span> <span class="toc-text">git Describe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E6%94%AFrebase"><span class="toc-number">2.2.9.</span> <span class="toc-text">多分支rebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9parent%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.10.</span> <span class="toc-text">选择parent提交记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E6%8F%90%E4%BA%A4%E5%88%86%E5%8F%91"><span class="toc-number">2.2.11.</span> <span class="toc-text">分支提交分发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">2.3.</span> <span class="toc-text">git远程仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-clone"><span class="toc-number">2.3.1.</span> <span class="toc-text">git clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">远程分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-fetch"><span class="toc-number">2.3.3.</span> <span class="toc-text">git fetch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-pull"><span class="toc-number">2.3.4.</span> <span class="toc-text">git pull</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-1"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-push"><span class="toc-number">2.3.5.</span> <span class="toc-text">git push</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E7%A6%BB%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="toc-number">2.3.6.</span> <span class="toc-text">偏离的提交历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E6%99%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">情景描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AE%9Amainpull-request"><span class="toc-number">2.3.7.</span> <span class="toc-text">锁定main——Pull Request</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E8%BF%9C%E7%A8%8B%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.</span> <span class="toc-text">git远程高级操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%BD%E8%B8%AA"><span class="toc-number">2.4.1.</span> <span class="toc-text">远程追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E4%B8%BB%E5%88%86%E6%94%AF"><span class="toc-number">3.1.</span> <span class="toc-text">推送主分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">3.2.</span> <span class="toc-text">合并远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">3.3.</span> <span class="toc-text">绑定本地和远程分支</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/12/V%E8%81%8A%E9%A1%B9%E7%9B%AE/" title="V聊项目">V聊项目</a><time datetime="2024-03-12T06:37:32.019Z" title="发表于 2024-03-12 14:37:32">2024-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/12/Github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Github使用指南">Github使用指南</a><time datetime="2024-03-12T05:13:50.541Z" title="发表于 2024-03-12 13:13:50">2024-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/01/%E7%94%A8%E5%8F%8B%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/" title="用友实习经历">用友实习经历</a><time datetime="2024-03-01T05:15:29.005Z" title="发表于 2024-03-01 13:15:29">2024-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/27/Feed%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="Feed流系统设计">Feed流系统设计</a><time datetime="2024-02-27T06:57:38.771Z" title="发表于 2024-02-27 14:57:38">2024-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" title="系统设计基础">系统设计基础</a><time datetime="2024-02-27T03:35:23.450Z" title="发表于 2024-02-27 11:35:23">2024-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>