<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>图解网络学习笔记 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础 OSI网络模型  应用层：网络服务与最终用户的一个接口，常见的协议有：HTTP FTP SMTP SNMP DNS. 表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。 会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话. 传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有TCP UDP. 网">
<meta property="og:type" content="article">
<meta property="og:title" content="图解网络学习笔记">
<meta property="og:url" content="https://vlsmhd.github.io/2023/06/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="基础 OSI网络模型  应用层：网络服务与最终用户的一个接口，常见的协议有：HTTP FTP SMTP SNMP DNS. 表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。 会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话. 传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有TCP UDP. 网">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-06-19T06:36:56.436Z">
<meta property="article:modified_time" content="2024-03-09T08:35:43.735Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2023/06/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '图解网络学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-09 16:35:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">77</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">图解网络学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-19T06:36:56.436Z" title="发表于 2023-06-19 14:36:56">2023-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-09T08:35:43.735Z" title="更新于 2024-03-09 16:35:43">2024-03-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="图解网络学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础">基础</h1>
<h2 id="osi网络模型">OSI网络模型</h2>
<ul>
<li>应用层：网络服务与最终用户的一个接口，常见的协议有：<strong>HTTP FTP
SMTP SNMP DNS</strong>.</li>
<li>表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</li>
<li>会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有<strong>TCP
UDP</strong>.</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有<strong>ICMP
IGMP IP等</strong>.</li>
<li>数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
<h2 id="tcpip网络模型">TCP/IP网络模型</h2>
<p>层级自上而下：</p>
<h3 id="应用层">应用层</h3>
<p><strong>对象：</strong>应用软件，如：HTTP、FTP、Telnet、DNS、SMTP等</p>
<p><strong>作用：</strong>给用户提供服务</p>
<p><strong>应用层之间数据传输：</strong>交付给下面一层传输层进行传输。</p>
<h3 id="传输层">传输层</h3>
<p><strong>作用：</strong>为应用层提供数据传输服务，为应用层提供网络支持。</p>
<p><strong>传输协议：</strong></p>
<ul>
<li><p>TCP传输控制协议（<em>Transmission Control
Protocol</em>）：保证数据交付——可靠性</p>
<ul>
<li><p>传输形式：分段传输</p>
<p><img src="图解网络学习笔记/TCP段.png" alt="img" style="zoom: 50%;"></p></li>
</ul></li>
<li><p>UDP：不保证数据准确传输</p></li>
</ul>
<p><strong>设计原则：</strong>简单、高效、专注</p>
<h3 id="网络层">网络层</h3>
<p><strong>作用：</strong>负责传输层的底层传输控制。
包括寻址、路由等。</p>
<p><strong>传输协议：</strong>IP协议（<em>Internet Protocol</em>）</p>
<p><strong>传输形式：</strong>分片传输（超过1500byte）IP报文。</p>
<p><img src="图解网络学习笔记/12.jpg" alt="img" style="zoom:67%;"></p>
<p><strong>IP地址：</strong>每个设备独一无二的编号。</p>
<p>IPv4 协议， IP 地址共 32
位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP
地址虽然做到了区分设备，但是寻址起来就特别麻烦，如何快速找到主机位置？</p>
<p>IP地址分成两个含义：</p>
<ul>
<li>主机号：负责标识同一「子网」下的不同主机；
<ul>
<li><strong>子网掩码</strong>取反，与IP地址与运算</li>
</ul></li>
<li>网络号：负责标识该 IP 地址是属于哪个「子网」的；
<ul>
<li>计算方式：与<strong>子网掩码</strong>与运算</li>
</ul></li>
</ul>
<p><strong>路由：</strong></p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号" style="zoom:67%;">****</p>
<p>相当于导航。</p>
<h3 id="网络接口层">网络接口层</h3>
<p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link
Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data
frame）发送到网络上。</p>
<p><strong>作用：</strong>为网络层提供「链路级别」传输的服务，在以太网这样的底层网络发送数据包。使用MAC地址标识设备。</p>
<h3 id="数据封装格式">数据封装格式</h3>
<p><img src="图解网络学习笔记/封装.png" alt="img" style="zoom:80%;"></p>
<h2 id="键入网址到网页显示的底层逻辑">键入网址到网页显示的底层逻辑</h2>
<figure>
<img src="图解网络学习笔记/2.jpg" alt="简单的网络模型">
<figcaption aria-hidden="true">简单的网络模型</figcaption>
</figure>
<h3 id="http解析url">HTTP解析URL</h3>
<p>url的组成：</p>
<p><img src="图解网络学习笔记/image-20230620144039690.png" alt="image-20230620144039690" style="zoom: 80%;"></p>
<p>url作用：请求服务器里的文件资源。</p>
<p>web服务器文件路径：</p>
<p><img src="图解网络学习笔记/image-20230620144152665.png" alt="image-20230620144152665" style="zoom:80%;"></p>
<p>若不指定数据源路径，默认访问服务器下的默认资源如index.html等。</p>
<p>http请求报文：</p>
<figure>
<img src="图解网络学习笔记/image-20230620144603789.png" alt="image-20230620144603789">
<figcaption aria-hidden="true">image-20230620144603789</figcaption>
</figure>
<p>服务器响应报文：</p>
<figure>
<img src="图解网络学习笔记/image-20230620144639804.png" alt="image-20230620144639804">
<figcaption aria-hidden="true">image-20230620144639804</figcaption>
</figure>
<h3 id="真实地址查询dns">真实地址查询——DNS</h3>
<p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给
<code>Web</code> 服务器。</p>
<p>发送之前，需要得到服务器域名对应的地址。需要DNS</p>
<p><strong>DNS作用：</strong>保存了 <code>Web</code> 服务器域名与
<code>IP</code> 的对应关系</p>
<ul>
<li><p>域名格式：www.server.com，越靠右的位置层级越高。</p></li>
<li><p>域名层级关系：</p>
<p><img src="图解网络学习笔记/5.jpg" alt="DNS 树状结构" style="zoom:80%;"></p></li>
</ul>
<h4 id="域名解析流程">域名解析流程：</h4>
<p><img src="图解网络学习笔记/6.jpg" alt="域名解析的工作流程" style="zoom: 67%;"></p>
<ol type="1">
<li>客户端发出一个DNS请求，向本地DNS服务器询问域名的ip地址是什么</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到key为
www.server.com的缓存，直接返回域名的ip地址给客户端。如果没找到，它会向<strong>根域名服务器</strong>请求询问。</li>
<li>根DNS收到本地的DNS服务器请求后会为其指路，指向比自己层级低一层的顶级域名（com）服务器。</li>
<li>依次类推，中间的每一层域名服务器都在进行指路的操作。...</li>
<li>终于，找到了www.server.com的权威域名服务器，服务器返回ip地址给本地DNS服务器</li>
<li>本地DNS将ip返回到客户端。</li>
</ol>
<h3 id="协议栈">协议栈：</h3>
<p>通过 DNS 获取到 IP 后，就可以把 HTTP
的传输工作交给操作系统中的<strong>协议栈</strong>。</p>
<p><img src="图解网络学习笔记/7.jpg" alt="img" style="zoom:67%;"></p>
<h3 id="tcp可靠传输">TCP可靠传输</h3>
<p>三次握手：</p>
<p><img src="图解网络学习笔记/TCP三次握手.drawio.png" alt="TCP 三次握手" style="zoom: 50%;"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code>
状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li>
<li>然后客户端主动发起连接 <code>SYN</code>，之后处于
<code>SYN-SENT</code> 状态。</li>
<li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code>
客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code>
之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于
<code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li>
<li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于
<code>ESTABLISHED</code> 状态，因为它也一发一收了。</li>
</ul>
<p>linux查看tcp连接信息：</p>
<p>通过 <code>netstat -napt</code> 命令。</p>
<p>TCP分割数据：</p>
<p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP
就需要把 HTTP
的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p>
<p><img src="图解网络学习笔记/11.jpg" alt="MTU 与 MSS" style="zoom:80%;"></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为
<code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP
数据的最大长度。</li>
</ul>
<h1 id="http">HTTP</h1>
<h2 id="概念">概念</h2>
<p>超文本传输协议：</p>
<ul>
<li>协议：
<ul>
<li>「<strong>协</strong>」字，代表的意思是必须有<strong>两个以上的参与者</strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</li>
<li>「<strong>议</strong>」字，代表的意思是对参与者的一种<strong>行为约定和规范</strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。</li>
</ul></li>
<li>传输：
<ul>
<li>http是双向传输协议：基于http通信的双方都有传输信息的能力</li>
<li>传输过程中可以经过中间件</li>
</ul></li>
<li>超文本：超越文字的文本，如图片、视频等多媒体信息。</li>
</ul>
<h3 id="常见状态码">常见状态码</h3>
<figure>
<img src="图解网络学习笔记/6-五大类HTTP状态码.png" alt="五大类 HTTP 状态码">
<figcaption aria-hidden="true">五大类 HTTP 状态码</figcaption>
</figure>
<p>2XX：</p>
<ul>
<li>「<strong>200
OK</strong>」是最常见的成功状态码，表示一切正常。如果是非
<code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK
基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP
分块下载或断点续传，表示响应返回的 body
数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code>
类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL
重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved
Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的
URL 再次访问。</li>
<li>「<strong>302
Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个
URL 来访问。
<ul>
<li>301 和 302 都会在响应头里使用字段
<code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的
URL。</li>
</ul></li>
<li>「<strong>304 Not
Modified</strong>」不具有跳转的含义，表示资源未修改，<strong>重定向已存在的缓冲文件</strong>，也称<strong>缓存重定向</strong>，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code>
类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad
Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403
Forbidden</strong>」表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li>
<li>「<strong>404 Not
Found</strong>」表示<strong>请求的资源在服务器上不存在或未找到</strong>，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code>
类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400
类型，是个笼统通用的错误码，服务器发生了<strong>未知</strong>错误</li>
<li>「<strong>501 Not
Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad
Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service
Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h3 id="http常见字段">http常见字段</h3>
<p><strong>host字段</strong>：</p>
<p>客户端发请求时，用来指定目标服务器的域名。</p>
<p>案例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure>
<ul>
<li>有了 <code>Host</code>
字段，就可以将请求发往「同一台」服务器上的不同网站。</li>
</ul>
<p><strong>Content-length字段</strong>：</p>
<p>存在于服务器在返回数据，表明本次回应的<strong>数据长度</strong>。</p>
<p>案例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure>
<ul>
<li>单位：字节</li>
<li>作为 http body的边界</li>
</ul>
<p><strong>Connection字段：</strong></p>
<p>最常用于客户端要求服务器使用「HTTP
长连接」机制，以便其他请求复用。</p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<ul>
<li>开启了 HTTP Keep-Alive 机制后，
连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</li>
</ul>
<p><strong>Content-Type 字段</strong>：</p>
<p>用于服务器回应时，告诉客户端，<strong>本次数据的格式</strong>。</p>
<p>案例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure>
<p>客户端请求的时候，可以使用 <code>Accept</code>
字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<ul>
<li>以上表示接收任意格式</li>
</ul>
<p><strong>Content-Encoding字段：</strong></p>
<p>字段说明数据的压缩方法。<strong>表示服务器返回的数据使用了什么压缩格式</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
<p>客户端在请求时，用 <code>Accept-Encoding</code>
字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, default</span><br></pre></td></tr></table></figure>
<h3 id="uri和url">URI和URL</h3>
<ul>
<li>URI，全称是Uniform Resource
Identifier)，中文翻译是统一资源标志符，主要作用是<strong>唯一标识一个资源</strong>。
<ul>
<li>具体资源具体地址</li>
</ul></li>
<li>URL，全称是Uniform Resource
Location)，中文翻译是统一资源定位符，主要作用是<strong>提供资源的路径</strong>。打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。
<ul>
<li>全部资源，自己在里面找具体资源</li>
</ul></li>
</ul>
<h2 id="get与post">Get与POST</h2>
<h3 id="get">GET</h3>
<p>定义：从服务器获取指定的资源。</p>
<p>请求参数位置：在 URL 中，URL 规定只能支持 ASCII码字符</p>
<p>请求过程：</p>
<p><img src="图解网络学习笔记/12-Get请求.png" alt="GET 请求" style="zoom: 80%;"></p>
<p>注意：</p>
<ul>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>一般会被缓存</li>
</ul>
<h3 id="post">POST</h3>
<p>根据请求负荷对指定的资源做出处理。</p>
<figure>
<img src="图解网络学习笔记/13-Post请求.png" alt="POST 请求">
<figcaption aria-hidden="true">POST 请求</figcaption>
</figure>
<h3 id="是否安全和幂等">是否安全和幂等</h3>
<p>安全：在 HTTP 协议里，所谓的「安全」是指<strong>请求方法不会 破坏
服务器上的资源</strong>。</p>
<p>幂等：多次执行相同的操作，结果是一样的</p>
<p>从RFC规范的语义看：</p>
<ul>
<li>GET方法既安全又幂等，所以浏览器会对其做缓存，提高查询效率</li>
<li>POST方法不安全不幂等，不会缓存</li>
</ul>
<p>“抽象”建议：</p>
<ul>
<li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET
方法自然就不是安全和幂等。</li>
<li>可以用 POST 方法实现查询数据的请求，这样实现的 POST
方法自然就是安全和幂等。</li>
</ul>
<h2 id="http缓存">HTTP缓存</h2>
<p>为防止频繁请求，将常用的请求缓存到本地，提升响应效率。</p>
<p><img src="图解网络学习笔记/image-20231018145456462.png" alt="浏览器查询缓存流程" style="zoom:80%;"></p>
<p>先强制，后协商（先比值，再比时间）</p>
<h3 id="强制缓存">强制缓存</h3>
<p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，<strong>决定是否使用缓存的主动性在于浏览器</strong>。</p>
<p>强缓存是利用下面这两个 HTTP 响应头部（Response
Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；
<ul>
<li>优先级略高，设置丰富，建议使用</li>
</ul></li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>具体实现流程：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在
Response 头部加上 Cache-Control，Cache-Control
中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与
Cache-Control
中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的
Cache-Control。</li>
</ul>
<h3 id="协商缓存">协商缓存</h3>
<p><img src="图解网络学习笔记/缓存etag.png" alt="img" style="zoom:50%;"></p>
<h4 id="实现">实现</h4>
<p>第一种，比较修改时间：请求头部中的 <code>If-Modified-Since</code>
字段与响应头部中的 <code>Last-Modified</code>
字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的
<code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的
<code>If-Modified-Since</code>：<strong>当资源过期了</strong>，发现响应头中具有
Last-Modified 声明，则<strong>再次发起请求的时候带上 Last-Modified
的时间</strong>，服务器收到请求后发现有 If-Modified-Since
则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP
200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304
走缓存。</li>
</ul>
<p>第二种，比较值：请求头部中的 <code>If-None-Match</code>
字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的
<code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有
Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag
的值。服务器收到请求后进行比对，如果资源没有变化返回
304，如果资源变化了返回 200。</li>
</ul>
<p>ETag的优先级较高：</p>
<h2 id="http特性">HTTP特性</h2>
<ol type="1">
<li>简单</li>
</ol>
<p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是
<code>key-value</code>
简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p>
<ol start="2" type="1">
<li>灵活和易于扩展</li>
</ol>
<p>HTTP
协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<p>同时 HTTP 由于是工作在应用层（ <code>OSI</code>
第七层），则它<strong>下层可以随意变化</strong>，比如：</p>
<ul>
<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；</li>
<li>HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0
传输协议改用了 UDP 协议。</li>
</ul>
<ol start="3" type="1">
<li>应用广泛和跨平台</li>
</ol>
<h3 id="无状态">无状态</h3>
<p>好处：服务器不会记得http的状态，减轻服务器压力。</p>
<p>坏处：服务器不记忆浏览器状态，那对于需要登录的业务来说，每一次操作都需要登录就很麻烦。</p>
<p>解决，cookie机制.</p>
<h4 id="cookie">cookie</h4>
<p><img src="图解网络学习笔记/14-cookie技术.png" alt="Cookie 技术" style="zoom: 67%;"></p>
<h3 id="明文传输">明文传输</h3>
<p>明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark
抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p>
<p>但是这正是这样，HTTP
的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p>
<h2 id="https">HTTPS</h2>
<p>HTTP与HTTPS两者的区别：</p>
<ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS
则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS
安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而
HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS
的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是
443。</li>
<li>HTTPS 协议需要向
CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<p>二者协议层区别：</p>
<p><img src="图解网络学习笔记/19-HTTPS与HTTP.jpeg" alt="HTTP 与 HTTPS 网络层" style="zoom:67%;"></p>
<p>http存在的问题：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p>https利用如下机制解决http存在的问题：</p>
<ul>
<li><strong>信息加密</strong>：</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示</li>
<li><strong>身份证书</strong>：证明网站的来源是√的</li>
</ul>
<h3 id="https的安全性操作">https的安全性操作</h3>
<h4 id="混合加密">混合加密</h4>
<p>作用：用来加密传输<strong>数据</strong></p>
<figure>
<img src="图解网络学习笔记/20-混合加密.png" alt="混合加密">
<figcaption aria-hidden="true">混合加密</figcaption>
</figure>
<p>采用对称加密 + 非对称加密结合的方式实现：</p>
<ul>
<li>非对称加密交换密钥
<ul>
<li>优点：保证了对称会话密钥的安全性，同时公钥可以随意分发，提高传输效率</li>
</ul></li>
<li>对称加密方式加密数据
<ul>
<li>优点：运算速度快，但必须保证密钥不泄露</li>
</ul></li>
</ul>
<h5 id="对称加密">对称加密</h5>
<h5 id="非对称加密">非对称加密</h5>
<p>两个密钥</p>
<ul>
<li>公钥：这个是可以公开给所有人的；</li>
<li>私钥：这个必须由本人管理，不可泄露。</li>
</ul>
<p>双向加解密：</p>
<ul>
<li>公钥加密，私钥解密：保证信息传输的安全，被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li>公钥解密，私钥加密：<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。
<ul>
<li>这个效率很高，一般用于数字签名，也是非对称加密常用的加密方式</li>
</ul></li>
</ul>
<h4 id="摘要算法-数字签名">摘要算法 + 数字签名</h4>
<p>作用：防止传输过程中的内容<strong>不被篡改</strong>。</p>
<p>为传输的数据创建一个指纹，传输到对方以后，对方对内容也计算出一个指纹，比对这俩指纹是否相同，如果相同，则说明传输过程中内容未被篡改。</p>
<p>指纹的计算：通过<strong>摘要算法</strong>（哈希函数），这个函数是单向函数（只能通过内容计算出这个唯一hash码，但是不能通过hash码推出内容）。</p>
<ul>
<li>确保内容不会篡改</li>
<li>存在的问题：但不能确保 <strong>内容 + 哈希值</strong>
一并被其它人替换掉包</li>
</ul>
<p>采用数字签名</p>
<p><img src="图解网络学习笔记/数字签名.png" alt="img" style="zoom: 67%;"></p>
<h4 id="数字证书">数字证书</h4>
<p>身份验证是最终环节，因为公钥是可以被伪造的，然后篡改中间传输的数据，再把私钥掉包做一个假的数字签名，那以上问题又会出现。</p>
<p><img src="图解网络学习笔记/22-数字证书工作流程.jpeg" alt="数子证书工作流程" style="zoom:67%;"></p>
<ul>
<li>第三方CA的私钥，起到了关键的作用。</li>
</ul>
<h3 id="https建立连接的过程">https建立连接的过程</h3>
<p>SSL/TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
</ul>
<p>上面两步：TLS的握手阶段，涉及四次通信，使用不同的<strong>密钥交换算法</strong>。</p>
<ul>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p><img src="图解网络学习笔记/23-HTTPS工作流程.jpeg" alt="HTTPS 连接建立过程" style="zoom: 50%;"></p>
<p><strong><em>1. ClientHello</em></strong></p>
<p>由客户端向服务器发起加密通信请求，就是 <code>ClientHello</code>
请求。</p>
<p>在这一步，客户端主要向服务器发送以下信息：</p>
<ul>
<li>客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li>
<li>客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</li>
<li>客户端支持的密码套件列表，如 RSA 加密算法。</li>
</ul>
<p><strong><em>2. SeverHello</em></strong></p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是
<code>SeverHello</code>。</p>
<p>服务器回应的内容有如下内容：</p>
<ul>
<li>确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li>
<li>服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</li>
<li>确认的密码套件列表，如 RSA 加密算法。</li>
<li>服务器的数字证书。</li>
</ul>
<p><strong><em>3.客户端回应</em></strong></p>
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA
公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p>
<ul>
<li>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</li>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li>
</ul>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p>
<p><strong>服务器和客户端有了这三个随机数（Client Random、Server
Random、pre-master
key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
<p><strong><em>4. 服务器的最后回应</em></strong></p>
<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p>
<p>然后，向客户端发送最后的信息：</p>
<ul>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li>
</ul>
<p>至此，整个 TLS
的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是<strong>使用普通的
HTTP 协议</strong>，只不过用<strong>会话秘钥</strong>加密内容。</p>
<h2 id="http版本演变">HTTP版本演变</h2>
<p><img src="图解网络学习笔记/27-HTTP3.jpeg" alt="HTTP/1 ~ HTTP/3" style="zoom:80%;"></p>
<p><strong>http1.0 -&gt; http1.1</strong></p>
<p>性能改进：</p>
<ol type="1">
<li>长连接的方式改善了 HTTP/1.0 短连接造成的性能开销</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ol>
<p>性能瓶颈：</p>
<ol type="1">
<li>请求 /
响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩
<code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果<strong>服务器响应慢</strong>，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ol>
<p><strong>http1.1 -&gt; http2.0</strong></p>
<p>性能改进：</p>
<ol type="1">
<li><p>头部压缩</p></li>
<li><p>二进制格式</p>
<p>报文的形式是用二进制表示，头信息和数据体都是二进制，并且统称为<strong>帧（frame）</strong></p></li>
<li><p>并发传输</p>
<p>一个TCP连接包含多个stream，一个Stream里有多个Message（请求）</p></li>
<li><p>服务器推送</p></li>
</ol>
<p>性能瓶颈：</p>
<ol type="1">
<li>队头阻塞：TCP层面，多个stream中，如果有一个接收消息的过程中丢失消息，后面的stream都会阻塞</li>
</ol>
<p><strong>http2.0 -&gt; http3.0</strong></p>
<p>性能改进：</p>
<ol type="1">
<li>无队头阻塞：某个流丢包，不会影响其它流，多个stream之间互不影响</li>
<li>快速建立连接</li>
<li>连接迁移</li>
</ol>
<h3 id="http1.1优化">HTTP1.1优化</h3>
<h4 id="减少http请求次数">减少http请求次数</h4>
<p>最直观的减少就是 采用缓存，重复的请求走缓存处理。</p>
<h5 id="减少重定向请求次数">减少重定向请求次数</h5>
<p><strong>重定向请求</strong>：服务器某个资源发生了迁移，其url地址从url1变成url2，客户端并不知情，还是访问url1，服务器回回应302响应码和<code>Location</code>
头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2
请求以获得服务器的资源。</p>
<p><img src="图解网络学习笔记/客户端重定向.png" alt="img" style="zoom:67%;"></p>
<p>如何优化，使得客户端第一次请求就能返回url2的资源？</p>
<p>采用代理服务器：</p>
<p><img src="图解网络学习笔记/代理服务器重定向.png" alt="img" style="zoom:67%;"></p>
<p>如果代理服务器也知道重定向规则，那继续优化为：</p>
<p><img src="图解网络学习笔记/代理服务器重定向2.png" alt="img" style="zoom:67%;"></p>
<h5 id="合并请求">合并请求</h5>
<p>思想：把多个访问小文件的请求，合并成一个大请求，资源相同，但是减少了http请求次数。也就<strong>减少了重复发送的
HTTP 头部</strong>。</p>
<p>案例：图片合并</p>
<p>使用 <code>CSS Image Sprites</code>
技术把多个小图片合成一个大图片</p>
<p><img src="图解网络学习笔记/css精灵.png" alt="图来源于：墨染枫林的CSDN" style="zoom:50%;"></p>
<h5 id="延迟发送请求">延迟发送请求</h5>
<p>思想：按需获取</p>
<p>案例：滚动分页查询</p>
<h4 id="减少http响应的数据大小">减少http响应的数据大小</h4>
<h5 id="无损压缩">无损压缩</h5>
<p>概念：保证资源被压缩的同时，资源不被破坏，还能恢复压缩前的样子。</p>
<p>适用场景：适合用在文本文件、程序可执行文件、程序源代码。</p>
<p>压缩过程：</p>
<ol type="1">
<li>按照语法规则削减：通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。</li>
<li>对原始资源建立统计模型：将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。</li>
</ol>
<p>案例：gzip</p>
<h5 id="有损压缩">有损压缩</h5>
<p>概念：资源被压缩以后，解压的数据与源数据不相同，但是大差不差</p>
<p>适用场景：经常用于压缩多媒体数据，比如音频、视频、图片。</p>
<h4 id="http1.1缺陷">http1.1缺陷</h4>
<ul>
<li><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li>
<li><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6
个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP
慢启动过程给流量带来的影响；</li>
<li><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP
事务（请求和响应）后，才能处理下一个事务；</li>
<li><em>HTTP 头部巨大且重复</em>，由于 HTTP
协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie
的头部，而 Cookie 的大小通常很大；</li>
<li><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li>
</ul>
<h3 id="http2特性优势">HTTP2特性优势</h3>
<h4 id="兼容http1.1">兼容http1.1</h4>
<ol type="1">
<li><p>HTTP/2 没有在 URI
里引入新的协议名，仍然用「http://」表示明文协议，用「https://」表示加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好的实现了协议的<strong>平滑升级</strong>。</p></li>
<li><p>只在应用层做了改变，充分解耦。还是基于 TCP
协议传输，应用层方面为了保持功能上的兼容，HTTP/2 把 HTTP
分解成了<strong>「语义」</strong>和<strong>「语法」</strong>两个部分，「语义」层不做改动，与
HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。</p></li>
</ol>
<h4 id="头部压缩">头部压缩</h4>
<p>HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，开发了
<strong>HPACK</strong> 算法</p>
<h5 id="hpack算法"><strong>HPACK算法</strong></h5>
<p>三种压缩方式：</p>
<ul>
<li>静态字典；</li>
<li>动态字典；</li>
<li>Huffman 编码（压缩算法）；</li>
</ul>
<p>客户端和服务器两端都会建立和维护「<strong>字典</strong>」，用长度较小的索引号表示重复的字符串，再用
Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong>。</p>
<h6 id="静态表编码">静态表编码</h6>
<figure>
<img src="图解网络学习笔记/image-20231209144033607.png" alt="静态表编码">
<figcaption aria-hidden="true">静态表编码</figcaption>
</figure>
<ul>
<li><code>Index</code> 表示索引（Key）</li>
<li><code>Header Value</code> 表示索引对应的 Value</li>
<li><code>Header Name</code> 表示字段的名字</li>
</ul>
<p>表中有的 Index 没有对应的 Header Value，这是因为这些 Value
并不是固定的而是变化的，这些 Value 都会经过 <strong>Huffman
编码</strong>后，才会发送出去。</p>
<p>压缩案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server: nghttpx\r\n</span><br></pre></td></tr></table></figure>
<p>算上冒号空格和末尾的<code>\r\n</code>，共占用了 17
字节，<strong>而使用了静态表和 Huffman 编码，可以将它压缩成 8
字节，压缩率大概 47%</strong>。</p>
<p>抓包分析：</p>
<p><img src="图解网络学习笔记/image-20231209144403126.png" alt="image-20231209144403126" style="zoom:67%;"></p>
<p>根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value
是变化，那么它的 HTTP/2 头部前 2 位固定为
<code>01</code>，所以整个头部格式如下图：</p>
<p><img src="图解网络学习笔记/image-20231209144621374.png" alt="image-20231209144621374" style="zoom:67%;"></p>
<ul>
<li>首先，从静态表中能查到 <code>server</code> 头部字段的 Index 为
54，二进制为 110110，再加上固定 01，头部格式第 1 个字节就是
<code>01110110</code>，这正是上面抓包标注的红色部分的二进制数据。</li>
<li>然后，第二个字节的首个比特位表示 Value 是否经过 Huffman 编码，剩余的
7 位表示 Value 的长度，比如这次例子的第二个字节为
<code>10000110</code>，首位比特位为 1 就代表 Value 字符串是经过 Huffman
编码的，经过 Huffman 编码的 Value 长度为 6。</li>
</ul>
<p>而字符串nghttpx，每个字符有对应的哈夫曼编码。</p>
<h6 id="动态表编码">动态表编码</h6>
<p>不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，Index
从 <code>62</code> 起步，会在编码解码的时候随时更新。</p>
<p>动态表使用生效前提：在同一个连接上，重复传送相同的http头部。</p>
<p>案例：第一次发送时头部中的「<code>User-Agent</code>
」字段数据有上百个字节，经过 Huffman
编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的
Index 号
62。<strong>那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发
1 个字节的 Index
号就好了，因为双方都可以根据自己的动态表获取到字段的数据</strong>。</p>
<h4 id="二进制帧">二进制帧</h4>
<h4 id="并发传输">并发传输</h4>
<h4 id="服务器主动推送资源">服务器主动推送资源</h4>
<h3 id="http3特性">HTTP3特性</h3>
<h1 id="tcp">TCP</h1>
<h2 id="概念-1">概念</h2>
<p>TCP概念：TCP
是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。TCP工作在传输层。</p>
<ul>
<li><strong>面向连接</strong>：<strong>一对一</strong>连接，不能像 UDP
协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP
都可以<strong>保证一个报文一定能够到达接收端</strong>；</li>
<li><strong>字节流</strong>：用户消息通过 TCP
协议传输时，消息可能会被操作系统<strong>分组</strong>成多个的 TCP
报文，如果接收方的程序如果不知道<strong>消息的边界</strong>，是无法读出一个有效的用户消息的。并且
TCP 报文是<strong>有序的</strong>，当前一个TCP
报文没有收到的时候，即使它先收到了后面的 TCP
报文，那么也不能扔给应用层去处理，同时对<strong>重复</strong>的 TCP
报文会自动丢弃。</li>
</ul>
<h3 id="tcp头格式">TCP头格式</h3>
<p><img src="图解网络学习笔记/format,png-20230309230534096.png" alt="TCP 头格式" style="zoom: 50%;"></p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的<strong>随机数</strong>作为其初始值，通过
SYN
包传给接收端主机，每发送一次数据，就<strong>累加</strong>一次该<strong>数据字节数</strong>的大小。</p>
<ul>
<li>作用：<strong>用来解决网络包乱序问题。</strong></li>
</ul>
<p><strong>确认应答号</strong>：指下一次<strong>期望</strong>收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code>
时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的
<code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP
连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code>
时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code>
时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换
<code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h3 id="tcp连接">TCP连接</h3>
<p>概念：实际上是维护的某些状态信息，如Socket、序列号和窗口大小等，这些信息用于保证数据传输的可靠性和流量控制等作用</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
<p>唯一确定一个TCP连接：</p>
<p>根据TCP四元组：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<h3 id="tcp与udp的区别">TCP与UDP的区别</h3>
<p>1、报文格式不同</p>
<p>UDP格式：</p>
<p><img src="图解网络学习笔记/format,png-20230309230439961.png" alt="UDP 头部格式" style="zoom:80%;"></p>
<ul>
<li>校验和：校验和是为了提供可靠的 UDP
首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li>
</ul>
<p>2、连接</p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p>3、服务对象</p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p>4、可靠性</p>
<ul>
<li>TCP
是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p>5、拥塞控制、流量控制</p>
<ul>
<li>TCP
有拥塞控制和流量控制机制，保证数据传输的<strong>安全性</strong>。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p>6、首部开销</p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是
<code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p>7、传输方式</p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP
是一个包一个包的发送，是有<strong>边界</strong>的，但可能会丢包和乱序。</li>
</ul>
<p>8、数据分片不同</p>
<ul>
<li>TCP 的数据大小如果大于 MSS
大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP
数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP
层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<h2 id="连接建立">连接建立</h2>
<h3 id="三次握手过程">三次握手过程</h3>
<p><img src="图解网络学习笔记/TCP三次握手.drawio-16976984172465.png" alt="TCP 三次握手" style="zoom: 50%;"></p>
<ol type="1">
<li>初始化：服务端和客户端都在close状态，随后服务器开启listen监听状态</li>
<li>第一次握手：客户端随机初始化<strong>序列号（client_isn）</strong>，赋值给TCP首部的<strong>序列号</strong>字段，同时把SYN标志位置于1，表示是<strong>SYN报文</strong>。随后发给服务端，向服务端发起连接。客户端进入<code>SYN_SENT</code>状态。
<img src="图解网络学习笔记/format,png-20230309230500953.png" alt="第一个报文 —— SYN 报文" style="zoom: 50%;"></li>
<li>第二次握手：服务端收到SYN同步报文之后，自己也随机初始化<strong>序列号（server_isn）</strong>，赋值给TCP首部的序列号字段，然后把TCP首部的确认应答字段赋值为
client_isn（客户端传来的序列号） +
1。然后将SYN与ACK字段都赋值为1，表示该报文是SYN +
ACK（同步+确认应答）报文。
随后发送给客户端，表示同意连接。服务端进入<code>SYN_RCVD</code>状态。
<img src="图解网络学习笔记/format,png-20230309230504118.png" alt="第二个报文 —— SYN + ACK 报文" style="zoom:50%;"></li>
<li>第三次握手：客户端收到服务端的报文后，还需应答一次报文。这次不会生成序列号，在TCP首部的确认应答号填入<code>server_isn</code>
+
1，将TCP首部ACK标志为1。发送给服务端，此时都进入<code>established</code>状态。
<img src="图解网络学习笔记/format,png-20230309230508297.png" alt="第三个报文 —— ACK 报文" style="zoom: 50%;"></li>
</ol>
<p>注意：前两次握手不能携带数据，第三次握手可以携带数据。</p>
<h3 id="为什么三次握手">为什么三次握手</h3>
<h4 id="避免历史连接">避免历史连接</h4>
<p>旧的连接可能会重复连接，造成混乱，看一下两次握手可能会出现的情况：</p>
<p><img src="图解网络学习笔记/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接" style="zoom:67%;"></p>
<p>可以看到，旧的syn先到达之后，服务端发送ack，由于没有第三次握手了，服务端就会默认连接成功，就会发数据。这发的数据其实是客户端不需要的，因为客户端想要建立新一轮连接而不是这个旧链接，因此占用了服务端额外的资源。</p>
<p><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<p><strong>三次握手避免</strong></p>
<p>情况一：</p>
<p><img src="图解网络学习笔记/format,png-20230309230525514.png" alt="三次握手避免历史连接" style="zoom: 50%;"></p>
<p>客户端连续发送多次SYN
建立连接的报文，<strong>网络拥堵</strong>的情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN」
报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code>
报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 +
1，于是就会回 RST 报文。</li>
<li>服务端收到 RST 报文后，就会释放连接。</li>
<li>后续最新的 SYN
抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>实现：通过客户端一方进行ack Num的比对来实现</p>
<p>情况二：</p>
<p>当服务端在收到 RST 报文之前，先收到了「新 SYN
报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN
报文」。会发生：</p>
<ol type="1">
<li>服务端正常ack，回复旧的SYN报文信息</li>
<li>再次收到新的SYN报文时，会回一个
<code>Challenge Ack</code>报文给客户端，这个ack不是回应本次新SYN的，而是上一次的ack确认号（表示：你不是连过这个了，还连？）
，随后客户端期待的应该是新的SYN的ack，发现不是，会发送RST断开连接。</li>
</ol>
<h4 id="同步双方初始序列号">同步双方初始序列号</h4>
<p>序列号的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK
报文中的序列号知道）；</li>
</ul>
<p>保证可靠的关键——四次握手——三次握手</p>
<p><img src="图解网络学习笔记/format,png-20230309230639121.png" alt="四次握手与三次握手" style="zoom: 50%;"></p>
<h4 id="避免资源浪费">避免资源浪费</h4>
<p>两次握手会发生的缺陷：</p>
<p>当客户端发生的 <code>SYN</code>
报文在<strong>网络</strong>中<strong>阻塞</strong>，客户端没有接收到
<code>ACK</code> 报文，就会重新发送
<code>SYN</code>，由于没有第三次握手，服务端不知道是否连接建立成功，每收到一个syn就会建立一次连接，建立多个冗余连接，就会造成资源浪费。</p>
<p><img src="图解网络学习笔记/format,png-20230309230636571.png" alt="两次握手会造成资源浪费" style="zoom:50%;"></p>
<h3 id="丢失握手报文">丢失握手报文</h3>
<h4 id="第一次丢失">第一次丢失</h4>
<p>第一次报文达不到服务端，客户端就迟迟等不到服务端的SYN +
ACK报文，于是就会触发客户端的超时重传机制。</p>
<ul>
<li>重传的SYN报文序列号一致</li>
<li>最大重传次数：在 Linux 里，客户端的 SYN 报文最大重传次数由
<code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是
5。</li>
</ul>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2
秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8
秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的
2 倍</strong>。</p>
<p>第五次超时重传以后，再等待32s，没有收到服务端回应的ack，就断开连接。</p>
<p>超时重传的总耗时为：63s</p>
<p>假设 tcp_syn_retries 参数值为 3，那么当客户端的 SYN
报文一直在网络中丢失时，会发生下图的过程：</p>
<p><img src="图解网络学习笔记/第1次握手丢失.png" alt="img" style="zoom: 50%;"></p>
<h4 id="第二次丢失">第二次丢失</h4>
<p>客户端收不到ack，触发超时重传</p>
<p>服务端收不到第三次握手的ack，触发超时重传</p>
<ul>
<li>SYN-ACK 报文的最大重传次数由
<code>tcp_synack_retries</code>内核参数决定，默认值是 5。</li>
</ul>
<p>假设 tcp_syn_retries 参数值为 1，tcp_synack_retries 参数值为
2，那么当第二次握手一直丢失时，发生的过程如下图：</p>
<p><img src="图解网络学习笔记/第2次握手丢失.png" alt="img" style="zoom:50%;"></p>
<h4 id="第三次丢失">第三次丢失</h4>
<p>第三次握手的 ACK 是对第二次握手的 SYN
的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，<strong>重传
SYN-ACK 报文</strong>，直到收到第三次握手，或者达到最大重传次数。</p>
<ul>
<li><strong>ACK 报文是不会有重传的，当 ACK
丢失了，就由对方重传对应的报文</strong>。</li>
</ul>
<p>假设 tcp_synack_retries 参数值为
2，那么当第三次握手一直丢失时，发生的过程如下图：</p>
<p><img src="图解网络学习笔记/第三次握手丢失.drawio.png" alt="img" style="zoom:50%;"></p>
<h3 id="初始序列号isn">初始序列号ISN</h3>
<p>随机产生原理：基于时钟，每4微秒 + 1，转一圈要 4.55 个小时。</p>
<p>ISN随机生成算法：<code>ISN = M + F(localhost, localport, remotehost, remoteport)</code>。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的
IP、源端口、目的端口生成一个随机数值。要保证 Hash
算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<h4 id="为什么每次建立连接都要不一样的isn">为什么每次建立连接都要不一样的ISN</h4>
<p><strong>防止历史报文被下一个相同的四元组接收</strong></p>
<p><img src="图解网络学习笔记/isn相同.png" alt="历史报文被新四元组接收" style="zoom:50%;"></p>
<ul>
<li>由于历史报文刚好在服务端接收范围内，因此可以接收</li>
</ul>
<p>解决：采用不同ISN号</p>
<p><img src="图解网络学习笔记/isn不同-17001030466155.png" alt="isn不同" style="zoom: 33%;"></p>
<ul>
<li>采用不同的ISN，<strong>很大程度上</strong>避免历史报文被下一个相同四元组的连接接收。</li>
<li>保证ISN不同，因此，大概率使得对方接收窗口接收范围不包含历史报文</li>
</ul>
<h5 id="序列号回绕">序列号回绕</h5>
<p>序列号和初始序列化：</p>
<ul>
<li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到
TCP 接收端的数据流的一个字节，因为 TCP
是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP
为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个
32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li>
<li><strong>初始序列号</strong>，在 TCP
建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个
32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55
小时</strong>。</li>
</ul>
<p>回绕现象：序列号不是无限递增，当达到32位上限4G，会回归到0值。回归到0值以后，如果发生了连接断开重连，那很有可能新连接会接收到回归0值以后的就报文。</p>
<p>解决：采用TCP时间戳字段，tcp_timestamps 参数是默认开启的，开启了
tcp_timestamps 参数，TCP
头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT
，另一个是能防止序列号回绕（PAWS）</strong>。</p>
<p>案例：假设 TCP 的发送窗口是 1
GB，并且使用了时间戳选项，发送方会为每个 TCP
报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个
6GB 大小的数据流。</p>
<p><img src="图解网络学习笔记/1d497c38621ebc44ee3d8763fd03da67.png" alt="图片" style="zoom:80%;"></p>
<p>32 位的序列号在时刻 D 和 E
之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻
F 重新出现。如果 TCP
无法识别这个绕回的报文，那么数据完整性就会遭到破坏。</p>
<p>使用时间戳选项能够有效的防止上述问题，如果丢失的报文会在时刻 F
重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或
6），因此防回绕序列号算法（PAWS）会将其丢弃。</p>
<h2 id="连接断开">连接断开</h2>
<h3 id="四次挥手过程">四次挥手过程</h3>
<p><img src="图解网络学习笔记/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom: 67%;"></p>
<ol type="1">
<li>第一次挥手：客户端想要断开连接，向服务器发送一个FIN报文，报文中FIN字段被设置为1，随后进入<code>FIN_WAIT_1</code>状态。</li>
<li>第二次挥手：服务端接收完客户端传来的第一个FIN报文之后，会进行确认应答回复，发送给客户端一个ACK报文。服务端进入<code>CLOSED_WAIT</code>状态，客户端如果收到这个报文会进入<code>FIN_WAIT_2</code>状态。</li>
<li>第三次挥手：服务端<strong>将剩余的数据处理完毕</strong>后，会发送给客户端自己的FIN报文。随后服务器进入<code>LAST_ACK</code>状态</li>
<li>第四次挥手：客户端接收服务端的FIN报文后，回复一个ACK确认应答报文，进入TIME_WAIT状态，服务器收到后直接进入CLOSE状态关闭连接。随后客户端会等个一段时间也进入CLOSE状态。</li>
</ol>
<p>注意：主动申请关闭连接的，才会有TIME_WAIT状态。</p>
<h4 id="为什么-time_wait-等待的时间是-2msl">为什么 TIME_WAIT
等待的时间是 2MSL</h4>
<p><strong>MSL（Maximum Segment
Lifetime）概念：</strong>报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<ul>
<li>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code>
秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux
系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</li>
</ul>
<blockquote>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以
<strong>MSL 应该要大于等于 TTL 消耗为 0
的时间</strong>，以确保报文已被自然消亡。</p>
<p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux
认为数据报文经过 64 个路由器的时间不会超过 30
秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
</blockquote>
<p>等待2MSL的作用：</p>
<ol type="1">
<li><p>允许自己最后一次挥手的ACK丢失一次：若 ACK 在第一个 MSL
内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT
状态的连接可以应对。</p></li>
<li><p>防止失效的连接请求报文段出现在本次连接中。</p></li>
</ol>
<p>MSL为什么不是4 或者 8：</p>
<ol type="1">
<li>丢包率低，连续丢包的概率更低，你设置成4MSL，肯定是想容许多次报文丢失的场景出现，但这种概率低，抛弃这种情况获得的收益更大。</li>
<li>防止失效的连接请求报文段出现在本次连接中。</li>
</ol>
<h3 id="丢失挥手报文">丢失挥手报文</h3>
<h4 id="第一次丢失-1">第一次丢失</h4>
<p>第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK
的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由
<code>tcp_orphan_retries</code> 参数控制。</p>
<p>假设 tcp_orphan_retries 参数值为 3：</p>
<p><img src="图解网络学习笔记/第一次挥手丢失.png" alt="img" style="zoom:50%;"></p>
<h4 id="第二次丢失-1">第二次丢失</h4>
<p>ACK
报文是不会重传，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传
FIN 报文直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<p>假设 tcp_orphan_retries 参数值为 2：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.png" alt="img" style="zoom:50%;"></p>
<h4 id="第三次丢失-1">第三次丢失</h4>
<p>客户端收到第二次挥手，也就是收到服务端发送的 ACK
报文后，客户端就会处于 <code>FIN_WAIT2</code>
状态，有两种函数调用方式进入这个状态：</p>
<ul>
<li>close：无法再发送和接收数据，所以<code>FIN_WAIT2</code>
状态不可以持续太久，而 <code>tcp_fin_timeout</code>
控制了这个状态下连接的持续时长，默认值是 60 秒。</li>
<li>shutdown：指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</li>
</ul>
<p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN
报文后（第二次挥手），内核会自动回复 ACK，同时连接处于
<code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close
函数关闭连接。</p>
<p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN
报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK
来确认连接关闭。</p>
<p>假设 <code>tcp_orphan_retrie</code>s = 3：</p>
<p><img src="图解网络学习笔记/第三次挥手丢失.drawio.png" alt="img" style="zoom:50%;"></p>
<h4 id="第四次丢失">第四次丢失</h4>
<p>第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN
报文，重发次数仍然由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>假设 tcp_orphan_retries 为 2：</p>
<p><img src="图解网络学习笔记/第四次挥手丢失drawio.drawio.png" alt="img" style="zoom:50%;"></p>
<h2 id="重传机制">重传机制</h2>
<p>用来针对包丢失的情况。</p>
<h3 id="超时重传">超时重传</h3>
<p>概念：发送数据时，指定一个定时器，超过指定时间后，没有收到ack就重新发送。</p>
<p>重传情况：</p>
<ul>
<li>发送数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><img src="图解网络学习笔记/5-16982399345161.jpg" alt="超时重传的两种情况" style="zoom: 50%;"></p>
<p>RTT（Round-Trip Time 往返时延）：</p>
<p><img src="图解网络学习笔记/6-16982400465447.jpg" alt="RTT" style="zoom:50%;"></p>
<p>概念：数据发送到接收确认应答所隔时间</p>
<p>超时重传时间：RTO（Retransmission Timeout 超时重传时间）</p>
<p>RTO过大过小的情况：</p>
<p><img src="图解网络学习笔记/7-169824019122510.jpg" alt="超时时间较长与较短" style="zoom:50%;"></p>
<ul>
<li>当超时时间 <strong>RTO
较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO
较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>最佳实践：<strong>RTO应该 略大于 RTT</strong></p>
<p>因为网络传输受各种影响，所以RTT是动态变化的，RTO也应该随之变化，需要动态采样往返时间，并经过计算：</p>
<p>采样：</p>
<ul>
<li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT
的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT
有一个大的波动的话，很难被发现的情况。</li>
</ul>
<p>RFC计算标准：</p>
<p><img src="图解网络学习笔记/9.jpg" alt="RFC6289 建议的 RTO 计算 " style="zoom:50%;"></p>
<ul>
<li><code>SRTT</code> 是计算平滑的RTT ，</li>
<li><code>DevRTR</code> 是计算平滑的RTT 与 最新 RTT 的差距。</li>
</ul>
<p>通过最佳实践，大量实验得出：在 Linux 下，<strong>α = 0.125，β =
0.25， μ = 1，∂ = 4</strong>。</p>
<p>多次超时的策略：</p>
<p><strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<h3 id="快速重传">快速重传</h3>
<p>工作方式：</p>
<p><img src="图解网络学习笔记/10.jpg" alt="快速重传机制" style="zoom:67%;"></p>
<p>收到三个相同的ACK，就会重发丢失的报文（ACK中共同指定的）。</p>
<p>缺陷：不知道重传多少个数据包。</p>
<p>假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3
都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2
给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的，
那是选择重传 Seq2 一个报文，还是重传 Seq2
之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p>
<ul>
<li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的
Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。</li>
<li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2
和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传
Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</li>
</ul>
<h3 id="sack">SACK</h3>
<p><code>SACK</code>（ Selective Acknowledgment），
<strong>选择性确认</strong>。
实现方式：在TCP首部添加字段SACK。这样接收方可以告诉发送方接收了哪些数据，这样就可以只重传丢失的数据。</p>
<p><img src="图解网络学习笔记/11-16983060189123.jpg" alt="选择性确认" style="zoom: 50%;"></p>
<h3 id="duplicate-sack">Duplicate SACK</h3>
<p>使用SACK告诉发送者，哪些数据<strong>重复接收</strong>。</p>
<p>应用场景：</p>
<p><strong>ACK丢包</strong></p>
<p><img src="图解网络学习笔记/12-16983063025476.jpg" alt="ACK 丢包" style="zoom:50%;"></p>
<p><strong>网络延时</strong></p>
<p><img src="图解网络学习笔记/13.jpg" alt="网络延时" style="zoom:50%;"></p>
<h2 id="滑动窗口机制">滑动窗口机制</h2>
<p>tcp每发一次数据，就要等待一次确认应答，往返时间越长，效率略低。</p>
<p>引入<strong>窗口</strong>，指定窗口大小，那就能一次性发送如窗口大小一般的数据，无需忙等。</p>
<p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」
<code>3</code> 个 TCP 段，并且中途若有 ACK
丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img src="图解网络学习笔记/15.jpg" alt="用滑动窗口方式并行处理" style="zoom:67%;"></p>
<ul>
<li>该模式称为 累计确认、累计应答</li>
</ul>
<p>窗口的大小：TCP 头里有一个字段叫
<code>Window</code>，也就是窗口大小。
窗口的大小一般由<strong>接收方</strong>决定。</p>
<h3 id="发送方">发送方</h3>
<p><img src="图解网络学习笔记/16.jpg" alt="img" style="zoom: 50%;"></p>
<p>发送全部数据，可用窗口变为0：</p>
<p><img src="图解网络学习笔记/17-16983974204025.jpg" alt="可用窗口耗尽" style="zoom:50%;"></p>
<p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK
确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5
个字节，因为有 5 个字节的数据被应答确认</strong>，接下来
<code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送
<code>52~56</code> 这 5 个字节的数据了。</p>
<p><img src="图解网络学习笔记/18.jpg" alt="32 ~ 36 字节已确认" style="zoom:50%;"></p>
<p>程序表示发送方的四个部分：</p>
<ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA</code>（<em>Send
Unacknoleged</em>）：是一个绝对指针，它指向的是<strong>已发送但未收到确认的第一个字节的序列号</strong>，也就是
#2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是
#3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code>
指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4
的第一个字节了。</li>
</ul>
<p>可用窗口大小：<code>SND.WND</code> - （<code>SND.NXT</code> -
<code>SND.UNA</code> ）</p>
<h3 id="接收方">接收方</h3>
<p><img src="图解网络学习笔记/20.jpg" alt="接收窗口" style="zoom: 50%;"></p>
<p>其中三个接收部分，使用两个指针进行划分:</p>
<ul>
<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>
<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是
#3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code>
指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4
的第一个字节了。</li>
</ul>
<p>发送方、接收方窗口大小大致相似，根据实际情况调整。</p>
<h2 id="流量控制">流量控制</h2>
<p>为什么要流量控制？</p>
<p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费</p>
<p>控制的是哪一方的流量？</p>
<p>控制的发送方流量。</p>
<h3 id="流量控制过程">流量控制过程</h3>
<p><img src="图解网络学习笔记/21.png" alt="流量控制" style="zoom: 50%;"></p>
<p>关键：</p>
<ul>
<li>发送端根据当前的可用窗口大小去发送消息，也就是说被滑动窗口控制流量</li>
<li>发送端可用窗口大小为0，就会被限制发送数据。</li>
</ul>
<h3 id="操作系统缓冲区滑动窗口大小">操作系统缓冲区&amp;滑动窗口大小</h3>
<p>实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p>
<p>当应用进程没办法读取缓冲区内容，会影响缓冲区大小：</p>
<p>场景一：</p>
<ul>
<li>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为
<code>360</code>；</li>
<li>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。</li>
</ul>
<p><img src="图解网络学习笔记/22.jpg" alt="img" style="zoom: 50%;"></p>
<p>最后发送窗口压缩到0，也就是发生了窗口关闭。</p>
<p>场景二：</p>
<p>当服务端系统资源非常紧张的时候，操作系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。</p>
<p><img src="图解网络学习笔记/23.jpg" alt="img" style="zoom: 50%;"></p>
<h3 id="窗口关闭">窗口关闭</h3>
<p>解决上述发送窗口变为负值。</p>
<h4 id="死锁现象">死锁现象</h4>
<p><img src="图解网络学习笔记/24.jpg" alt="窗口关闭潜在的危险" style="zoom:67%;"></p>
<p>窗口关闭后，接收方处理完数据，可以发送消息了，于是告知发送方发送消息，但是告知的信息丢失，导致两方都在忙等。</p>
<p>TCP解决方案：定时器。</p>
<p>TCP 为每个连接设有一个持续定时器，只要 TCP
连接一方收到对方的<strong>零窗口通知</strong>，就启动持续计时器。</p>
<p><img src="图解网络学习笔记/25.jpg" alt="窗口探测" style="zoom:67%;"></p>
<ul>
<li>如果接收窗口仍然为
0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60
秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP
实现就会发 <code>RST</code> 报文来中断连接。</p>
<h3 id="糊涂窗口综合征">糊涂窗口综合征</h3>
<p>问题描述：发送窗口很小，但还要持续频繁发送。<strong>接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。而一次传输，光TCP40Byte，非常浪费。</p>
<p>案例：</p>
<p>接收方的窗口大小是 360
字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p>
<ul>
<li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1
个字节的数据；</li>
<li>在下一个发送方的 TCP 段到达之前，应用程序还从缓冲区中读取了 40
个额外的字节；</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/26.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="糊涂窗口综合症" style="zoom:50%;"></p>
<p>糊涂窗口现象，可以同时发生在发送方和接收方：</p>
<ul>
<li>发送方：可以发送小数据</li>
<li>接收方：可以通告发送方小窗口</li>
</ul>
<p>避免以上两种情况，就能解决糊涂窗口问题：</p>
<h4 id="接收方解决策略">接收方解决策略</h4>
<p>定义当「窗口大小」小于 <code>min( MSS，缓存空间/2 )</code>
，也就是小于 MSS 与 1/2
缓存大小中的最小值时，就会<strong>向发送方通告窗口为
<code>0</code></strong>，也就阻止了发送方再发数据过来。</p>
<h4 id="发送方解决策略">发送方解决策略</h4>
<h5 id="nagle-算法">Nagle 算法</h5>
<p>发送数据满足以下条件之一：</p>
<ul>
<li>窗口大小 &gt;= <code>MSS</code> 并且 数据大小 &gt;=
<code>MSS</code></li>
<li>收到之前发送数据的ACK回包</li>
</ul>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 有数据要发送 {</span><br><span class="line">    <span class="keyword">if</span> 可用窗口大小 &gt;= MSS and 可发送的数据 &gt;= MSS {</span><br><span class="line">    	立刻发送MSS大小的数据</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> 有未确认的数据 {</span><br><span class="line">            将数据放入缓存等待接收ACK</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            立刻发送数据</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Nagle
算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet
或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭
Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="type">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<h2 id="拥塞控制">拥塞控制</h2>
<p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时
TCP
就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....</p>
<p>位置：位于发送方。</p>
<p>拥塞窗口 ≈ 发送窗口</p>
<h3 id="慢启动">慢启动</h3>
<p>TCP
在刚建立连接完成后，慢启动，发送的数据一点一点增加，防止刚开始一次性发送过多数据造成拥塞现象。</p>
<p>算法规则：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加
1 。</strong></p>
<p><img src="图解网络学习笔记/27.jpg" alt="慢启动算法" style="zoom: 67%;"></p>
<p>慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<p>慢启动门限 <code>ssthresh</code> （slow start
threshold）状态变量。</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code>
时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code>
时，就会使用「拥塞避免算法」。</li>
</ul>
<p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p>
<h3 id="拥塞避免">拥塞避免</h3>
<p>算法规则：<strong>每当收到一个 ACK 时，cwnd 增加
1/cwnd。</strong></p>
<p><img src="图解网络学习笔记/28.jpg" alt="拥塞避免" style="zoom:67%;"></p>
<h3 id="拥塞发生">拥塞发生</h3>
<p>网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<h4 id="超时重传-1">超时重传</h4>
<p>ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd
初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
<p><img src="图解网络学习笔记/29.jpg" alt="拥塞发送 —— 超时重传" style="zoom:50%;"></p>
<p>缺陷：</p>
<p>会造成网络卡顿，一瞬间发送窗口降到最低，影响体验。</p>
<h4 id="快速重传-1">快速重传</h4>
<p>快速重传算法：当接收方发现丢了一个中间包的时候，发送三次前一个包的
ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则
<code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<h3 id="快速恢复">快速恢复</h3>
<p><img src="图解网络学习笔记/拥塞发生-快速重传.drawio.png" alt="快速重传和快速恢复" style="zoom:50%;"></p>
<h1 id="ip">IP</h1>
<p>IP工作在：网络层，主要作用：实现主机之间的通信（点对点通信）。</p>
<p><img src="图解网络学习笔记/2-17001911207131.jpg" alt="IP 的作用" style="zoom:50%;"></p>
<p>网络层IP与数据链路层MAC的关系：</p>
<ul>
<li>MAC：实现 <strong>直连</strong>的两个<strong>设备</strong>通信</li>
<li>IP：负责在
<strong>没有直连</strong>的两个<strong>网络</strong>之间的通信</li>
</ul>
<p><img src="图解网络学习笔记/3.jpg" alt="IP 的作用与 MAC 的作用" style="zoom: 67%;"></p>
<ul>
<li>传输过程中：
<ul>
<li>源IP和目的IP都不会改变</li>
<li>源MAC和目标MAC一直在变</li>
</ul></li>
</ul>
<h2 id="ip地址ipv4">IP地址（IPV4）</h2>
<p>IP地址配置单位：并不是主机，而是网卡</p>
<p>表示方式：</p>
<p><img src="图解网络学习笔记/4.jpg" alt="点分十进制" style="zoom:80%;"></p>
<h3 id="分类地址">分类地址</h3>
<p>分类地址：</p>
<p><img src="图解网络学习笔记/7-17001916446728.jpg" alt="IP 地址分类" style="zoom:80%;"></p>
<p>优点：</p>
<ul>
<li>快速判断分类地址，选路简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>不灵活：<strong>同一网络下没有地址层次</strong>，比如一个公司里用了
B
类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种
IP
分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</li>
<li>不现实：<strong>不能很好的与现实网络匹配</strong>，主机数是定死的，不好实现
<ul>
<li>C 类地址能包含的最大主机数量实在太少了，只有 254
个，估计一个网吧都不够用。</li>
<li>而 B 类地址能包含的最大主机数量又太多了，6
万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li>
</ul></li>
</ul>
<h4 id="abc类地址">ABC类地址</h4>
<p>A、B、C类地址主机号范围信息：</p>
<p><img src="图解网络学习笔记/8.jpg" alt="img" style="zoom:67%;"></p>
<p><strong>最大主机数计算方式</strong></p>
<p>看主机号有多少位，有n位，那就有<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.176ex" height="1.714ex" role="img" focusable="false" viewBox="0 -675.5 2729.7 757.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(1229.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2229.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container></span>个主机数。</p>
<p>减去的2个特殊主机地址：</p>
<p><img src="图解网络学习笔记/10-170019180059213.jpg" alt="img" style="zoom:67%;"></p>
<ul>
<li>主机号全为 1
指定某个网络下的所有主机，用于<strong>广播</strong></li>
<li>主机号全为 0 指定<strong>某个网络</strong></li>
</ul>
<h5 id="广播地址"><strong>广播地址</strong></h5>
<p>作用：<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p>
<p>分类：</p>
<ul>
<li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为
192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的
IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li>
<li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为
192.168.0.0/24 的主机向 <strong>192.168.1.255/24 的目标地址</strong>发送
IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有
192.168.1.1~192.168.1.254
的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。）
。</li>
</ul>
<h4 id="de类地址">DE类地址</h4>
<p><img src="图解网络学习笔记/12-170019196383016.jpg" alt="img" style="zoom:80%;"></p>
<h5 id="多播地址">多播地址</h5>
<p>作用：<strong>将包发送给特定组内的所有主机。</strong></p>
<p><img src="图解网络学习笔记/13-170019201814819.jpg" alt="单播、广播、多播通信" style="zoom:50%;"></p>
<h3 id="无分类地址cidr">无分类地址CIDR</h3>
<p>IP地址划分：网络号 + 主机号</p>
<p>表示形式： <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x
位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code></p>
<p>案例：比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24
位是网络号，剩余的 8 位是主机号。</p>
<p><img src="图解网络学习笔记/15-170019236238422.jpg" alt="img" style="zoom:50%;"></p>
<p><strong>为什么分离网络号和主机号</strong></p>
<ul>
<li><p>两台计算机要通讯，要判断是否在一个广播域，也就是<strong>网络地址</strong>是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p></li>
<li><p>不在同一广播域，靠路由器寻址。而路由器寻址，也是靠找到每一个网络，然后把包发到网络内的路由器，进而定位到具体主机··</p></li>
</ul>
<h4 id="子网掩码">子网掩码</h4>
<p>掩码：掩盖掉主机号，只显示网络号。<strong>将子网掩码和 IP
地址按位计算 AND，就可得到网络号。</strong></p>
<p><img src="图解网络学习笔记/16-170019252574725.jpg" alt="img" style="zoom: 67%;"></p>
<h4 id="子网划分">子网划分</h4>
<p>划分形式：</p>
<p><img src="图解网络学习笔记/18-170019313364528.jpg" alt="img" style="zoom: 67%;"></p>
<p>对C类地址划分：</p>
<p>从8位主机号借用两位作为子网号：</p>
<p><img src="图解网络学习笔记/19.jpg" alt="img" style="zoom:50%;"></p>
<p>这样就有四个子网：</p>
<p><img src="图解网络学习笔记/21.jpg" alt="四个子网" style="zoom:67%;"></p>
<h3 id="公有私有ip地址">公有私有ip地址</h3>
<p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。</p>
<p><img src="图解网络学习笔记/22-17002784937201.jpg" alt="img" style="zoom:50%;"></p>
<p>平时我们办公室、家里、学校用的 IP 地址，一般都是私有 IP
地址。因为这些地址允许组织内部的 IT
人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP
地址和我学校的可以是一样的。</p>
<p>就像每个小区都有自己的楼编号和门牌号，你小区家可以叫 1 栋 101
号，我小区家也可以叫 1 栋
101，没有任何问题。但一旦出了小区，就需要带上中山路 666 号（公网 IP
地址），是国家统一分配的，不能两个小区都叫中山路 666。</p>
<p>所以，公有 IP
地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有
IP，这样全世界的人才能访问。并且公有 IP
地址基本上要在整个互联网范围内保持唯一。</p>
<p><img src="图解网络学习笔记/23-17002784937203.jpg" alt="公有 IP 地址与私有 IP 地址" style="zoom:50%;"></p>
<p>公有IP地址管理：</p>
<p>私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由
<code>ICANN</code>
组织管理，中文叫「互联网名称与数字地址分配机构」。</p>
<p>IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP
地址，是按州的方式层层分配。</p>
<p><img src="图解网络学习笔记/24-17002785204957.jpg" alt="img" style="zoom:80%;"></p>
<ul>
<li>ARIN 北美地区</li>
<li>LACNIC 拉丁美洲和一些加勒比群岛</li>
<li>RIPE NCC 欧洲、中东和中亚</li>
<li>AfriNIC 非洲地区</li>
<li>APNIC 亚太地区</li>
</ul>
<p>其中，在中国是由 CNNIC 的机构进行管理，它是中国国内唯一指定的全局 IP
地址管理的组织</p>
<h3 id="路由控制">路由控制</h3>
<p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。</p>
<p>路由控制表：记录着网络地址与下一步应该发送至路由器的地址</p>
<p>流程：</p>
<p><img src="图解网络学习笔记/25-170027942603410.jpg" alt="IP 地址与路由控制" style="zoom: 50%;"></p>
<p><strong>环回地址不会流向网络。</strong></p>
<h3 id="ip分片与重组">IP分片与重组</h3>
<p><strong>MTU：最大传输单元</strong></p>
<ul>
<li>每种数据链路的MTU都是不相同的，如FDDI 数据链路 MTU 4352、以太网的
MTU 是 1500 字节等。</li>
</ul>
<p>以太网内：</p>
<p>当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。经过分片之后的 IP
数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。</p>
<p>假设发送方发送一个 4000
字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3
个小数据报进行传输，再交由接收方重组成大数据报。</p>
<p><img src="图解网络学习笔记/26.jpg" alt="分片与重组" style="zoom:80%;"></p>
<p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP
引入了 <code>MSS</code> 也就是在 TCP 层进行分片不由 IP 层分片，那么对于
UDP 我们尽量不要发送一个大于 <code>MTU</code> 的数据报文。</p>
<h2 id="ipv6">IPV6</h2>
<p>特点：</p>
<p>IPv6 不仅仅只是可分配的地址变多了，它还有非常多的亮点。</p>
<ul>
<li>IPv6 可自动配置，即使没有 DHCP
服务器也可以实现自动分配IP地址，真是<strong>便捷到即插即用</strong>啊。</li>
<li>IPv6 包头包首部长度采用固定的值 <code>40</code>
字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大<strong>提高了传输的性能</strong>。</li>
<li>IPv6 有应对伪造 IP
地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong>。</li>
<li><strong>...</strong> （由你发现更多的亮点）</li>
</ul>
<p><strong>地址标识方法</strong></p>
<p>IPv4 地址长度共 32 位，是以每 8
位作为一组，并用点分十进制的表示方式。</p>
<p>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」
隔开。</p>
<figure>
<img src="图解网络学习笔记/27-17003642385521.jpg" alt="IPv6 地址表示方法">
<figcaption aria-hidden="true">IPv6 地址表示方法</figcaption>
</figure>
<p>如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号
「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<figure>
<img src="图解网络学习笔记/28-17003642385523.jpg" alt="Pv6 地址缺省表示方">
<figcaption aria-hidden="true">Pv6 地址缺省表示方</figcaption>
</figure>
<p><strong>IPV6地址结构</strong></p>
<p>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</p>
<p>IPv6 的地址主要有以下类型地址：</p>
<ul>
<li>单播地址，用于一对一的通信</li>
<li>组播地址，用于一对多的通信</li>
<li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li>
<li>没有广播地址</li>
</ul>
<p><img src="图解网络学习笔记/29-17003642636937.jpg" alt="IPv6地址结构" style="zoom:67%;"></p>
<p><strong>单播地址</strong></p>
<p>对于一对一通信的 IPv6
地址，主要划分了三类单播地址，每类地址的有效范围都不同。</p>
<ul>
<li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4
没有此类型</li>
<li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于 IPv4
的私有 IP</li>
<li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于 IPv4
的公有 IP</li>
</ul>
<p><strong>IPV4与IPV6首部对比</strong></p>
<figure>
<img src="图解网络学习笔记/31.jpg" alt="IPv4 首部与 IPv6 首部的差异">
<figcaption aria-hidden="true">IPv4 首部与 IPv6 首部的差异</figcaption>
</figure>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong>
因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验</li>
<li><strong>取消了分片/重新组装相关字段。</strong>
分片与重组是耗时的过程，IPv6
不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP
首部的一部分了，但它并没有消失，而是可能出现在 IPv6
首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6
的首部成为固定长度的 <code>40</code> 字节</li>
</ul>
<h2 id="ip协议相关">IP协议相关</h2>
<h3 id="dns">DNS</h3>
<p>域名作用：方便人类记忆。</p>
<p>DNS域名解析：将域名网址自动转换为具体的 IP 地址。</p>
<h4 id="域名层级关系">域名层级关系</h4>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如
<code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>
<ul>
<li><strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</li>
</ul>
<p>层级关系类似Linux文件系统一样：</p>
<p><img src="图解网络学习笔记/32.jpg" alt="DNS 树状结构" style="zoom:50%;"></p>
<h4 id="域名解析工作流程">域名解析工作流程</h4>
<p><img src="图解网络学习笔记/33.jpg" alt="域名解析的工作流程" style="zoom: 50%;"></p>
<ol type="1">
<li>客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP
是啥，并发给<strong>本地 DNS 服务器</strong>（也就是客户端的 TCP/IP
设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到
www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS
会去问它的<strong>根域名服务器</strong>：“老大， 能告诉我 www.server.com
的 IP 地址吗？”
根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是
.com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 <strong>.com
顶级域名服务</strong>器地址给你，你去问问它吧。”</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我
www.server.com 的 IP 地址吗？”</li>
<li>顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS
服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问<strong>权威 DNS
服务器</strong>：“老三，www.server.com对应的IP是啥呀？” server.com
的权威 DNS
服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<h3 id="arp">ARP</h3>
<p>IP数据包传输过程中，确定了源 IP 地址和目标 IP
地址后，就会通过主机「路由表」确定 IP 数据包下一跳。</p>
<p>下一跳的MAC地址，通过ARP协议计算。</p>
<p><strong>ARP如何确定MAC地址</strong></p>
<p>借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC
地址。</p>
<p><img src="图解网络学习笔记/34.jpg" alt="ARP 广播" style="zoom:50%;"></p>
<ul>
<li>主机会通过<strong>广播</strong>发送 ARP
请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP
请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP
地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP
响应包</strong>返回给主机。</li>
</ul>
<blockquote>
<p>操作系统通常会把第一次通过 ARP 获取的 MAC
地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。不过，MAC
地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</p>
</blockquote>
<h4 id="rarp">RARP</h4>
<p>已知MAC地址，求IP地址。</p>
<p>通常这需要架设一台 <code>RARP</code>
服务器，在这个服务器上<strong>注册设备的 MAC 地址及其 IP
地址</strong>。然后再将这个设备接入到网络：</p>
<ul>
<li>设备（主机）会发送一条「我的 MAC
地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li>
<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为
XXXX」的信息给这个设备。</li>
</ul>
<p>最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP
地址。</p>
<p><img src="图解网络学习笔记/35.jpg" alt="RARP" style="zoom:80%;"></p>
<h3 id="dhcp">DHCP</h3>
<p>作用：让主机动态获取IP地址，避免自配</p>
<p><strong>工作过程</strong></p>
<p><img src="图解网络学习笔记/36.jpg" alt="DHCP 工作流程" style="zoom:50%;"></p>
<ol type="1">
<li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP
数据报
<ul>
<li>由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是
<strong>UDP 广播通信</strong>，其使用的广播目的地址是
255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP
地址。</li>
<li>DHCP 客户端将该 IP
数据报传递给链路层，<strong>链路层</strong>然后将<strong>帧广播</strong>到所有的网络中设备。</li>
</ul></li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP
OFFER）</strong> 向客户端做出响应。
<ul>
<li>该报文仍然使用 IP 广播地址 255.255.255.255</li>
<li>该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS
服务器以及 <strong>IP 地址租用期</strong>。</li>
</ul></li>
<li>客户端收到一个或多个服务器的 DHCP
提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP
请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li>
<li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP
请求报文进行响应，应答所要求的参数</li>
</ol>
<p><strong>特点</strong></p>
<ol type="1">
<li>全程UDP广播通信</li>
</ol>
<h4 id="dhcp中继代理">DHCP中继代理</h4>
<p>客户端与服务器通信用的是广播，但如果 DHCP
服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那每个网络都要配一个
DHCP 服务器，开销过大，因此诞生了DHCP中继代理，有了 DHCP
中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP
服务器统一进行管理。</strong></p>
<p><img src="图解网络学习笔记/37.jpg" alt=" DHCP 中继代理" style="zoom:50%;"></p>
<ul>
<li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP
中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP
服务器。</li>
<li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP
中继代理将此包广播给 DHCP 客户端 。</li>
</ul>
<h3 id="nat">NAT</h3>
<p>目的：缓解对IP地址的高频使用。</p>
<p>原理：是一种<strong>网络地址转换</strong>技术，把私有 IP
地址转换成公有 IP 地址。</p>
<p><img src="图解网络学习笔记/38.jpg" alt="NAT" style="zoom: 50%;"></p>
<ul>
<li>普通的 NAT 转换没什么意义，IP地址并没有减少使用</li>
</ul>
<p>把 IP 地址 + 端口号一起进行转换，就用一个全球 IP
地址，这种转换技术就叫<strong>网络地址与端口转换 NAPT。</strong></p>
<p><strong>缺点</strong></p>
<p>NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT
转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>
<p><strong>改进</strong></p>
<ol type="1">
<li><p>使用IPV6</p></li>
<li><p>采用NAT穿透技术</p>
<p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT
设备之后，并且会主动获得 NAT 设备的公有
IP，并为自己建立端口映射条目，注意这些都是
NAT设备后的应用程序自动完成的。</p>
<p>也就是说，在 NAT
穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT
设备要修改它外发的数据包，于是它主动配合 NAT
设备的操作，主动地建立好映射，这样就不像以前由 NAT
设备来建立映射了。</p>
<p>说人话，就是客户端主动从 NAT 设备获取公有 IP
地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT
设备来进行转换了。</p></li>
</ol>
<h4 id="napt">NAPT</h4>
<p><img src="图解网络学习笔记/39.jpg" alt="NAPT" style="zoom: 50%;"></p>
<ol type="1">
<li>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器
183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。</li>
<li>到达路由器进行转发以后，<strong>两个私有 IP 地址都转换 IP
地址为公有地址
120.229.175.121，但是以不同的端口号作为区分。</strong></li>
<li>随后生成一个 NAPT
路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B
能同时与服务器之间进行通信。
<ul>
<li>这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP
连接首次握手时的 SYN
包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN
包的确认应答从表中被删除。</li>
</ul></li>
</ol>
<h3 id="icmp">ICMP</h3>
<p>ICMP 全称是 <strong>Internet Control Message
Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p>
<p><strong>作用：</strong></p>
<ul>
<li><strong>确认IP包是否到达目标地址</strong></li>
<li><strong>报告发送过程中 IP 包被废弃的原因</strong></li>
<li><strong>改善网络设置</strong></li>
</ul>
<p>应对不可达的报文，ICMP工作流程：</p>
<p><img src="图解网络学习笔记/40.jpg" alt="ICMP 目标不可达消息" style="zoom:50%;"></p>
<h4 id="包头格式">包头格式</h4>
<p><img src="图解网络学习笔记/5-170062309557316.jpg" alt="ICMP 报文" style="zoom:50%;"></p>
<h4 id="类型">类型</h4>
<p>ICMP 大致可以分为两大类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li>
<li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li>
</ul>
<p><img src="图解网络学习笔记/41.jpg" alt="常见的 ICMP 类型" style="zoom:50%;"></p>
<h5 id="查询报文">查询报文</h5>
<p>回送消息 —— 类型 <code>0</code> 和 <code>8</code></p>
<p>作用：回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code>
命令就是利用这个消息实现的。</p>
<ul>
<li>只要正常返回了ICMP回送响应，发送端到接收端就可达状态</li>
</ul>
<p>可以向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型
<code>8</code>），也可以接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型
<code>0</code>）。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/8.jpg" alt="ICMP 回送请求和回送应答报文" style="zoom: 50%;"></p>
<p>相比原生的 ICMP，这里多了两个字段：</p>
<ul>
<li><strong>标识符</strong>：用以区分是哪个应用程序发 ICMP
包，比如用进程 <code>PID</code> 作为标识符；</li>
<li><strong>序号</strong>：序列号从 <code>0</code>
开始，每发送一次新的回送请求就会加 <code>1</code>，
可以用来确认网络包是否有丢失。</li>
</ul>
<h5 id="差错报文">差错报文</h5>
<p>目标不可达类型的代码：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/9.jpg" alt="目标不可达类型的常见代码号" style="zoom:50%;"></p>
<p><strong>a.网络不可达代码为 0</strong></p>
<p><em>外卖版本：</em></p>
<p>小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C
区楼，小林表示头上很多问号，压根就没这个地方。</p>
<p><em>正常版本：</em></p>
<p>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方
IP 的网络号，就通过 ICMP
协议以<strong>网络不可达</strong>（<code>Network Unreachable</code>）的原因告知主机。</p>
<p>自从不再有网络分类以后，网络不可达也渐渐不再使用了。</p>
<p><strong>b.主机不可达代码为 1</strong></p>
<p><em>外卖版本：</em></p>
<p>小林第二次送外卖时，这次小区有 5 层楼高的 C
区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房
，说明找不到这个房间。</p>
<p><em>正常版本：</em></p>
<p>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP
协议以<strong>主机不可达</strong>（<code>Host Unreachable</code>）的原因告知主机。</p>
<p><strong>c. 协议不可达代码为 2</strong></p>
<p><em>外卖版本：</em></p>
<p>小林第三次送外卖时，这次小区有 C 区楼，也有 601
号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~</p>
<p><em>正常版本：</em></p>
<p>当主机使用 TCP
协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP
协议访问，那么会通过 ICMP
协议以<strong>协议不可达</strong>的原因告知主机。</p>
<p><strong>d. 端口不可达代码为 3</strong></p>
<p><em>外卖版本：</em></p>
<p>小林第四次送外卖时，这次小区有 C 区楼，也有 601
号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。</p>
<p><em>正常版本：</em></p>
<p>当主机访问对端主机 8080
端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听
8080 端口，那么会通过 ICMP
协议以<strong>端口不可达</strong>的原因告知主机。</p>
<p><strong>e. 需要进行分片但设置了不分片位代码为 4</strong></p>
<p><em>外卖版本：</em></p>
<p>小林第五次送外卖时，这次是个吃播博主点了 100
份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。</p>
<p><em>正常版本：</em></p>
<p>发送端主机发送 IP 数据报时，将 IP
首部的<strong>分片禁止标志位</strong>设置为<code>1</code>。根据这个标志位，途中的路由器遇到超过
MTU 大小的数据包时，不会进行分片，而是直接抛弃。</p>
<h3 id="igmp">IGMP</h3>
<p><img src="图解网络学习笔记/42.jpg" alt="组播模型" style="zoom:50%;"></p>
<p><strong>IGMP
是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p>
<ul>
<li>IGMP
报文向<strong>路由器申请</strong>加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过
IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP
路由器表，路由器后续就会转发组播包到对应的主机了。</li>
<li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为
1，因为 IGMP 是工作在主机与连接的路由器之间。</li>
</ul>
<h4 id="工作机制"><strong>工作机制</strong></h4>
<p><strong>常规查询与响应工作机制</strong></p>
<p><img src="图解网络学习笔记/43.jpg" alt=" IGMP 常规查询与响应工作机制" style="zoom: 67%;"></p>
<ol type="1">
<li>路由器会周期性发送目的地址为
<code>224.0.0.1</code>（组播地址，表示同一网段内所有主机和路由器）
<strong>IGMP 常规查询报文</strong>。</li>
<li>主机1 和 主机 3
收到这个查询，随后会启动「<strong>报告延迟计时器</strong>」，计时器的时间是随机的，通常是
0~10 秒，计时器超时后主机就会发送 <strong>IGMP
成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP
地址为组播地址）。
<ul>
<li>如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的
IGMP 报文数量。</li>
</ul></li>
<li>路由器收到主机的成员关系报文后，就会在 IGMP
路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li>
</ol>
<p><strong>离开组播组工作机制</strong></p>
<p>情况一：网段中仍有该组播组</p>
<p><img src="图解网络学习笔记/44.jpg" alt=" IGMPv2 离开组播组工作机制 情况1" style="zoom:67%;"></p>
<ol type="1">
<li>主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报文，报文的目的地址是
224.0.0.2（表示发向网段内的所有路由器）</li>
<li>路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP
特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1
组的其他成员。</li>
<li>主机 3 仍然是组 224.1.1.1
的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发
224.1.1.1 的组播数据包。</li>
</ol>
<p>情况二：网段中没有该组播组</p>
<p><img src="图解网络学习笔记/45.jpg" alt=" IGMPv2 离开组播组工作机制 情况2" style="zoom:67%;"></p>
<ol type="1">
<li>主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报文。</li>
<li>路由器收到该报文后，以 1 秒为间隔连续发送 IGMP
特定组查询报文（共计发送 2 个）。此时在该网段内，组 224.1.1.1
已经没有其他成员了，因此没有主机响应这个查询。</li>
<li>一定时间后，路由器认为该网段中已经没有 224.1.1.1
组播组成员了，将不会再向这个网段转发该组播地址的数据包。</li>
</ol>
<h2 id="ping工作原理">ping工作原理</h2>
<p>案例：</p>
<figure>
<img src="图解网络学习笔记/12-17015972052891.jpg" alt="主机 A ping 主机 B">
<figcaption aria-hidden="true">主机 A ping 主机 B</figcaption>
</figure>
<ol type="1">
<li><p>源主机构建一个回送请求的ICMP报文</p></li>
<li><p>封装ip报文，添加IP头</p></li>
<li><p>封装MAC地址，添加MAC头</p>
<ol type="1">
<li>本地ARP映射表查看是否有对端主机的MAC地址
<ul>
<li>有：封装</li>
<li>没有：发送ARP协议请求查询</li>
</ul></li>
</ol></li>
<li><p>数据链路层构建数据帧</p></li>
</ol>
<p>步骤流程图：</p>
<p><img src="图解网络学习笔记/17.png" alt="主机 A ping 主机 B 期间发送的事情"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2023/06/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://vlsmhd.github.io/2023/06/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" title="设计模式学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/19/leetcode%E6%A0%91%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode树题目专项训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode树题目专项训练</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机网络—自顶向下方法——学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-26</div><div class="title">计算机网络—自顶向下方法——学习笔记</div></div></a></div><div><a href="/2023/04/01/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/" title="Leetcode-Hot100-22.括号生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">Leetcode-Hot100-22.括号生成</div></div></a></div><div><a href="/2023/04/03/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" title="Leetcode-Hot100-226. 翻转二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">Leetcode-Hot100-226. 翻转二叉树</div></div></a></div><div><a href="/2023/03/31/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" title="Leetcode-Hot100-3.无重复字符的最长子串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-31</div><div class="title">Leetcode-Hot100-3.无重复字符的最长子串</div></div></a></div><div><a href="/2023/05/04/Leetcode-Hot100-105.-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" title="Leetcode-Hot100-105. 从前序与中序遍历序列构造二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-04</div><div class="title">Leetcode-Hot100-105. 从前序与中序遍历序列构造二叉树</div></div></a></div><div><a href="/2023/04/24/Leetcode-Hot100-108.-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="Leetcode-Hot100-108. 将有序数组转换为二叉搜索树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-24</div><div class="title">Leetcode-Hot100-108. 将有序数组转换为二叉搜索树</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">77</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#osi%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">OSI网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">TCP&#x2F;IP网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">网络接口层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">数据封装格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91"><span class="toc-number">1.3.</span> <span class="toc-text">键入网址到网页显示的底层逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%A7%A3%E6%9E%90url"><span class="toc-number">1.3.1.</span> <span class="toc-text">HTTP解析URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2dns"><span class="toc-number">1.3.2.</span> <span class="toc-text">真实地址查询——DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">域名解析流程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">协议栈：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">TCP可靠传输</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">http常见字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uri%E5%92%8Curl"><span class="toc-number">2.1.3.</span> <span class="toc-text">URI和URL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get%E4%B8%8Epost"><span class="toc-number">2.2.</span> <span class="toc-text">Get与POST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-number">2.2.1.</span> <span class="toc-text">GET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#post"><span class="toc-number">2.2.2.</span> <span class="toc-text">POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">是否安全和幂等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">协商缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%89%B9%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">无状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">cookie</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93"><span class="toc-number">2.4.2.</span> <span class="toc-text">明文传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https"><span class="toc-number">2.5.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.1.</span> <span class="toc-text">https的安全性操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">混合加密</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.5.1.1.1.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.5.1.1.2.</span> <span class="toc-text">非对称加密</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">摘要算法 + 数字签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">数字证书</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">https建立连接的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%89%88%E6%9C%AC%E6%BC%94%E5%8F%98"><span class="toc-number">2.6.</span> <span class="toc-text">HTTP版本演变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http1.1%E4%BC%98%E5%8C%96"><span class="toc-number">2.6.1.</span> <span class="toc-text">HTTP1.1优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91http%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">减少http请求次数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="toc-number">2.6.1.1.1.</span> <span class="toc-text">减少重定向请求次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82"><span class="toc-number">2.6.1.1.2.</span> <span class="toc-text">合并请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">2.6.1.1.3.</span> <span class="toc-text">延迟发送请求</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91http%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">减少http响应的数据大小</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.6.1.2.1.</span> <span class="toc-text">无损压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.6.1.2.2.</span> <span class="toc-text">有损压缩</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http1.1%E7%BC%BA%E9%99%B7"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">http1.1缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2%E7%89%B9%E6%80%A7%E4%BC%98%E5%8A%BF"><span class="toc-number">2.6.2.</span> <span class="toc-text">HTTP2特性优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9http1.1"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">兼容http1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">头部压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hpack%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.2.2.1.</span> <span class="toc-text">HPACK算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81"><span class="toc-number">2.6.2.2.1.1.</span> <span class="toc-text">静态表编码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8%E7%BC%96%E7%A0%81"><span class="toc-number">2.6.2.2.1.2.</span> <span class="toc-text">动态表编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7"><span class="toc-number">2.6.2.3.</span> <span class="toc-text">二进制帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93"><span class="toc-number">2.6.2.4.</span> <span class="toc-text">并发传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">2.6.2.5.</span> <span class="toc-text">服务器主动推送资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http3%E7%89%B9%E6%80%A7"><span class="toc-number">2.6.3.</span> <span class="toc-text">HTTP3特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp"><span class="toc-number">3.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">TCP头格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">TCP连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">TCP与UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">3.2.</span> <span class="toc-text">连接建立</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">三次握手过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">为什么三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">避免历史连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%8C%E6%96%B9%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">同步双方初始序列号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">避免资源浪费</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87"><span class="toc-number">3.2.3.</span> <span class="toc-text">丢失握手报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">第一次丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">第二次丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">第三次丢失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7isn"><span class="toc-number">3.2.4.</span> <span class="toc-text">初始序列号ISN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%83%BD%E8%A6%81%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84isn"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">为什么每次建立连接都要不一样的ISN</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7%E5%9B%9E%E7%BB%95"><span class="toc-number">3.2.4.1.1.</span> <span class="toc-text">序列号回绕</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80"><span class="toc-number">3.3.</span> <span class="toc-text">连接断开</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">四次挥手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-time_wait-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2msl"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">为什么 TIME_WAIT
等待的时间是 2MSL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E6%8C%A5%E6%89%8B%E6%8A%A5%E6%96%87"><span class="toc-number">3.3.2.</span> <span class="toc-text">丢失挥手报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%A2%E5%A4%B1-1"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">第一次丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%A2%E5%A4%B1-1"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">第二次丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%A2%E5%A4%B1-1"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">第三次丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">第四次丢失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">3.4.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">3.4.2.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sack"><span class="toc-number">3.4.3.</span> <span class="toc-text">SACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duplicate-sack"><span class="toc-number">3.4.4.</span> <span class="toc-text">Duplicate SACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">滑动窗口机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9"><span class="toc-number">3.5.1.</span> <span class="toc-text">发送方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9"><span class="toc-number">3.5.2.</span> <span class="toc-text">接收方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.6.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">3.6.1.</span> <span class="toc-text">流量控制过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.6.2.</span> <span class="toc-text">操作系统缓冲区&amp;滑动窗口大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="toc-number">3.6.3.</span> <span class="toc-text">窗口关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%8E%B0%E8%B1%A1"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">死锁现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81"><span class="toc-number">3.6.4.</span> <span class="toc-text">糊涂窗口综合征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">接收方解决策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">发送方解决策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nagle-%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.2.1.</span> <span class="toc-text">Nagle 算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.7.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">3.7.2.</span> <span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="toc-number">3.7.3.</span> <span class="toc-text">拥塞发生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0-1"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-1"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">快速重传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">3.7.4.</span> <span class="toc-text">快速恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ip"><span class="toc-number">4.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80ipv4"><span class="toc-number">4.1.</span> <span class="toc-text">IP地址（IPV4）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.1.</span> <span class="toc-text">分类地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abc%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">ABC类地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.1.1.1.</span> <span class="toc-text">广播地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#de%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">DE类地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">多播地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80cidr"><span class="toc-number">4.1.2.</span> <span class="toc-text">无分类地址CIDR</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">子网掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">子网划分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E7%A7%81%E6%9C%89ip%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.3.</span> <span class="toc-text">公有私有ip地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.4.</span> <span class="toc-text">路由控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84"><span class="toc-number">4.1.5.</span> <span class="toc-text">IP分片与重组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv6"><span class="toc-number">4.2.</span> <span class="toc-text">IPV6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">4.3.</span> <span class="toc-text">IP协议相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dns"><span class="toc-number">4.3.1.</span> <span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">域名层级关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">域名解析工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arp"><span class="toc-number">4.3.2.</span> <span class="toc-text">ARP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rarp"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">RARP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dhcp"><span class="toc-number">4.3.3.</span> <span class="toc-text">DHCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dhcp%E4%B8%AD%E7%BB%A7%E4%BB%A3%E7%90%86"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">DHCP中继代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nat"><span class="toc-number">4.3.4.</span> <span class="toc-text">NAT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#napt"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">NAPT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#icmp"><span class="toc-number">4.3.5.</span> <span class="toc-text">ICMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">包头格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87"><span class="toc-number">4.3.5.2.1.</span> <span class="toc-text">查询报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87"><span class="toc-number">4.3.5.2.2.</span> <span class="toc-text">差错报文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#igmp"><span class="toc-number">4.3.6.</span> <span class="toc-text">IGMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">工作机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">ping工作原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/13/WebSocket/" title="WebSocket">WebSocket</a><time datetime="2024-03-13T09:07:51.702Z" title="发表于 2024-03-13 17:07:51">2024-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/12/V%E8%81%8A%E9%A1%B9%E7%9B%AE/" title="V聊项目">V聊项目</a><time datetime="2024-03-12T06:37:32.019Z" title="发表于 2024-03-12 14:37:32">2024-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/12/Github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Github使用指南">Github使用指南</a><time datetime="2024-03-12T05:13:50.541Z" title="发表于 2024-03-12 13:13:50">2024-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/01/%E7%94%A8%E5%8F%8B%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/" title="用友实习经历">用友实习经历</a><time datetime="2024-03-01T05:15:29.005Z" title="发表于 2024-03-01 13:15:29">2024-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/27/Feed%E6%B5%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="Feed流系统设计">Feed流系统设计</a><time datetime="2024-02-27T06:57:38.771Z" title="发表于 2024-02-27 14:57:38">2024-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>