<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java面试整理 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础语法 基本数据类型 几种基本数据类型 8种数据类型：  6 种数字类型：  4 种整数型：byte、short、int、long 2 种浮点型：float、double  1 种字符类型：char 1 种布尔型：boolean。  它们所占空间：            基本类型 位数 字节 默认值 取值范围     byte">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试整理">
<meta property="og:url" content="https://vlsmhd.github.io/2023/07/31/java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="基础语法 基本数据类型 几种基本数据类型 8种数据类型：  6 种数字类型：  4 种整数型：byte、short、int、long 2 种浮点型：float、double  1 种字符类型：char 1 种布尔型：boolean。  它们所占空间：            基本类型 位数 字节 默认值 取值范围     byte">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-07-31T09:19:49.814Z">
<meta property="article:modified_time" content="2024-01-11T15:49:43.393Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2023/07/31/java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-11 23:49:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">71</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-31T09:19:49.814Z" title="发表于 2023-07-31 17:19:49">2023-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-11T15:49:43.393Z" title="更新于 2024-01-11 23:49:43">2024-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础语法">基础语法</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<h3 id="几种基本数据类型">几种基本数据类型</h3>
<p>8种数据类型：</p>
<ul>
<li>6 种数字类型：
<ul>
<li>4
种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul></li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<p>它们所占空间：</p>
<p><a id="基本类型表"></a></p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 5%" />
<col style="width: 17%" />
<col style="width: 9%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">基本类型</th>
<th style="text-align: left;">位数</th>
<th style="text-align: left;">字节</th>
<th style="text-align: left;">默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>byte</code></td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td>-128 ~ 127</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;">32</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;">64</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">'u0000'</td>
<td>0 ~ 65535</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>float</code></td>
<td style="text-align: left;">32</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>double</code></td>
<td style="text-align: left;">64</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">依赖于JVM厂商</td>
<td style="text-align: left;">false</td>
<td>true、false</td>
</tr>
</tbody>
</table>
<p>跨平台特性也有一部分原因是因为java里基础类型大小不变的这一特性。</p>
<h3 id="基本类型和包装类型的区别">基本类型和包装类型的区别</h3>
<p><strong>用途：</strong></p>
<p>基本类型：常量的设定、局部变量</p>
<p>包装类型：包装类型可用于泛型、方法参数、对象属性等</p>
<p><strong>存储类型：</strong></p>
<p>基本类型：</p>
<ul>
<li>局部变量存放在 Java <strong>虚拟机栈</strong>中的局部变量表中。</li>
<li>成员变量放在堆中</li>
</ul>
<p>包装类型：属于对象类型，几乎都在堆里。</p>
<p><strong>占用空间：</strong></p>
<p>包装 &gt; 基本</p>
<p><strong>默认值：</strong></p>
<p>包装：不赋值就是null 基本：都有基础默认值，具体见<a
href="#基本类型表">上表</a>。</p>
<p><strong>比较方式：</strong></p>
<p>基本数据类型：==<code>比较的是值。</code></p>
<p>包装数据类型：<code>==</code>
比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用
<code>equals()</code> 方法。</p>
<h3 id="包装类型的缓存机制">包装类型的缓存机制</h3>
<p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code>
这 4 种包装类默认创建了数值 <strong>[-128，127]</strong>
的相应类型的缓存数据，<code>Character</code> 创建了数值在
<strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回
<code>True</code> or <code>False</code>。</p>
<p><strong><code>Character</code> 缓存源码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Integer 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>值比较：对于Integer类型，处在[-128 ,
127]之间的值可以用==比较，因为就在缓存中，可以复用。而以外的值会存放在堆中，不会复用已有的对象，推荐用equals比较。</li>
</ul>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<h3 id="自动装箱与拆箱">自动装箱与拆箱</h3>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱   Integer.valueOf </span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱		Integer.intValue</span></span><br></pre></td></tr></table></figure>
<p>解析字节码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line">   LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line">   ALOAD 0</span><br><span class="line"></span><br><span class="line">   BIPUSH 10</span><br><span class="line"></span><br><span class="line">   INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">   PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">  L2</span><br><span class="line"></span><br><span class="line">   LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line">   ALOAD 0</span><br><span class="line"></span><br><span class="line">   ALOAD 0</span><br><span class="line"></span><br><span class="line">   GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">   INVOKEVIRTUAL java/lang/Integer.intValue (I)</span><br><span class="line"></span><br><span class="line">   PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line">   RETURN</span><br></pre></td></tr></table></figure>
<h3 id="浮点数运算的精度丢失">浮点数运算的精度丢失</h3>
<p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>解决：</p>
<p>使用BigDecimal</p>
<h2 id="变量">变量</h2>
<h3 id="成员变量与局部变量的区别">成员变量与局部变量的区别</h3>
<p><strong>语法：</strong></p>
<ul>
<li>成员变量：属于类、可被权限修饰符修饰</li>
<li>局部变量：代码块、方法区、方法参数等</li>
</ul>
<p><strong>存储方式：</strong></p>
<ul>
<li>成员变量：
<ul>
<li>使用static修饰：属于类</li>
<li>不使用：属于对象，在堆里存储</li>
</ul></li>
<li>局部变量：<strong>存在于栈内存</strong>。</li>
</ul>
<p><strong>生命周期：</strong></p>
<ul>
<li>成员变量：和对象的生存时间一致</li>
<li>局部变量：方法调用开始 -&gt; 结束、或者代码块执行结束</li>
</ul>
<p><strong>默认值：</strong></p>
<ul>
<li>成员变量：按默认值赋值</li>
<li>局部变量：必须手动赋值</li>
</ul>
<h2 id="方法">方法</h2>
<h3
id="静态方法为什么不能调用非静态成员">静态方法为什么不能调用非静态成员</h3>
<ol type="1">
<li>静态方法属于类，在类加载的时候就分配栈内存，可以用类名直接访问，但是非静态成员是对象的信息范畴，必须创建对象实例才能访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="重载和重写有什么区别">重载和重写有什么区别</h3>
<p>重载就是同样的一个方法能够根据输入输出数据类型的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要<strong>覆盖</strong>父类方法</p>
<h4 id="重载">重载</h4>
<p>发生在同一个类中（或者父类和子类之间），<strong>方法名必须相同</strong>，<strong>参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符</strong>可以不同。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">区别点</th>
<th style="text-align: left;">重载方法</th>
<th style="text-align: left;">重写方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">发生范围</td>
<td style="text-align: left;">同一个类</td>
<td style="text-align: left;">子类</td>
</tr>
<tr class="even">
<td style="text-align: left;">参数列表</td>
<td style="text-align: left;">必须修改</td>
<td style="text-align: left;">一定不能修改</td>
</tr>
<tr class="odd">
<td style="text-align: left;">返回类型</td>
<td style="text-align: left;">可修改</td>
<td
style="text-align: left;">子类方法返回值类型应比父类方法返回值类型更小或相等（子类）</td>
</tr>
<tr class="even">
<td style="text-align: left;">异常</td>
<td style="text-align: left;">可修改</td>
<td
style="text-align: left;">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr class="odd">
<td style="text-align: left;">访问修饰符</td>
<td style="text-align: left;">可修改</td>
<td
style="text-align: left;">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr class="even">
<td style="text-align: left;">发生阶段</td>
<td style="text-align: left;">编译期</td>
<td style="text-align: left;">运行期</td>
</tr>
</tbody>
</table>
<h3
id="深拷贝和浅拷贝区别什么是引用拷贝">深拷贝和浅拷贝区别，什么是引用拷贝？</h3>
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象<strong>内部的属性是引用类型</strong>的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象<strong>共用</strong>同一个内部对象。</p>
<p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<figure>
<img src="shallow&amp;deep-copy.png"
alt="浅拷贝、深拷贝、引用拷贝示意图" />
<figcaption
aria-hidden="true">浅拷贝、深拷贝、引用拷贝示意图</figcaption>
</figure>
<h2 id="object">Object</h2>
<h3 id="常见方法">常见方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="和-equals-的区别">== 和 equals() 的区别</h3>
<p>==：</p>
<ul>
<li>基本类型：比值</li>
<li>引用类型：<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>对于 ==
来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p>equals()：只能用来判断两个对象是否相等。</p>
<ul>
<li><strong>类没有重写
<code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是
<code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写
<code>equals()</code>方法来比较两个对象中的<strong>属性</strong>是否相等；若它们的属性相等，则返回
true(即，认为这两个对象相等)。</li>
</ul>
<h4 id="string的equals方法">String的equals()方法</h4>
<p>String类的equals()方法被重写过，会判断两个字符串的值是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashcode-方法">hashCode() 方法</h3>
<p>方法是本地方法，利用C / C++实现。</p>
<p>作用：为每个对象生成独特的编码，确定对象在哈希表中的索引，方便从哈希表中快速查找。</p>
<h4 id="hashcode存在的意义">hashCode存在的意义</h4>
<p>“<code>HashSet</code> 如何检查重复”</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code>
会先计算对象的 <code>hashCode</code>
值来判断对象加入的位置，同时也会与其他已经加入的对象的
<code>hashCode</code> 值作比较，如果没有相符的
<code>hashCode</code>，<code>HashSet</code>
会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code>
值的对象，这时会调用 <code>equals()</code> 方法来检查
<code>hashCode</code>
相等的对象是否真的相同。如果两者相同，<code>HashSet</code>
就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了
<code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>hashcode()其实也是用于判断两个对象是否相同，如果两个对象连哈希码都不相同，那就不用进行equals比较了。在一定程度上提高了集合审查元素的效率。</p>
<p><strong>为什么hashcode()过后还要equals比较？</strong></p>
<p>hashcode可能会发生哈希冲突，所以保险起见，满足这两个方法这两个对象就是相同的。</p>
<ul>
<li>hashcode() &amp;&amp; equals : 相同</li>
<li>!hashcode() ： 一定不相同。</li>
</ul>
<p>所以说，重写equals方法也必须重写hashcode方法，防止出现两个对象equal但是hashcode值不一样。</p>
<h2 id="string">String</h2>
<h3
id="stringstringbufferstringbuilder-的区别">String、StringBuffer、StringBuilder
的区别</h3>
<p>可变性：</p>
<ul>
<li>String不可变</li>
<li><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自
<code>AbstractStringBuilder</code> 类，在
<code>AbstractStringBuilder</code>
中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和
<code>private</code> 关键字修饰，最关键的是这个
<code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如
<code>append</code> 方法。</li>
</ul>
<p>线程安全性：</p>
<ul>
<li><p><code>String</code>
中的对象是不可变的，也就可以理解为常量，线程安全。</p></li>
<li><p><code>StringBuffer</code>
对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p></li>
<li><p><code>StringBuilder</code>
并没有对方法进行加同步锁，所以是非线程安全的。</p></li>
</ul>
<p>性能：</p>
<p>StringBuilder &gt; StringBuffer</p>
<ol type="1">
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用
<code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用
<code>StringBuffer</code></li>
</ol>
<h3 id="string-为什么是不可变的">String 为什么是不可变的</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>final修饰内部的char数组，即使这个char引用指针能变，但这个成员变量是私有的，不会暴露给外界。</li>
<li><code>String</code> 类被 <code>final</code>
修饰导致其不能被继承，进而避免了子类破坏 <code>String</code>
不可变。</li>
</ol>
<h3 id="字符串拼接用-还是-stringbuilder">字符串拼接用“+” 还是
StringBuilder</h3>
<p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String
类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20220422161637929.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>字符串对象通过“+”的字符串拼接方式，实际上是通过
<code>StringBuilder</code> 调用 <code>append()</code>
方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个
<code>String</code> 对象 。</p>
<h3 id="字符串常量池的作用">字符串常量池的作用</h3>
<p><strong>字符串常量池</strong> 是 JVM
为了提升性能和减少内存消耗针对字符串（String
类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h4 id="string-s1-new-stringabc这句话创建了几个字符串对象">String s1 =
new String("abc");这句话创建了几个字符串对象</h4>
<ol type="1">
<li>如果常量池没有"abc"这个字符串，会先创建"abc"实例，然后再创建s1引用对象</li>
<li>如果有，只创建s1引用对象</li>
</ol>
<h3 id="string的intern-方法有什么作用">String的intern
方法有什么作用</h3>
<p><code>String.intern()</code> 是一个
native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池</strong>中</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用，不同于s3，这是往常量池找</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="string-类型的变量和常量做运算时发生了什么">String
类型的变量和常量做“+”运算时发生了什么</h3>
<p>对于<strong>编译期可以确定值的字符串</strong>，也就是常量字符串（被写死的值）
，jvm 会将其存入字符串常量池。</p>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化——常量折叠。</p>
<p><strong>常量折叠：</strong></p>
<p>对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成
<code>String str3 = "string";</code> 。</p>
<p>引用类型的值无法在编译器确定，无法优化。</p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过
<code>StringBuilder</code> 调用 <code>append()</code>
方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个
<code>String</code> 对象 。</p>
<p>但是String引用类型被final修饰后，可以让编译器当成常量处理。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果
，编译器在运行时才能知道其确切值的话，就无法对其优化。下面就不行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常">异常</h2>
<p><strong>Java 异常类层次结构图</strong></p>
<figure>
<img src="image-20230802210612642.png" alt="image-20230802210612642" />
<figcaption aria-hidden="true">image-20230802210612642</figcaption>
</figure>
<h3 id="exception-和-error-有什么区别">Exception 和 Error
有什么区别</h3>
<ul>
<li><p>Exception：可catch捕获、可处理</p>
<ul>
<li><p>Checked Exception (受检查异常，必须处理)
：没被catch通不过编译。</p>
<ul>
<li>(除了运行时异常以外，都是受查异常)</li>
</ul></li>
<li><p>Unchecked Exception (不受检查异常，可以不处理)：</p>
<ul>
<li><p>常见的非受查异常：</p>
<ul>
<li><p><code>NullPointerException</code>(空指针错误)</p></li>
<li><p><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</p></li>
<li><p><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</p></li>
<li><p><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</p></li>
<li><p><code>ClassCastException</code>（类型转换错误）</p></li>
<li><p><code>ArithmeticException</code>（算术错误）</p></li>
<li><p><code>SecurityException</code> （安全错误比如权限不够）</p></li>
<li><p><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</p></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>error：不建议catch捕获，遇到线程终止处理。</p>
<ul>
<li>常见：OOM、SOF</li>
</ul></li>
</ul>
<h3 id="throwable-类常用方法有哪些">Throwable 类常用方法有哪些</h3>
<ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>:
返回异常对象的本地化信息。使用 <code>Throwable</code>
的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与
<code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印
<code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally-使用">try-catch-finally 使用</h3>
<ul>
<li><code>try</code>块：用于捕获异常。其后可接零个或多个
<code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个
<code>finally</code> 块。</li>
<li><code>catch</code>块：用于处理 try 捕获到的异常。</li>
<li><code>finally</code>
块：无论是否捕获或处理异常，<code>finally</code>
块里的语句<strong>都会被执行</strong>。
<ul>
<li>当在 <code>try</code> 块或 <code>catch</code> 块中遇到
<code>return</code> 语句时，<code>finally</code>
语句块将在方法返回之前被执行。</li>
<li><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try
语句和 finally 语句中都有 return 语句时，try 语句块中的 return
语句会被忽略。这是因为 try 语句中的 return
返回值会先被暂存在一个<strong>本地变量</strong>中，当执行到 finally
语句中的 return 之后，会覆盖掉try块里的return返回值。</li>
</ul></li>
</ul>
<h3 id="finally-中的代码是否一定会执行">finally
中的代码是否一定会执行</h3>
<p>基本上都是外界环境出问题所导致的：</p>
<ol type="1">
<li>finally 之前虚拟机被终止运行的话，finally
中的代码就不会被执行。</li>
<li>程序所在的线程死亡。</li>
<li>CPU关闭</li>
</ol>
<h3 id="使用-try-with-resources-代替try-catch-finally">使用
<code>try-with-resources</code> 代替<code>try-catch-finally</code></h3>
<ul>
<li><strong>适用范围（资源的定义）：</strong> 任何实现
<code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code>
的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在
<code>try-with-resources</code> 语句中，任何 catch 或 finally
块在声明的资源关闭后运行。</li>
</ul>
<p>类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Java 7 之后的 <code>try-with-resources</code>
语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个资源需要关闭的时候，使用 <code>try-with-resources</code>
实现，通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="异常使用有哪些需要注意的地方">异常使用有哪些需要注意的地方？</h3>
<ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动
new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>
</ul>
<h2 id="泛型">泛型</h2>
<h3 id="泛型的使用方式">泛型的使用方式</h3>
<h4 id="泛型类">泛型类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型接口">泛型接口</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法">泛型方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line"> &#123;</span><br><span class="line">       <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">          System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:
<code>public static &lt; E &gt; void printArray( E[] inputArray )</code>
一般被称为静态泛型方法;在 java
中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的
<code>&lt;E&gt;</code></p>
</blockquote>
<h3 id="项目中哪里用到了泛型">项目中哪里用到了泛型</h3>
<ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数
<code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code>
用于动态指定 <code>Excel</code> 导出的数据类型</li>
<li>构建集合工具类（参考 <code>Collections</code> 中的
<code>sort</code>, <code>binarySearch</code> 方法）。</li>
</ul>
<h2 id="反射">反射</h2>
<h3 id="获取-class-对象的四种方式">获取 Class 对象的四种方式</h3>
<p>利用class类对象，将一个类的方法、变量信息提取出来。</p>
<ol type="1">
<li><p>知道具体类情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过
<code>Class.forName()</code>传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="反射基本操作">反射基本操作</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> &#123;</span><br><span class="line">           value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">   <span class="type">TargetObject</span> <span class="variable">targetObject</span> <span class="operator">=</span> (TargetObject) targetClass.newInstance();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取 TargetObject 类中定义的所有方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">       System.out.println(method.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">           String.class);</span><br><span class="line"></span><br><span class="line">   publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> targetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">   <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">   field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用 private 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">   <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">   privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   privateMethod.invoke(targetObject);</span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="注解">注解</h2>
<p><code>Annotation</code> （注解） 是 Java5
开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<ol type="1">
<li><p>定义一个<code>@interface</code>
，必须要用@Retention注解标识；可以在接口内定义要穿的参数</p></li>
<li><p>进行属性定义</p>
<p>定义方式<code>RetentionPolicy value();</code></p></li>
</ol>
<p>属性是由注解处理器类库(<code>java.lang.reflect.AnnotatedElement</code>)发现并处理：</p>
<ul>
<li><code>AnnotatedElement</code>
接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的<code>AnnotatedElement</code>对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</li>
</ul>
<p>注解处理基础方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1：&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</span><br><span class="line">　　方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</span><br><span class="line">　　方法3：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</span><br><span class="line">　　方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</span><br></pre></td></tr></table></figure>
<h3 id="注解的解析方法有哪几种">注解的解析方法有哪几种</h3>
<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java
代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code>
注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring
框架的
<code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h3 id="spi">SPI</h3>
<p>SPI 即 Service Provider Interface
，字面意思就是：“服务提供者的接口”。我的理解是：自己能做的东西，做明白的东西外包</p>
<p>与API的区别：</p>
<figure>
<img src="1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="序列化和反序列化">序列化和反序列化</h2>
<ul>
<li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>数据传输、远程调用：对象在进行网络传输（比如远程方法调用 RPC
的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>持久化：将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>缓存：将对象存储到数据库（如
Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<p>序列化属于OSI七层模型的应用层。</p>
<p><strong>对某些字段不进行序列化：</strong></p>
<p>使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code>
关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被
<code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code>
修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰
<code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有
<code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="过程">过程</h3>
<p><code>serialVersionUID</code>：</p>
<ul>
<li><p>序列化期间，针对可序列化的类，它们会有唯一版本号与之相关联。</p></li>
<li><p>反序列化期间，用于验证序列化对象的发送者和接收者为这个对象加载了兼容序列化的类（这个类继承了序列化接口、同一类的对象）。接收者为对象加载的类的<code>serialVersionUID</code>与发送者的不相同，就会报异常：<code>InvalidClassException</code></p></li>
<li><p>但是在序列化中，发送者和接收者不是同一个人，即，这些人可能不同，机器或系统可能不同，并且位置必须不同。在序列化中，发送方和接收方都应仅在开始时具有.class文件，即，要进行序列化的人和准备反序列化的人仅应在开始时包含相同的.class文件。</p></li>
<li><p>序列化时，针对每个对象，<strong>发送方JVM</strong>都会保存一个Unique
Identifier。JVM负责根据发送方系统中存在的相应.class文件生成该唯一ID。</p></li>
<li><p>反序列化时，接收方JVM将与对象关联的唯一ID与本地类Unique
ID进行比较，即JVM还将基于接收方系统中存在的相应.class文件创建唯一ID。如果两个唯一的ID都匹配，则将仅执行反序列化。否则，我们将获得Runtime
Exception，提示InvalidClassException。这个唯一的标识符不过是SerialVersionUID。</p></li>
</ul>
<h2 id="语法糖">语法糖</h2>
<p>方便程序员开发程序而设计的一种特殊语法——语法糖。</p>
<p>主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for
循环、try-with-resources 语法、lambda 表达式等。</p>
<p>JVM 其实并不能识别语法糖，Java
语法糖要想被正确执行，需要先通过编译器进行<strong>解糖</strong>，编译阶段变成可识别的语法。</p>
<h2 id="比较器">比较器</h2>
<h3 id="comparator">Comparator</h3>
<p>比较器接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/*	</span></span><br><span class="line"><span class="comment">    	1：前面的数 &gt; 后面的数，是降序（从大到小）的，如果想要改为升序排列，就需要返回 1；</span></span><br><span class="line"><span class="comment">    	-1：前面的数 &lt; 后面的数，是升序（从小到大）的，不改变位置就返回 -1；</span></span><br><span class="line"><span class="comment">        0：二者相等，不进行交换，也就不排序。但是要根据题目来判断返回什么。如果数组是无序的，不能直接返回0。</span></span><br><span class="line"><span class="comment">        若保证升序排列，要返回o1 - o2，降序则 o2 - o1。（ o1值的是集合中的第一个对象，o2是第二个对象）</span></span><br><span class="line"><span class="comment">        return 0:不交换位置，不排序</span></span><br><span class="line"><span class="comment">        return 1:交换位置</span></span><br><span class="line"><span class="comment">        return -1:不交换位置</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="排序一维数组">排序一维数组</h4>
<p>基础类型：</p>
<p><img src="java面试整理/image-20231228211852265.png" alt="image-20231228211852265" style="zoom:80%;" /></p>
<p>包装类型：</p>
<p>用匿名内部类，也是直接采用运算符</p>
<figure>
<img src="java面试整理/image-20231228212218170.png"
alt="image-20231228212218170" />
<figcaption aria-hidden="true">image-20231228212218170</figcaption>
</figure>
<h4 id="排序二维数组">排序二维数组</h4>
<figure>
<img src="java面试整理/image-20231228212308065.png"
alt="image-20231228212308065" />
<figcaption aria-hidden="true">image-20231228212308065</figcaption>
</figure>
<figure>
<img src="java面试整理/image-20231228212320805.png"
alt="image-20231228212320805" />
<figcaption aria-hidden="true">image-20231228212320805</figcaption>
</figure>
<h4 id="排序对象数组">排序对象数组</h4>
<p>必须按照对象中的某一具体数值属性排序。</p>
<p>创建Student学生实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">	<span class="comment">// setXXX/getXXX，构造方法，toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="java面试整理/image-20231228212620251.png"
alt="image-20231228212620251" />
<figcaption aria-hidden="true">image-20231228212620251</figcaption>
</figure>
<h3 id="comparable">Comparable</h3>
<p>也是一个接口，用于定义类的时候实现接口，重写compareTo方法，对特定的对象进行排序字段设置。</p>
<figure>
<img src="java面试整理/image-20231228213231720.png"
alt="image-20231228213231720" />
<figcaption aria-hidden="true">image-20231228213231720</figcaption>
</figure>
<h2 id="本地方法">本地方法</h2>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/wi__wi/article/details/51085907#:~:text=JAVA中有两种方法：JAVA方法和本地方法.%20JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中.%20本地方法是由其它语言编写的，编译成和处理器相关的机器代码.%20本地方法保存在动态链接库中，即.dll%20(windows系统)文件中，格式是各个平台专有的.%20JAVA方法是与平台无关的，但是本地方法不是。.,http%3A%2F%2Fblog.sina.com.cn%2Fs%2Fblog_5b9b4abe01016zw0.html.%20一.%20什么是Native%20Method.%20简单地讲，一个Native%20Method就是一个java调用非java代码的接口。.">JAVA本地方法详解，什么是JAVA本地方法？-CSDN博客</a></p>
<p>一个Native
Method就是<strong>一个java调用非java代码</strong>的接口。</p>
<h1 id="集合">集合</h1>
<p>集合框架族：</p>
<figure>
<img src="java-collection-hierarchy.png" alt="Java 集合框架概览" />
<figcaption aria-hidden="true">Java 集合框架概览</figcaption>
</figure>
<h2 id="list">List</h2>
<h3 id="arraylist">ArrayList</h3>
<h4 id="特性">特性</h4>
<ul>
<li>arrayList基于动态数组
<ul>
<li>创建不用指定大小</li>
<li>动态扩容</li>
</ul></li>
<li>arrayList有丰富API</li>
<li>arrayList只能存储对象类型，不能存储基础类型。</li>
<li>arrayList可以存储空值。</li>
</ul>
<h4 id="各类操作的效率">各类操作的效率</h4>
<p>插入：</p>
<ul>
<li>头插：后面元素需要往后移动，复杂度O(n)</li>
<li>尾插：O(1)</li>
<li>中间插：随机位置的话，O(n/2) -&gt; O(n)</li>
<li>扩容：O(n)</li>
</ul>
<p>删除：</p>
<ul>
<li>头删：涉及移动元素，后面的元素移动到前面。O(n)</li>
<li>尾删：O(1)</li>
<li>中间删：O(n/2) -&gt; O(n)</li>
</ul>
<h4 id="集合计算api">集合计算API</h4>
<h5 id="交集">交集</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arraylist1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; arraylist2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arraylist1.add(<span class="number">1</span>);arraylist1.add(<span class="number">2</span>);arraylist1.add(<span class="number">3</span>);</span><br><span class="line">arraylist2.add(<span class="number">3</span>);arraylist2.add(<span class="number">4</span>);</span><br><span class="line">arraylist1.retainAll(arraylist2);<span class="comment">//求交集，这时候arraylist1已经修改过了，无需写成arraylist1=arraylist1.retainAll(arraylist2);</span></span><br></pre></td></tr></table></figure>
<h5 id="并集">并集</h5>
<p>没有封装好的API，使用合并去重方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个整数集求并集</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">integerArrayListUnion</span><span class="params">(</span></span><br><span class="line"><span class="params">    ArrayList&lt;Integer&gt; arraylist1, ArrayList&lt;Integer&gt; arraylist2)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    arraylist.addAll(arraylist1);</span><br><span class="line">    arraylist.addAll(arraylist2);</span><br><span class="line">    arraylist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;(arraylist));</span><br><span class="line">    <span class="keyword">return</span> arraylist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="补集">补集</h5>
<p>补集的概念：<strong>设S是一个集合,A是S的一个子集,由S中所有不属于A的元素组成的集合，叫做A对于S的补集</strong>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arraylist1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; arraylist2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arraylist1.add(<span class="number">1</span>);arraylist1.add(<span class="number">2</span>);arraylist1.add(<span class="number">3</span>);</span><br><span class="line">arraylist2.add(<span class="number">3</span>);</span><br><span class="line">arraylist1.removeAll(arraylist2);</span><br><span class="line">System.out.println(<span class="string">&quot;┐Arraylist2（对于Arraylist1）=&quot;</span>+arraylist1);<span class="comment">//由于1集合包含2集合，求2的补集有意义。</span></span><br></pre></td></tr></table></figure>
<h4 id="部分源码分析">部分源码分析</h4>
<p>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>List&lt;E&gt;</code>：</li>
<li><code>RandomAccess</code>：标志接口，支持快速随机访问</li>
<li><code>Cloneable</code>：可进行深拷贝、浅拷贝</li>
<li><code>Serializable</code></li>
</ul>
<p>类图：</p>
<figure>
<img src="arraylist-class-diagram.png" alt="ArrayList 类图" />
<figcaption aria-hidden="true">ArrayList 类图</figcaption>
</figure>
<h5 id="扩容机制">扩容机制</h5>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果创建的时候未指定大小，默认给一个空数组不占空间，然后真正用到的时候，比如添加第一个元素，会扩容到10</li>
</ul>
<p>add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>ensureCapacityInternal()</code>方法，获取最小需求量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>判断是否需要扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>添加第一个元素，开始创建大小为10的数组</li>
<li>添加元素到第10个</li>
<li>add第11个元素，先执行<code>ensureCapacityInternal()</code>方法，，得知最小需求量已经为11，然后调用<code>ensureExplicitCapacity</code>方法判断是否需要扩容，发现11
&gt; 原本的数量10，所以需要扩容。</li>
</ul>
<p>实际扩容方法<code>grow()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">     <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">     <span class="comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">         newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if
判断成立，newCapacity = minCapacity(为 10)。但是第二个 if
判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入
<code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return
true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比
minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大
size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return
true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><code>hugeCapacity()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linkedlist">LinkedList</h3>
<h4 id="特性-1">特性</h4>
<ul>
<li>底层双向链表。</li>
<li>每个元素存储额外的字段占用空间</li>
<li>头尾插入删除效率很高</li>
</ul>
<h4 id="各类操作的效率-1">各类操作的效率</h4>
<ul>
<li>头插头删、尾插尾删：O(1)</li>
<li>指定位置插入：O(n/2) -&gt; O(n)</li>
</ul>
<h3 id="linkedlist与arraylist区别">LinkedList与ArrayList区别</h3>
<p><strong>线程安全</strong></p>
<p>两者都不安全。</p>
<p><strong>内存</strong></p>
<ul>
<li>ArrayList空间浪费在扩容后预留的空间。</li>
<li>LinkedList空间浪费在每个结点的额外存储指针所占有的空间</li>
</ul>
<p><strong>快速随机访问</strong></p>
<p>快速随机访问就是通过元素的序号快速获取元素对象，如<code>get(int index)</code>方法</p>
<ul>
<li>LinkedList底层不是数组，不支持根据索引快速查找，所以随机访问的性能不高</li>
<li>ArrayList支持。</li>
</ul>
<p><strong>插入删除的位置是否受容器内部元素位置的影响</strong></p>
<ul>
<li>ArrayList：尾插无所谓，但是其它情况都是O(N)</li>
<li>LinkedList：头尾插都无所谓，中间插O(N)</li>
</ul>
<p><strong>底层数据结构</strong></p>
<p><code>ArrayList</code> 底层使用的是 <strong><code>Object</code>
数组</strong>；</p>
<p><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong>
数据结构</p>
<h2 id="queue">Queue</h2>
<p><code>Queue</code>
是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循
<strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据
<strong>因为容量问题而导致操作失败后处理方式的不同</strong>
可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr class="header">
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr class="even">
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr class="odd">
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口,
增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr class="header">
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr class="even">
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr class="odd">
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr class="even">
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr class="odd">
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr class="even">
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
<p><code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code>
等其他方法，可用于模拟栈.</p>
<h4 id="arraydeque-与-linkedlist-的区别">ArrayDeque 与 LinkedList
的区别</h4>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而
<code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但
<code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6
才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程,
不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code>
不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>arrayDeque性能高一点。</p>
<h2 id="hashmap">Hash&amp;Map</h2>
<h3 id="hashmap-和-hashtable-的区别">HashMap 和 Hashtable 的区别</h3>
<p><strong>线程安全：</strong></p>
<ul>
<li>hashmap线程不安全</li>
<li>hashtable整个表加锁</li>
</ul>
<p><strong>效率</strong>：</p>
<ul>
<li>hashmap正常</li>
<li>hashtable阳慢，建议不用</li>
</ul>
<p><strong>null key的支持：</strong></p>
<ul>
<li>hashmap支持单个null key，值的null可以有多个</li>
<li>hashtable不支持</li>
</ul>
<p><strong>默认容量、扩容：</strong></p>
<ul>
<li>hashmap默认容量：16 hashtable默认容量：11</li>
<li>给定容量：hashmap将给定的容量转化为最近的2的n次方幂，hashtable直接用。</li>
<li>hashmap达到负载因子扩容为原来的二倍，hashtable扩容为2n+1</li>
</ul>
<p>底层数据结构：</p>
<ul>
<li>hashmap：数组、链表|红黑树</li>
<li>hashtable：数组</li>
</ul>
<h3 id="hashmap-的长度为什么是-2-的幂次方">HashMap 的长度为什么是 2
的幂次方</h3>
<p>1、便于位运算计算</p>
<p>假设hashmap的长度是n，假设元素的hash值已经计算就是hash。</p>
<p>如果要确定数据要存放的具体位置，通过
<code>hash % n</code>这个公式计算。但是二进制计算的效率要比%效率高得多，那么把这个公式转换一下，就是
<code>hash &amp; (n - 1)</code>。</p>
<p>但是有个大前提：<strong>数组长度必须是2的n次方。</strong>所以...</p>
<p>2、使数据均匀分布，减少哈希冲突</p>
<p>假设空间大小是15，减1是14，二进制位对应：1110。</p>
<p>假如这时候有一个对象，哈希值的二进制中，最后一位无论是啥，与1110
进行与运算得到的结果，最后一位永远是0，这样hash表中就会一直有一个数组的索引数字计算不到，那就会浪费空间，而且会提高哈希冲突的概率。</p>
<h3 id="树化阈值为什么是8">树化阈值为什么是8</h3>
<ol type="1">
<li>尽量少转化为红黑树，因为红黑树耗内存资源。转化过程中也影响程序性能。</li>
<li>转换成树是为了提高查找性能，链表的时间复杂度是O(n)，树的时间复杂度是O(logn)
，当阈值是8的时候，logn计算的结果是3，对于O(n)的链表来说，平均查找次数是4，这相当于一个分界点。
&lt;8 链表查询效率高， &gt; 8就是红黑树查询效率高了。</li>
</ol>
<h3 id="为什么负载因子是0.75">为什么负载因子是0.75</h3>
<p>源码解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant <span class="title function_">use</span></span><br><span class="line"><span class="params">(see TREEIFY_THRESHOLD)</span>. And when they become too <span class="title function_">small</span> <span class="params">(due to</span></span><br><span class="line"><span class="params">removal or resizing)</span> they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes in bins follows a Poisson <span class="title function_">distribution</span></span><br><span class="line"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a</span><br><span class="line">parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span><br><span class="line">threshold of <span class="number">0.75</span>, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k <span class="title function_">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * pow(<span class="number">0.5</span>, k) /</span><br><span class="line">factorial(k)). The first values are:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure>
<p>首先，得出0.75这个值，是通过数学统计的方式得出，这个方式叫做<strong>泊松分布</strong>。</p>
<p>判断的依据是，根据不同的负载因子，得出，在hash冲突的情况下，链表结点的个数，服从这个分布；</p>
<p>使用0.75作为负载因子，在hash分布均匀的情况下，其每个桶链表结点的个数能超过8的概率，不及千万分之一，因此这是最佳实践产生的结果。</p>
<h3 id="hashmap-和-hashset-区别">HashMap 和 HashSet 区别</h3>
<p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><code>HashMap</code></th>
<th style="text-align: center;"><code>HashSet</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">实现了 <code>Map</code> 接口</td>
<td style="text-align: center;">实现 <code>Set</code> 接口</td>
</tr>
<tr class="even">
<td style="text-align: center;">存储键值对</td>
<td style="text-align: center;">仅存储对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">调用 <code>put()</code>向 map
中添加元素</td>
<td style="text-align: center;">调用 <code>add()</code>方法向
<code>Set</code> 中添加元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>HashMap</code> 使用键（Key）计算
<code>hashcode</code></td>
<td style="text-align: center;"><code>HashSet</code> 使用成员对象来计算
<code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code>
可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
<h3 id="hashset-如何检查重复">HashSet 如何检查重复</h3>
<p>添加对象的时候，hashset先计算对象的hashcode，通过hashcode判断对象要添加的位置在哪里，假如这个位置有空，添加进去，否则添加失败。（hashcode
+ equals）</p>
<p>add源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="treemap-相比于hashmap特性">TreeMap 相比于HashMap特性</h3>
<figure>
<img src="treemap_hierarchy.png" alt="TreeMap 继承关系图" />
<figcaption aria-hidden="true">TreeMap 继承关系图</figcaption>
</figure>
<p>实现 <code>NavigableMap</code> 接口有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code>
有了对集合中的元素<strong>根据键排序</strong>的能力</p>
<h3 id="hashmap-常见的遍历方式">HashMap 常见的遍历方式</h3>
<ol type="1">
<li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用迭代器（Iterator）KeySet 的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 For Each EntrySet 的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 For Each KeySet 的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Lambda 表达式的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.foreach((key,value) -&gt; &#123;</span><br><span class="line">	System.out.println(key);</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Streams API 单线程的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Streams API 多线程的方式进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="hashmap如何解决哈希冲突">hashmap如何解决哈希冲突</h3>
<h4 id="hash算法">hash算法</h4>
<p>概念：把任意长度的输入通过散列算法，变成固定长度的输出，这个输出结果就是一个散列值。</p>
<p>Hash冲突是由于哈希算法，被计算的数据是无限的，而计算后的结果的范围是有限的，总会存在不同的数据，经过计算之后得到值是一样，那么这个情况下就会出现所谓的哈希冲突</p>
<h4 id="解决hash冲突的方法">解决hash冲突的方法</h4>
<h5 id="开放定址法">开放定址法</h5>
<p>从发生冲突的那个位置开始，按照一定次序从Hash表找到一个空闲位置然后把发生冲突的元素存入到这个位置，而在java中，ThreadLocal就用到了线性探测法来解决Hash冲突</p>
<h6 id="删除元素过程">删除元素过程</h6>
<p>并不是真正的删除（把结点置为空），而是把这个元素标记，等下次有元素进来的时候取代他，才真正删除。</p>
<p>原因：线性探测法，在搜寻过程中遇到null直接返回。同时，如果删掉中间某一结点，后续的结点还要更改位置，比较麻烦</p>
<h5 id="链式寻址法拉链法">链式寻址法（拉链法）</h5>
<p>这是一种常见的方法，简单理解就是把存在Hash冲突的key，以单向链表来进行存储，比如HashMap</p>
<p><img src="image-20231109164653472.png" alt="image-20231109164653472" style="zoom:67%;" /></p>
<ol type="1">
<li>再hash</li>
<li>建立公共移除区</li>
</ol>
<h3 id="hashmap底层源码实现">HashMap底层源码实现</h3>
<p>数据结构：</p>
<ul>
<li>1.8之前是数组+链表</li>
<li>1.8之后是数组+链表|红黑树
<ul>
<li>树化：</li>
<li>退化：</li>
<li>树化阈值：</li>
<li>扩容</li>
</ul></li>
</ul>
<p>扰动函数：哈希表为了减少冲突所定义的一种函数。</p>
<p>hashcode()是每个对象都有的获取本身独一无二标识码的一种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法">构造方法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     </span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>putMapEntries方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 未初始化，s为m的实际元素个数，ft=s/loadFactor =&gt; s=ft*loadFactor, 跟我们前面提到的</span></span><br><span class="line"><span class="comment">             * 阈值=容量*负载因子 是不是很像，是的，ft指的是要添加s个元素所需的最小的容量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所</span></span><br><span class="line"><span class="comment">             * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。</span></span><br><span class="line"><span class="comment">             * 注意这里不是初始化阈值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="put方法">put方法</h4>
<p><img src="put.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="get方法">get方法</h4>
<p>大致流程：</p>
<ol type="1">
<li>根据key，调用hash方法算出hash码，然后通过哈希码hash调用内部方法getNode。</li>
<li>通过哈希码算出这个元素应在的位置，去这个位置寻找。</li>
<li>假如这个位置的第一个结点和要找的结点不一致：
<ol type="1">
<li>可能在链表结点中</li>
<li>可能在树节点中</li>
</ol></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="resize扩容">resize扩容</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span></span><br><span class="line">    	<span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 只有一个节点，直接计算元素新的位置即可</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span></span><br><span class="line">                    <span class="comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="set">Set</h2>
<h3 id="hashset与treeset区别">HashSet与TreeSet区别</h3>
<p><strong>内部实现</strong></p>
<ul>
<li>HashSet 内部使用哈希表来存储元素，因此它的查找、插入和删除操作的<a
target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=时间复杂度&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3049364903%7D">时间复杂度</a>都是
O(1)。</li>
<li>而 TreeSet 内部使用的是红黑树，因此它的时间复杂度为 O(log n)。</li>
</ul>
<p><strong>元素顺序</strong></p>
<ul>
<li>HashSet
不保证元素的顺序，因为它是根据哈希值来存储和检索元素的。</li>
<li>而 TreeSet
则可以保证元素的顺序，因为它是根据元素的自然顺序或者比较器来进行排序的。</li>
</ul>
<p><strong>接口</strong> HashSet 实现了 Set 接口，而 TreeSet 实现了
SortedSet 接口。</p>
<p><strong>使用场景</strong>
如果需要快速地插入、删除和查找元素，并且不关心它们的顺序，那么可以使用
HashSet。如果需要对元素进行排序，并且需要保证它们的顺序，那么可以使用
TreeSet。</p>
<p><strong>hash</strong></p>
<ul>
<li>hashSet要求放入的对象实现hashcode方法</li>
</ul>
<h1 id="并发编程">并发编程</h1>
<h2 id="基础概念">基础概念</h2>
<h3 id="进程">进程</h3>
<p>系统运行程序的基本单位。针对一个个的应用程序。</p>
<p>java应用程序进程：main()函数为入口，启动main函数就是启动了一个jvm进程。</p>
<h3 id="线程">线程</h3>
<p>粒度：比进程小，进程包含多个线程。</p>
<p>资源共享：共享进程的堆、方法区信息。每个线程有独立的程序计数器、虚拟机栈、本地方法栈。</p>
<h3 id="程序计数器为什么线程私有">程序计数器为什么线程私有</h3>
<p>一串代码可能交由多个线程去执行，然后单个CPU在运行多个线程的时候，是以时间片轮转调度来执行的，所以会有不间断的线程上下文的切换，那么每个线程必须要记录自己的代码执行到哪一行了，不然下次上下文切换到自己，自己不知道代码运行到哪就尴尬了。</p>
<p>主要就是为了：<strong>线程切换后能能恢复到正确的执行位置。</strong></p>
<h3
id="虚拟机栈和本地方法栈为什么是私有的">虚拟机栈和本地方法栈为什么是私有的</h3>
<p><strong>虚拟机栈：</strong> 每个 Java
方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在
Java 虚拟机栈中入栈和出栈的过程。</p>
<p><strong>本地方法栈：</strong>
和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行
Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native
方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>保证方法中的局部变量不会被其它执行的线程所影响。</p>
<h3 id="并发和并行">并发和并行</h3>
<p>并发：多个作业在同一时间段工作。单CPU运行多线程。</p>
<p>并行：多个作业在同一时刻工作。例如：多CPU运行多线程</p>
<h3 id="同步和异步">同步和异步</h3>
<p><strong>同步</strong>：发出一个调用之后，在没有得到结果之前，
该调用就不可以返回，一直等待。</p>
<p><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</p>
<ul>
<li>提高系统响应能力的手段</li>
</ul>
<h3 id="线程的生命周期和状态">线程的生命周期和状态</h3>
<p>在java中，线程有如下6个状态：</p>
<ul>
<li>new：初始状态</li>
<li>runnable：运行态</li>
<li>waiting：等待状态</li>
<li>time_waiting：超时等待
<ul>
<li>等待一段时间后，自动唤醒</li>
</ul></li>
<li>blocking：阻塞状态
<ul>
<li>线程在没有锁的情况下，争抢被加锁的资源</li>
</ul></li>
<li>terminated：终止状态</li>
</ul>
<figure>
<img src="640-1692712751157-1.png" alt="Java 线程状态变迁图" />
<figcaption aria-hidden="true">Java 线程状态变迁图</figcaption>
</figure>
<h4 id="java中线程状态与操作系统对比">java中线程状态与操作系统对比</h4>
<p>操作系统包含：</p>
<ul>
<li>ready：就绪态</li>
<li>running：运行态</li>
</ul>
<p>java仅有runnable态，原因：</p>
<p>现如今的时分系统，时间片精确到10~20ms，切换很快，没必要为每个线程再多拓展这两个状态，直接用runnable即可。</p>
<h3 id="线程的上下文切换">线程的上下文切换</h3>
<p>保留当前线程的上下文信息，留到下次切换该线程时做准备，并加载下一个要执行的线程的上下文信息。</p>
<h3 id="死锁">死锁</h3>
<p>定义：多个线程同时阻塞，都在等待某个资源被释放。线程被无限期终止，程序不可能停止。</p>
<figure>
<img src="2019-4死锁1.png" alt="线程死锁示意图" />
<figcaption aria-hidden="true">线程死锁示意图</figcaption>
</figure>
<p>模拟死锁代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死锁的四大条件：</p>
<ol type="1">
<li>互斥：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持：线程请求其他资源阻塞的时候，会持有当前的资源不放</li>
<li>不剥夺：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="避免死锁预防死锁">避免死锁、预防死锁</h4>
<p>预防：</p>
<ol type="1">
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠<strong>按序申请资源</strong>来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p>避免死锁：</p>
<p>资源分配的时候，对资源分配进行计算评估（银行家算法），使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong>
指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称
<code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<p>修改线程2的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<h3 id="sleep方法与wait方法">sleep()方法与wait()方法</h3>
<p>两者都会暂停线程的运行，但是有很大区别：</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 30%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;">sleep</th>
<th style="text-align: center;">wait</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">是否会释放锁</td>
<td style="text-align: center;">否</td>
<td style="text-align: center;">是</td>
</tr>
<tr class="even">
<td style="text-align: left;">方法类型</td>
<td style="text-align: center;"><code>Thread</code>
类的静态本地方法</td>
<td style="text-align: center;"><code>Object</code> 类的本地方法</td>
</tr>
<tr class="odd">
<td style="text-align: left;">休眠后，如何唤醒</td>
<td style="text-align: center;">自动唤醒</td>
<td style="text-align: center;">botify()唤醒，或者使用wart(long
timeout)</td>
</tr>
<tr class="even">
<td style="text-align: left;">用途</td>
<td style="text-align: center;">线程休眠</td>
<td style="text-align: center;">线程间交互通信</td>
</tr>
</tbody>
</table>
<h4 id="为什么wait是object方法">为什么wait是object方法：</h4>
<p>wait是想让线程释放某个对象锁，从而进入阻塞等锁状态，那我们操作目标应该是对象，而非线程本身。</p>
<h2 id="jmmjava-内存模型详解">JMM（Java 内存模型）详解</h2>
<h3 id="cpu缓存">CPU缓存</h3>
<p><strong>缓存：</strong>解决某两个或两个以上系统之间速度不匹配的问题。</p>
<ul>
<li><strong>CPU 缓存则是为了解决 CPU
处理速度和内存处理速度不对等的问题。</strong></li>
<li><strong>内存就是外存的告诉缓存。</strong></li>
</ul>
<p>多核CPU下的缓存图：</p>
<figure>
<img src="cpu-cache-protocol.png" alt="缓存一致性协议" />
<figcaption aria-hidden="true">缓存一致性协议</figcaption>
</figure>
<p>CPU cache的工作方式：先复制一份数据到 CPU
cache中，然后需要时去里面取，进行运算，运算结束再写回到 Main
Memory中。</p>
<p>但是会出现缓存不一致的问题。</p>
<p><strong>缓存不一致</strong>:通过协议规范解决</p>
<h3 id="指令重排序">指令重排序</h3>
<p>定义：系统在执行代码的过程中，会更改一些语句间的执行顺序（不会按照你写的顺序来），前提是保证语义正确的情况下。</p>
<ul>
<li><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>
，所以在多线程下，指令重排序可能会导致一些问题。</li>
</ul>
<p>种类：</p>
<ul>
<li>编译器优化重排：JVM、JIT等，</li>
<li>指令并行重排：指令级并行技术(Instruction-Level
Parallelism，ILP)来将多条指令重叠执行</li>
</ul>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt;
内存系统重排</strong>，最后变成操作系统可执行的指令序列。</p>
<h3 id="jmm">JMM</h3>
<h4 id="jmm出现的意义">JMM出现的意义</h4>
<ol type="1">
<li>java跨平台，那就要有自己的一套内存模型。因为不同的操作系统之间的内存结构都不一样。</li>
<li>java定义的一组并发编程的规范，里面有许多规范原则，简化了并发编程的开发。</li>
</ol>
<h4 id="jmm-如何抽象线程和主内存之间的关系">JMM
如何抽象线程和主内存之间的关系</h4>
<p>类似CPU缓存。</p>
<figure>
<img src="jmm.png" alt="JMM(Java 内存模型)" />
<figcaption aria-hidden="true">JMM(Java 内存模型)</figcaption>
</figure>
<p>把变量从主存中拷贝到自己的本地内存中，称为共享变量副本。</p>
<p>并发问题：当一个线程正在修改这个副本，还没有往主存中同步，但是另一个线程要取这个变量，但是它看到的变量还是自己刚刚拷贝的旧副本。</p>
<p><strong>主内存：</strong>所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</p>
<p><strong>本地内存：</strong>每个线程都有一个私有的本地内存来存储共享变量的<strong>副本</strong>，</p>
<ul>
<li>隔离性：每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。</li>
</ul>
<p>线程间的通信步骤：</p>
<ol type="1">
<li>线程 1
把本地内存中修改过的共享变量副本的值<strong>同步</strong>到主内存中去。</li>
<li>线程 2 到主存中读取对应的共享变量的值。</li>
</ol>
<p><strong>主内存与工作内存（线程间私有内存）之间的通信协议</strong>：</p>
<p>同步操作：</p>
<ul>
<li><strong>锁定（lock）</strong>:
作用于主内存中的变量，将他标记为一个线程独享变量。</li>
<li><strong>解锁（unlock）</strong>:
作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的
load 动作使用。</li>
<li><strong>load(载入)</strong>：把 read
操作从主内存中得到的变量值放入工作内存的变量的副本中。</li>
<li><strong>use(使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的
write 操作使用。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把 store
操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>规则：</p>
<ul>
<li>不允许一个线程无原因地（没有发生过任何 assign
操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中
“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或
assign）的变量，换句话说就是对一个变量实施 use 和 store
操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock
操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的
unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock
操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行
load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock
操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
</ul>
<h4 id="设计思想">设计思想</h4>
<figure>
<img src="image-20220731155332375.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="happens-before-原则">happens-before 原则</h3>
<p>第一个逻辑时钟算法。</p>
<p>作用： happens-before
原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p>
<p>设计思想：</p>
<ul>
<li>对于编译器、处理器的约束尽可能少，只要不改变程序执行结果，随便指令怎么排序都行</li>
<li>拒绝一切影响程序运行结果的指令重排序。</li>
</ul>
<p>运用：</p>
<p>1 happens-before 2</p>
<ul>
<li>表层含义：1的操作要在2的操作前执行。</li>
<li>实际深层含义：1的操作要对2的操作是可见的。</li>
</ul>
<h4 id="常见规则">常见规则</h4>
<ul>
<li><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作
happens-before 于书写在后面的操作；</li>
<li><strong>解锁规则</strong>：解锁 happens-before 于加锁；</li>
<li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作
happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile
变量的写操作的结果对于发生于其后的任何操作都是可见的。</li>
<li><strong>传递规则</strong>：如果 A happens-before B，且 B
happens-before C，那么 A happens-before C；</li>
<li><strong>线程启动规则</strong>：Thread 对象的
<code>start()</code>方法 happens-before 于此线程的每一个动作</li>
</ul>
<h3 id="并发三特性">并发三特性</h3>
<h4 id="原子性">原子性</h4>
<p>n次操作，要么同时执行，执行过程中不受任何干扰导致其终止，不然要么都不执行。</p>
<p>实现：</p>
<ul>
<li>悲观锁</li>
</ul>
<h4 id="可见性">可见性</h4>
<p>当一个线程对共享变量修改，其它线程可见。</p>
<p>实现：</p>
<ul>
<li>volatile：将变量声明为 <code>volatile</code> ，这就指示
JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
<h4 id="有序性">有序性</h4>
<p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>
<p>volatile禁止指令重排序。</p>
<h2 id="重要的锁">重要的锁</h2>
<h3 id="volatile关键字">volatile关键字</h3>
<h4 id="如何保证可见性">如何保证可见性</h4>
<p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示
JVM，这个变量是共享且不稳定的，每次使用它都<strong>到主存中进行读取</strong>。</p>
<h4 id="为什么禁止指令重排序">为什么禁止指令重排序</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance = new Singleton();</code>
这段代码其实是分为三步执行：</p>
<ol type="1">
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>这三个指令如果发生重排，假如变成1 -&gt; 3 -&gt; 2的顺序。</p>
<p>例如，线程 T1 执行了 1 和 3，此时 T2 调用
<code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code>
不为空，因此返回 <code>uniqueInstance</code>，但此时
<code>uniqueInstance</code> 还未被初始化。</p>
<h3 id="悲观锁">悲观锁</h3>
<p>悲观为主，做好最坏的打算，因此共享变量加锁每次只让一个线程操作。</p>
<p>缺点：高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>
<p>应用：写多读少</p>
<h3 id="乐观锁">乐观锁</h3>
<p>缺陷：冲突频繁发生（写占比非常多的情况），会频繁失败和重试，会非常影响性能，导致
CPU 飙升。</p>
<p>应用：读多写少</p>
<h4 id="版本号机制实现">版本号机制实现</h4>
<p>在数据表中加上一个数据版本号 <code>version</code>
字段，表示数据被修改的次数。当数据被修改时，<code>version</code>
值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取
<code>version</code> 值.</p>
<p>在<strong>提交更新</strong>时，若刚才读取到的 version
值为当前数据库中的 <code>version</code>
值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h4 id="cas实现">CAS实现</h4>
<p>全称Compare and Swap ， 底层是一个原子指令。</p>
<p>思想：用预期值和要更新的变量值比较，相等才会更新。</p>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong>：要更新的变量值(Var)</li>
<li><strong>E</strong>：预期值(Expected)</li>
<li><strong>N</strong>：拟写入的新值(New)</li>
</ul>
<p>案例：线程 A 要修改变量 i 的值为 6，i 原值为 1（V =
1，E=1，N=6，假设不存在 ABA 问题）。</p>
<ol type="1">
<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6
。</li>
<li>i 与 1
进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS
操作失败。</li>
</ol>
<h4 id="乐观锁存在的问题">乐观锁存在的问题</h4>
<h5 id="aba问题">ABA问题</h5>
<p>如果一个变量初始是A值，准备修改他的时候还是A值，但是这中间可能发生其它修改，这是未知的。</p>
<h5 id="循环等待时长久">循环等待时长久</h5>
<p>CAS
经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给
CPU 带来非常大的执行开销。</p>
<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause
指令有两个作用：</p>
<ol type="1">
<li>可以延迟流水线执行指令，使 CPU
不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU
流水线被清空，从而提高 CPU 的执行效率。</li>
</ol>
<h3 id="公平锁和非公平锁">公平锁和非公平锁</h3>
<ul>
<li>公平锁：锁被释放之后，先申请的线程先得到锁。
<ul>
<li>性能不好，但公平</li>
</ul></li>
<li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是<strong>随机</strong>或者按照其他优先级排序的。
<ul>
<li>性能好，但会出现饿死</li>
</ul></li>
</ul>
<h3 id="可中断锁和不可中断锁">可中断锁和不可中断锁</h3>
<ul>
<li><strong>可中断锁</strong>：<strong>获取锁的过程</strong>中可以被中断，不需要一直等到获取锁之后
才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>
<li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。
<code>synchronized</code> 就属于是不可中断锁。</li>
</ul>
<h3 id="共享锁和独占锁">共享锁和独占锁</h3>
<ul>
<li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li>
<li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li>
</ul>
<h3 id="自旋锁">自旋锁</h3>
<h3 id="synchronized-锁">synchronized 锁</h3>
<h4 id="使用">使用</h4>
<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得
<strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得
<strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code>
方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态
<code>synchronized</code> 方法，而线程 B
需要调用这个实例对象所属类的静态 <code>synchronized</code>
方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code>
方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code>
方法占用的锁是当前实例对象锁。</p>
<p><strong>3、修饰代码块</strong> （锁指定对象/类）</p>
<p>对括号里指定的对象/类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得
<strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得
<strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="底层原理">底层原理</h4>
<p><code>synchronized</code> 同步语句块的实现使用的是
<code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中
<code>monitorenter</code>
指令指向同步代码块的开始位置，<code>monitorexit</code>
指令则指明同步代码块的结束位置。</p>
<figure>
<img src="synchronized-get-lock-code-block.png"
alt="执行 monitorenter 获取锁" />
<figcaption aria-hidden="true">执行 monitorenter 获取锁</figcaption>
</figure>
<p>锁计数器。</p>
<p>解锁：</p>
<figure>
<img src="synchronized-release-lock-block.png"
alt="执行 monitorexit 释放锁" />
<figcaption aria-hidden="true">执行 monitorexit 释放锁</figcaption>
</figure>
<h3 id="reentrantlock">ReentrantLock</h3>
<p>实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁</p>
<h3 id="reentrantreadwritelock">ReentrantReadWriteLock</h3>
<p>可重入的读写锁，实现了读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p>
<p>两把锁：</p>
<ul>
<li>WriteLock：一个线程持有</li>
<li>ReadLock：多个线程持有</li>
</ul>
<p>适合<strong>读多写少</strong>的场景</p>
<p>能否同时拥有两把锁：</p>
<ul>
<li>拥有读锁的情况下，不能获得写锁：读锁不能升级为写锁</li>
<li>拥有写锁的情况下，不能获得读锁</li>
</ul>
<h2 id="threadlocal">ThreadLocal</h2>
<p>作用：保证每一个线程拥有自己独立的本地变量</p>
<h3 id="原理">原理</h3>
<p>俩容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上ThreadLocal就是对hashmap容器的一个封装。</p>
<p>set方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面得出结论，最终要存的变量，放在了<strong><code>ThreadLocalMap</code></strong>
中，key就是<code>ThreadLocal</code>对象 ,value就是Object类对象。</p>
<p>抛开<code>ThreadLocal</code>，每个线程其实是有一个<code>ThreadLocalMap</code>，可以存多个ThreadLocal对象</p>
<figure>
<img src="threadlocal-data-structure.png" alt="ThreadLocal 数据结构" />
<figcaption aria-hidden="true">ThreadLocal 数据结构</figcaption>
</figure>
<h3 id="内存泄露问题">内存泄露问题</h3>
<p>Entry是一个弱引用，如果 <code>ThreadLocal</code>
没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value
不会被清理掉。</p>
<p>这样就会出现许多key为null的Entry，占用空间。</p>
<p>解决：手动调用remove（）方法。</p>
<h2 id="线程池">线程池</h2>
<p>使用好处：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="创建线程池的方式">创建线程池的方式</h3>
<ol type="1">
<li><p><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p></li>
<li><p><strong>通过 <code>Executor</code> 框架的工具类
<code>Executors</code> 来创建。</strong></p></li>
</ol>
<h3 id="线程池参数">线程池参数</h3>
<p><strong><code>ThreadPoolExecutor</code> 3
个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code></strong> ：核心线程数</li>
<li><strong><code>maximumPoolSize</code></strong> ：最大线程数</li>
<li><strong><code>workQueue</code></strong>：工作队列。新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p>其它参数：</p>
<p><strong><code>keepAliveTime</code></strong>：存活时间：线程池中的线程数量大于
<code>corePoolSize</code>
的时候，这部分线程如果没有要执行的任务，会等待这个keepAliveTime时间后销毁。属于救急线程</p>
<p><strong><code>unit</code></strong>： <code>keepAliveTime</code>
参数的时间单位。</p>
<p><strong><code>threadFactory</code></strong> ：产生线程的工厂</p>
<p><strong><code>handler</code></strong> ：拒绝策略</p>
<p>工作原理：</p>
<figure>
<img src="image-20210831093204388.png" alt="image-20210831093204388" />
<figcaption aria-hidden="true">image-20210831093204388</figcaption>
</figure>
<p>流程：</p>
<figure>
<img src="图解线程池实现原理.png" alt="图解线程池实现原理" />
<figcaption aria-hidden="true">图解线程池实现原理</figcaption>
</figure>
<h4 id="四种拒绝策略">四种拒绝策略</h4>
<ol type="1">
<li><strong>抛异常</strong>
java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li>
<li><strong>由调用者执行任务</strong>
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li>
<li><strong>丢弃任务</strong>
java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li>
<li><strong>丢弃最早排队任务</strong>
java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li>
</ol>
<h3 id="常用的阻塞队列">常用的阻塞队列</h3>
<ul>
<li>容量为 <code>Integer.MAX_VALUE</code> 的
<code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code>
和 <code>SingleThreadExector</code>
。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li>
<li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code>
。<code>SynchronousQueue</code>
没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code>
的最大线程数是 <code>Integer.MAX_VALUE</code>
，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致
OOM。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code>
和 <code>SingleThreadScheduledExecutor</code>
。<code>DelayedWorkQueue</code>
的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code>
添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达
<code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>
</ul>
<h2 id="aqs">AQS</h2>
<h3 id="aqs底层">AQS底层</h3>
<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code>
，翻译过来的意思就是抽象队列同步器</p>
<h4 id="思想">思想</h4>
<p>看共享资源状态：</p>
<ul>
<li>共享资源空闲：将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li>
<li>被请求的共享资源被占用：需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制
AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten
locks） 实现的。</li>
</ul>
<p>共享资源方式：</p>
<ul>
<li><code>Exclusive</code>：独占，如<code>ReentrantLock</code></li>
<li><code>Share</code>：共享，如<code>Semaphore</code>/<code>CountDownLatch</code></li>
</ul>
<h5 id="clh队列">CLH队列</h5>
<p>数据结构：双向链表</p>
<figure>
<img src="CLH.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>对于资源state的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取资源的过程：</p>
<p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为
0，表示未锁定状态。</p>
<p>A线程调用lock()，state+1，获取锁成功。其它线程发现这个state !=
0，获取锁失败，A释放锁的时候，state--，变为0。</p>
<p><strong>可重入：</strong>A在执行业务的时候，想重复获取锁，state会继续++，同样释放的时候也是由内而外释放锁。</p>
<h5 id="自定义同步器">自定义同步器</h5>
<p>基于模板方法模式</p>
<ol type="1">
<li>使用者继承 <code>AbstractQueuedSynchronizer</code>
并重写指定的方法。</li>
<li>将 AQS
组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h2 id="同步工具类">同步工具类</h2>
<h3 id="semaphore信号量">Semaphore(信号量)</h3>
<p>可以控制多个访问同一资源的线程。</p>
<p><strong>使用：</strong></p>
<p>假设有 <code>N(N&gt;5)</code> 个线程来获取 <code>Semaphore</code>
中的共享资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>
<p>只有这五个线程能访问到特定的资源。获取到共享资源的线程才能执行。</p>
<blockquote>
<p>如果资源只有一个，那就跟lock这种排它锁没区别。</p>
</blockquote>
<p><strong>模式</strong>：</p>
<ul>
<li>公平模式：调用 <code>acquire()</code>
方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li>非公平模式：抢占式的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">  	sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定是否公平</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  	sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用：</strong>单机限流。</p>
<h4 id="原理-1">原理</h4>
<p>AQS实现，将构造方法传来的permits，当做state的值。</p>
<figure>
<img src="image-20230908184053505.png" alt="image-20230908184053505" />
<figcaption aria-hidden="true">image-20230908184053505</figcaption>
</figure>
<h3 id="countdownlatch-倒计时器">CountDownLatch （倒计时器）</h3>
<p><code>CountDownLatch</code> 允许 <code>count</code>
个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p>一次性使用工具，使用完即销毁。</p>
<h4 id="原理-2">原理</h4>
<p>默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程调用 <code>countDown()</code>
时，其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少
<code>state</code>，state为0时，表示所有的线程都调用了
<code>countDown</code> 方法，在 <code>CountDownLatch</code>
上等待的线程就会被唤醒并继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放共享锁，AbstractQueuedSynchronizer 默认实现</span></span><br><span class="line"><span class="comment">// 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//释放共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      <span class="comment">//释放当前节点的后置等待节点</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 state 进行递减，直到 state 变成 0；</span></span><br><span class="line"><span class="comment">// 只有 count 递减到 0 时，countDown 才会返回 true</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 自选检查 state 是否为 0</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果 state 已经是 0 了，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对 state 进行递减</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// CAS 操作更新 state 的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待（也可以叫做加锁）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有超时时间的等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取锁，获取成功则返回，失败则加入等待队列，挂起线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 尝试获得锁，获取成功则返回</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 获取失败加入等待队列，挂起线程</span></span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="应用">应用</h4>
<ol type="1">
<li><p>某一线程在开始运行前等待 n 个线程执行完毕 : 将
<code>CountDownLatch</code> 的计数器初始化为 n
（<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减
1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在
<code>CountDownLatch 上 await()</code>
的线程就会被唤醒。一个典型应用场景就是<strong>启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</strong>。</p></li>
<li><p>多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是<strong>多个线程在某一时刻同时开始执行</strong>。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的
<code>CountDownLatch</code> 对象，将其<strong>计数器初始化为 1</strong>
（<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先
<code>coundownlatch.await()</code>，当<strong>主线程调用</strong>
<code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p></li>
</ol>
<h2 id="atomic-原子类">Atomic 原子类</h2>
<h1 id="io">IO</h1>
<p>Input/Output，针对内存，数据输入到内存就叫输入，数据输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>/<code>Reader</code>:
所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>/<code>Writer</code>:
所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h2 id="基础">基础</h2>
<h3 id="字节流">字节流</h3>
<h4 id="字节输入流inputstream">字节输入流InputStream</h4>
<p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）<strong>到内存</strong>中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<p><code>InputStream</code> 常用方法：</p>
<ul>
<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到
255 之间。如果未读取任何字节，则代码返回 <code>-1</code>
，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组
<code>b</code> 中。如果数组 <code>b</code>
的长度为零，则不读取。如果没有可用字节读取，返回
<code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于
<code>b.length</code> ， 返回读取的字节数。这个方法等价于
<code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code>
方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>
参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节
,返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>
<ul>
<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取
<code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<p><code>FileInputStream</code>
是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<p>配合 <code>BufferedInputStream</code>使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p><code>DataInputStream</code>
用于读取指定类型数据，不能单独使用，必须结合其它流，比如
<code>FileInputStream</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure>
<p><code>ObjectInputStream</code> 用于从输入流中读取 Java
对象（反序列化），<code>ObjectOutputStream</code>
用于将对象写入到输出流(序列化)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>
<h4 id="字节输出流outputstream">字节输出流OutputStream</h4>
<p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是<strong>所有字节输出流的父类</strong>。</p>
<p><code>OutputStream</code> 常用方法：</p>
<ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code>
写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> :
在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>FileOutputStream</code>
是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<p>配合 <code>BufferedOutputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream)</span><br></pre></td></tr></table></figure>
<p><strong><code>DataOutputStream</code></strong>
用于写入指定类型数据，不能单独使用，必须结合其它流，比如
<code>FileOutputStream</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="comment">// 输出任意数据类型</span></span><br><span class="line">dataOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">dataOutputStream.writeByte(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Guide哥&quot;</span>, <span class="string">&quot;JavaGuide作者&quot;</span>);</span><br><span class="line">output.writeObject(person);</span><br></pre></td></tr></table></figure>
<h3 id="字符流">字符流</h3>
<p>为什么会有字符流：</p>
<ul>
<li>如果不知道编码类型就很容易出现乱码问题。</li>
</ul>
<p>字符流默认采用的是 <code>Unicode</code>
编码，我们可以通过构造方法自定义编码。</p>
<p><code>utf8</code> :英文占 1 字节，中文占 3
字节，<code>unicode</code>：任何字符都占 2
个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
<h4 id="reader字符输入流">Reader（字符输入流）</h4>
<p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code>
用于读取原始字节。</p>
<p><code>Reader</code> 常用方法：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> :
从输入流中读取一些字符，并将它们存储到字符数组
<code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code>
。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code>
方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>
参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字符
,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类
<code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于读取字符文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileReader</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);) &#123;</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fileReader.skip(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section"></h3>
<h4 id="writer字符输出流">Writer（字符输出流）</h4>
<p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<p><code>Writer</code> 常用方法：</p>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code>：写入字符数组
<code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code>
方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>
参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code>：写入字符串，等价于
<code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code>
方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>
参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的
<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code>：将指定的字符附加到指定的
<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类
<code>FileWriter</code>
是基于该基础上的封装，可以直接将字符写入到文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符流转换为字节流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于写入字符到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileWriter</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    output.write(<span class="string">&quot;你好。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节缓冲流">字节缓冲流</h3>
<p>IO
操作消耗性能的，缓冲流将数据加载至缓冲区，<strong>一次性读取/写入多个字节</strong>，从而避免频繁的
IO 操作，提高流的传输效率。</p>
<p>字节缓冲流这里采用了<strong>装饰器模式</strong>来增强
<code>InputStream</code>
和<code>OutputStream</code><strong>子类对象</strong>的功能。</p>
<p>通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强
<code>FileInputStream</code> 的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>字节流和字节缓冲流的性能差别： <code>write(int b)</code> 和
<code>read()</code>
这两个一次只读取一个字节的方法，由于字节缓冲流内部有缓冲区，因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少
IO 次数，提高读取效率。</p>
<p>使用 <code>write(int b)</code> 和 <code>read()</code>
方法，复制大文件性能对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用缓冲流复制PDF文件总耗时:15428 毫秒</span><br><span class="line">使用普通字节流复制PDF文件总耗时:2555062 毫秒</span><br></pre></td></tr></table></figure>
<p>调用 <code>read(byte b[])</code> 和
<code>write(byte b[], int off, int len)</code>
这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//每次写入4M的量</span></span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4
id="bufferedinputstream字节缓冲输入流">BufferedInputStream（字节缓冲输入流）</h4>
<p><code>BufferedInputStream</code>
从源头（通常是文件）读取数据（字节信息）到内存的过程中<strong>不会一个字节一个字节的读取</strong>，而是会先<strong>将读取到的字节存放在缓存区</strong>，并从内部缓冲区中单独读取字节。这样大幅减少了
IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code>
内部维护了一个缓冲区，这个<strong>缓冲区实际就是一个字节数组</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 缓冲区的默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 使用默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓冲区的大小默认为 <strong>8192</strong> 字节，也可以通过
<code>BufferedInputStream(InputStream in, int size)</code>
这个构造方法来指定缓冲区的大小。</p>
<h4
id="bufferedoutputstream字节缓冲输出流">BufferedOutputStream（字节缓冲输出流）</h4>
<p><code>BufferedOutputStream</code>
将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了
IO 次数，提高了读取效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    bos.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 <code>BufferedInputStream</code>
，<code>BufferedOutputStream</code>
内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong>
字节。</p>
<h3 id="字符缓冲流">字符缓冲流</h3>
<p><code>BufferedReader</code> （字符缓冲输入流）和
<code>BufferedWriter</code>（字符缓冲输出流）类似于
<code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<h3 id="打印流输出流的一种">打印流——输出流的一种</h3>
<p>sout原理：获取一个PrintStream对象，<code>print</code>方法实际调用的是
<code>PrintStream</code> 对象的 <code>write</code>
方法。<code>PrintStream</code> 属于字节打印流，与之对应的是
<code>PrintWriter</code> （字符打印流）。</p>
<h3 id="随机访问流">随机访问流</h3>
<p>定义：随意跳转到文件的任意位置进行读写的
<code>RandomAccessFile</code> 。</p>
<p>RandomAccessFile构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file, mode, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode, <span class="type">boolean</span> openAndDelete)</span>  <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">  <span class="comment">// 省略大部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以指定读写模式：</p>
<ul>
<li><code>r</code> : 只读模式。</li>
<li><code>rw</code>: 读写模式</li>
<li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code>
同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li>
<li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code>
同步更新对“文件的内容”的修改到外部存储设备。</li>
</ul>
<blockquote>
<p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>
</blockquote>
<p><code>RandomAccessFile</code>
中有一个<strong>文件指针</strong>用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过
<code>RandomAccessFile</code> 的 <code>seek(long pos)</code>
方法来设置文件指针的偏移量（距文件开头 <code>pos</code>
个字节处）。如果想要获取文件指针当前的位置的话，可以使用
<code>getFilePointer()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 指针当前偏移量为 6</span></span><br><span class="line">randomAccessFile.seek(<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 从偏移量 7 的位置开始往后写入字节数据</span></span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 指针当前偏移量为 0，回到起始位置</span></span><br><span class="line">randomAccessFile.seek(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br></pre></td></tr></table></figure>
<p>假设文件内容为：ABCDEFG，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br><span class="line">读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><br><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br></pre></td></tr></table></figure>
<p>写覆盖：</p>
<p><code>RandomAccessFile</code> 的 <code>write</code>
方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为
<code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p>
<p>断点续传：</p>
<p>上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件<strong>分片</strong>即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>
<h2 id="涉及设计模式">涉及设计模式</h2>
<h3 id="装饰器模式">装饰器模式</h3>
<p><strong>装饰器（Decorator）模式</strong>
可以在不改变原有对象的情况下拓展其功能。</p>
<p>组合替代继承来扩展原始类的功能，一些继承关系比较复杂的场景（IO
这一场景各种类的继承关系就比较复杂）更加实用。</p>
<p>装饰器的抽象装饰：<code>FilterInputStream</code>
（对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心</p>
<ul>
<li>用于增强 <code>InputStream</code>
和<code>OutputStream</code>子类对象的功能。</li>
</ul>
<p>具体装饰类：<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code>
等等都是<code>FilterInputStream</code>
的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p>
<p>案例：通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强
<code>FileInputStream</code> 的功</p>
<h3 id="适配器模式">适配器模式</h3>
<p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>
就是两个适配器(Adapter)，
同时，它们两个也是<strong>字节流和字符流之间的桥梁</strong>。</p>
<p><code>InputStreamReader</code> 使用 <code>StreamDecoder</code>
（流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong></p>
<p><code>OutputStreamWriter</code>
使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换</p>
<p><code>InputStream</code> 和 <code>OutputStream</code>
的子类是被适配者， <code>InputStreamReader</code> 和
<code>OutputStreamWriter</code>是适配器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br></pre></td></tr></table></figure>
<p><code>java.io.InputStreamReader</code> 部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">	<span class="comment">//用于解码的对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 StreamDecoder 对象</span></span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamDecoder 对象做具体的读取工作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.io.OutputStreamWriter</code> 部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="comment">// 用于编码的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamEncoder se;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取 StreamEncoder 对象</span></span><br><span class="line">            se = StreamEncoder.forOutputStreamWriter(out, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamEncoder 对象做具体的写入工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        se.write(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式">观察者模式</h3>
<p>NIO 中的文件目录监听服务使用到了观察者模式。</p>
<p>观察者：WatchService</p>
<p>被观察者：Watchable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Path</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Watchable</span> &#123;</span><br><span class="line">    WatchKey <span class="title function_">register</span><span class="params">(WatchService watcher,</span></span><br><span class="line"><span class="params">                      WatchEvent.Kind&lt;?&gt;[] events,</span></span><br><span class="line"><span class="params">                      WatchEvent.Modifier... modifiers)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WatchService</code> 用于监听文件目录的变化，同一个
<code>WatchService</code> 对象能够监听多个文件目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 WatchService 对象</span></span><br><span class="line"><span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个被监控文件夹的 Path 类:</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;workingDirectory&quot;</span>);</span><br><span class="line"><span class="comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span></span><br><span class="line"><span class="type">WatchKey</span> <span class="variable">watchKey</span> <span class="operator">=</span> path.register(</span><br><span class="line">watchService, StandardWatchEventKinds...);</span><br></pre></td></tr></table></figure>
<p><code>Path</code> 类 <code>register</code> 方法的第二个参数
<code>events</code>
（需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p>
<p><code>WatchService</code> 内部是通过一个 daemon
thread（守护线程）采用定期轮询的方式来检测文件的变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PollingWatchService</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractWatchService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutor;</span><br><span class="line"></span><br><span class="line">    PollingWatchService() &#123;</span><br><span class="line">        scheduledExecutor = Executors</span><br><span class="line">            .newSingleThreadScheduledExecutor(<span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                     <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                     t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                     <span class="keyword">return</span> t;</span><br><span class="line">                 &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enable</span><span class="params">(Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events, <span class="type">long</span> period)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 更新监听事件</span></span><br><span class="line">      <span class="built_in">this</span>.events = events;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启定期轮询</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; poll(); &#125;&#125;;</span><br><span class="line">      <span class="built_in">this</span>.poller = scheduledExecutor</span><br><span class="line">        .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="io模型">I/O模型</h2>
<h1 id="javaweb">JavaWeb</h1>
<h2 id="cookie和session">Cookie和Session</h2>
<p>cookie的创建过程：</p>
<figure>
<img
src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_70.png"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>session的创建过程：</p>
<ol type="1">
<li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（<strong>name为JSESSIONID的固定值</strong>，value为session对象的ID），然后将该Cookie发送至浏览器端</li>
<li>浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。</li>
</ol>
<h3 id="区别">区别</h3>
<ol type="1">
<li><p>数据存储位置：session在服务端、cookie在客户端</p></li>
<li><p>安全性</p>
<ul>
<li>cookie：不安全，存在浏览器就有被窃取的风险。</li>
<li>session：在进行敏感操作或者需要鉴别用户的时候，由于保存到服务端，安全性较高。会拿请求中的id去对比服务端存的用户等id信息来进行决策判断。</li>
</ul>
<p>所以一般登录业务涉及到的敏感数据都会放到session，而一些不重要的信息，但又能经常访问到的，放在cookie保存。</p></li>
<li><p>服务器压力</p>
<ul>
<li>session会加重服务器处理的压力。</li>
<li>cookie压力在于浏览器和本地的效率。</li>
</ul></li>
<li><p>保存时间</p>
<ul>
<li>cookie：保存时间很久，默认根据浏览器设定。当然服务端response的时候也能设置</li>
<li>session：服务器关闭，就会消失。</li>
</ul></li>
</ol>
<h2 id="servlet">Servlet</h2>
<p>Servlet是Java中用于<strong>处理Web请求和响应</strong>的一种技术。它是一种服务器端的Java程序，主要用于创建动态的、可扩展的Web应用程序。<strong>Servlet运行在支持Java的Web服务器上</strong>，如Tomcat、Jetty等。</p>
<h3 id="生命周期">生命周期</h3>
<ol type="1">
<li>初始化
<ul>
<li><strong>init(ServletConfig
config)方法</strong>：当Servlet第一次被请求时，Servlet容器会调用<code>init</code>方法。</li>
</ul></li>
<li>服务
<ul>
<li><strong>service(ServletRequest request, ServletResponse
response)方法：</strong>
当有请求到达时，Servlet容器会调用<code>service</code>方法，传递<code>ServletRequest</code>和<code>ServletResponse</code>对象。在这个方法中，开发者编写处理请求和生成响应的业务逻辑。</li>
<li>多线程处理：一个请求对应一个线程</li>
</ul></li>
<li>销毁</li>
</ol>
<h3 id="为什么有这样的规范">为什么有这样的规范</h3>
<ol type="1">
<li><strong>平台独立性：</strong>
Java是一种跨平台的编程语言，<strong>Servlet技术被设计成与特定的操作系统无关</strong>，可以在任何支持Java的平台上运行。这为开发人员提供了更大的灵活性，可以在不同的环境中部署相同的Servlet应用。</li>
<li><strong>可移植性：</strong>
Servlet的规范定义了一种标准的接口，使得开发人员可以编写与服务器无关的Servlet代码。这意味着，一旦开发了一个Servlet应用程序，它可以在任何支持Servlet规范的Web容器上运行，而不需要修改代码。</li>
<li><strong>面向Web开发：</strong>
Java的设计目标之一是支持分布式计算和网络编程。Servlet的出现使得Java可以更好地应对Web开发的需求，提供了一种有效的方式来处理HTTP请求和响应。</li>
</ol>
<h1 id="常用框架">常用框架</h1>
<h2 id="mybatis">Mybatis</h2>
<h3 id="查询缓存">查询缓存</h3>
<figure>
<img src="java面试整理/Center.png" alt="Mybatis缓存架构" />
<figcaption aria-hidden="true">Mybatis缓存架构</figcaption>
</figure>
<h4 id="一级缓存">一级缓存</h4>
<p><img src="java面试整理/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzM4MTU=,size_16,color_FFFFFF,t_70.png" alt="一级缓存" style="zoom: 50%;" /></p>
<p>一级缓存位于sqlsession内部，sqlsession是mybatis与数据库进行通信需要建立的对象，对象内部有类似hashmap这样的内存区域。</p>
<ul>
<li>sqlsession可以有多个，多个sqlsession之间的hashmap不受影响</li>
</ul>
<p>作用：两次相同的sql都基于一个sqlsession执行的话，那第一次执行完这个sql，就会把查询到的数据放入缓存中，第二次查询就会走这个缓存。</p>
<h5 id="生命周期-1">生命周期</h5>
<p>由sqlsession决定：</p>
<ul>
<li>创建：MyBatis在开启一个数据库会话时，会自行创建一个sqlsession对象，对象内部有一个excutor对象，excutor对象里又有PerpetualCache对象。</li>
<li>销毁：
<ul>
<li>会话正常结束：sqlsession被回收，缓存也会被回收</li>
<li>sqlsession操作缓存：
<ul>
<li>调用close()方法：清除PerpetualCache对象</li>
<li>调用clearCache()：只是简单清除缓存中的数据；但凡sql语句中涉及更新操作（insert、update、delete），为了保证一致性，sqlsession都会调用这个方法去清除cache对象中的数据</li>
</ul></li>
</ul></li>
</ul>
<h5 id="判断两次查询是否相同">判断两次查询是否相同</h5>
<ol type="1">
<li>传入的statementID相同</li>
<li>设置的statement参数相同</li>
<li>结果集范围相同</li>
<li>最终sql语句字符串相同</li>
</ol>
<h4 id="二级缓存">二级缓存</h4>
<p><img src="java面试整理/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzM4MTU=,size_16,color_FFFFFF,t_70-17012287648565.png" alt="二级缓存" style="zoom: 67%;" /></p>
<p>二级缓存的建设对象是mapper，每一个mapper有一个独立的命名空间，每个命名空间有一个缓存。这些命名空间都被Configuration对象管理。</p>
<p>多个sqlsession操作同一mapper的sql语句，得到的数据会放在二级缓存。
缓存数据被sqlsession共享，</p>
<p>sqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求<strong>返回的POJO必须是可序列化的</strong>。</p>
<p>工作原理：</p>
<figure>
<img src="java面试整理/Center-17012298390778.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="spring">Spring</h2>
<h3 id="spring模块">Spring模块</h3>
<figure>
<img src="20200831175708.png" alt="Spring5.x主要模块" />
<figcaption aria-hidden="true">Spring5.x主要模块</figcaption>
</figure>
<figure>
<img src="20200902100038.png" alt="Spring 各个模块的依赖关系" />
<figcaption aria-hidden="true">Spring 各个模块的依赖关系</figcaption>
</figure>
<h4 id="core-container">Core Container</h4>
<p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC
依赖注入功能的支持。Spring
其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring
各个模块的依赖关系图就可以看出来。</p>
<ul>
<li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li>
<li><strong>spring-beans</strong>：提供对 bean
的创建、配置和管理等功能的支持。</li>
<li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li>
<li><strong>spring-expression</strong>：提供对表达式语言（Spring
Expression Language） SpEL 的支持，只依赖于 core
模块，不依赖于其他模块，可以单独使用。</li>
</ul>
<h4 id="aop">AOP</h4>
<ul>
<li><strong>spring-aspects</strong>：该模块为与 AspectJ
的集成提供支持。</li>
<li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li>
<li><strong>spring-instrument</strong>：提供了为 JVM
添加代理（agent）的功能。 具体来讲，它为 Tomcat
提供了一个织入代理，能够为 Tomcat 传递类文
件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限.</li>
</ul>
<h4 id="data-accessintegration">Data Access/Integration</h4>
<ul>
<li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象
JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java
程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li><strong>spring-tx</strong>：提供对事务的支持。</li>
<li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM
框架的支持。</li>
<li><strong>spring-oxm</strong>：提供一个抽象层支撑
OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和
XStream 等。</li>
<li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1
以后，它还提供了对 spring-messaging 模块的继承。</li>
</ul>
<h4 id="spring-web">Spring Web</h4>
<ul>
<li><strong>spring-web</strong>：对 Web
功能的实现提供一些最基础的支持。</li>
<li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li>
<li><strong>spring-websocket</strong>：提供了对 WebSocket
的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是
Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC
不同，它不需要 Servlet API，是完全异步。</li>
</ul>
<h4 id="spring-test">Spring Test</h4>
<p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转
(IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似
JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito
的问题比如无法模拟 final, static， private
方法）等等常用的测试框架支持的都比较好。</p>
<h3 id="ioc">Ioc</h3>
<p><strong>IoC（Inversion of
Control:控制反转）</strong>：一种设计思想，就是我们把创建对象的控制权交给容器管理。</p>
<ul>
<li>控制：对象创建的行为，包括对象间的依赖关系，都交由spring容器来管理。</li>
<li>反转：交给外部环境</li>
</ul>
<p>本质：map集合。</p>
<h4 id="源码解析">源码解析</h4>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">Spring IOC
容器源码分析_Javadoop</a></p>
<h4 id="spring-bean">Spring Bean</h4>
<p>IoC 容器所管理的对象。</p>
<h5 id="类声明为bean的注解">类声明为bean的注解</h5>
<ul>
<li><code>@Component</code>：通用的注解，可标注任意类为
<code>Spring</code> 组件。如果一个 <strong>Bean
不知道属于哪个层</strong>，可以使用<code>@Component</code>
注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao
层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到
Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC
控制层，主要用于接受用户请求并调用 <code>Service</code>
层返回数据给前端页面。</li>
</ul>
<h5 id="component-和-bean-的区别"><span class="citation"
data-cites="Component">@Component</span> 和 <span class="citation"
data-cites="Bean">@Bean</span> 的区别</h5>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><span class="citation" data-cites="Bean">@Bean</span></th>
<th><span class="citation" data-cites="Component">@Component</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用域</td>
<td>作用在方法上</td>
<td>作用在类上</td>
</tr>
<tr class="even">
<td>含义</td>
<td>标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring
这是某个类的实例，当我需要用它的时候还给我。</td>
<td><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到
Spring 容器中（我们可以使用 <code>@ComponentScan</code>
注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean
容器中）。</td>
</tr>
<tr class="odd">
<td>自定义性</td>
<td>很强，通常外部导入的组件都用这个注解</td>
<td>一般用于配置类这种。</td>
</tr>
</tbody>
</table>
<h5 id="注入bean的注解">注入bean的注解</h5>
<table>
<thead>
<tr class="header">
<th>Annotaion</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr class="even">
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr class="odd">
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody>
</table>
<p><code>@Autowired</code>
和<code>@Resource</code>使用的比较多一些。</p>
<h5 id="autowired-和resource的区别"><code>@Autowired</code>
和<code>Resource</code>的区别</h5>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><span class="citation" data-cites="Autowired">@Autowired</span></th>
<th><span class="citation" data-cites="Resource">@Resource</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>提供者</td>
<td>spring</td>
<td>java</td>
</tr>
<tr class="even">
<td>注入方式</td>
<td>默认byType，可以通过 <code>@Qualifier</code>
注解来显式指定名称Byname</td>
<td>默认ByName，当然两个都行，看配置</td>
</tr>
<tr class="odd">
<td>使用范围</td>
<td>支持在构造函数、方法、字段和参数上使用</td>
<td>主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</td>
</tr>
</tbody>
</table>
<ul>
<li><code>ByType</code>存在的问题：当一个接口存在多个实现类，如果不指定名称，那编译器就不知道该使用这个接口的哪一个抽象类。于是会根据你定义的<strong>成员变量名</strong>匹配</li>
</ul>
<h5 id="bean的作用域">bean的作用域</h5>
<ul>
<li>singleton：单例</li>
<li>prototype：多例</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP
请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request
内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session
的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP
session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web
应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean
仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket
会话产生一个新的 bean</li>
</ul>
<h5 id="bean是否线程安全">bean是否线程安全</h5>
<p>单例bean：如果这个bean存在状态，那么就是可能会出现竞争情况下的并发安全问题。</p>
<ul>
<li>状态：就是使用过程中会不会改变它的一些属性等等，一般项目中的bean如Dao、service了，我们只是简单的使用这个接口去调用它的方法并不会改变它的属性值</li>
</ul>
<p>多例bean：不会存在线程安全问题，因为每次获取都会创建一个新的 bean
实例</p>
<h5 id="bean的生命周期">bean的生命周期</h5>
<ol type="1">
<li><p>实例化加载</p>
<ul>
<li><p>Bean 容器找到配置文件中 Spring Bean
的<strong>定义</strong>。</p></li>
<li><p>Bean 容器利用 Java Reflection API <strong>创建一个 Bean
的实例。</strong></p></li>
<li><p>如果涉及到一些属性值 利用
<code>set()</code>方法设置一些属性值。</p></li>
</ul></li>
<li><p>Aware，属性赋值</p>
<ul>
<li><p>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用
<code>setBeanName()</code>方法，传入 Bean 的名字。</p></li>
<li><p>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用
<code>setBeanClassLoader()</code>方法，传入
<code>ClassLoader</code>对象的实例。</p></li>
<li><p>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用
<code>setBeanFactory()</code>方法，传入
<code>BeanFactory</code>对象的实例。</p></li>
<li><p>与上面的类似，如果实现了其他
<code>*.Aware</code>接口，就调用相应的方法。</p></li>
</ul></li>
<li><p><strong>初始化</strong></p>
<ol type="1">
<li>前置处理
<ul>
<li>如果有和加载这个 Bean 的 Spring 容器相关的
<code>BeanPostProcessor</code>
对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
</ul>
<ol start="2" type="1">
<li><p>init</p>
<ul>
<li><p>如果 Bean
实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</p></li>
<li><p>如果 Bean 在配置文件中的定义包含 init-method
属性，执行指定的方法。</p></li>
</ul></li>
<li><p>后置处理</p>
<ul>
<li>如果有和加载这个 Bean 的 Spring 容器相关的
<code>BeanPostProcessor</code>
对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
</ul></li>
</ol></li>
</ol></li>
<li><p>销毁</p></li>
</ol>
<ul>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code>
接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含
destroy-method 属性，执行指定的方法。</li>
</ul>
<figure>
<img src="24bc2bad3ce28144d60d9e0a2edf6c7f.jpg"
alt="Spring Bean 生命周期" />
<figcaption aria-hidden="true">Spring Bean 生命周期</figcaption>
</figure>
<figure>
<img src="b5d264565657a5395c2781081a7483e1.jpg"
alt="Spring Bean 生命周期" />
<figcaption aria-hidden="true">Spring Bean 生命周期</figcaption>
</figure>
<h6
id="在bean装配阶段进行bean的替换复制">在bean装配阶段进行bean的替换、复制</h6>
<ol type="1">
<li><p>注册阶段，全局修改</p>
<p>编写定制的BeanFactoryPostProcessor，通过实现<code>postProcessBeanFactory</code>方法来修改或替换Bean定义。这是一个全局的Bean定义修改机会。</p></li>
<li><p>bean初始化前后，通过前置处理器后置处理器修改</p>
<p>实现BeanPostProcessor接口的<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>方法来替换或修改Bean的实例。</p></li>
</ol>
<h5 id="三级缓存解决循环依赖">三级缓存解决循环依赖</h5>
<p>bean的初始化要完成的三步：</p>
<ul>
<li>实例化</li>
<li>属性赋值</li>
<li>初始化</li>
</ul>
<p>三级缓存：</p>
<ol type="1">
<li>一级缓存 : <code>Map&lt;String,Object&gt;</code>
<strong>singletonObjects</strong>，单例池，用于保存<strong>实例化、属性赋值（注入）、初始化完成的
bean 实例</strong></li>
<li>二级缓存 : <code>Map&lt;String,Object&gt;</code>
<strong>earlySingletonObjects</strong>，早期曝光对象，用于<strong>保存实例化完成的
bean 实例</strong></li>
<li>三级缓存 : <code>Map&lt;String,ObjectFactory&lt;?&gt;&gt;</code>
<strong>singletonFactories</strong>，<strong>早期曝光对象工厂，用于保存
bean 创建工厂，以便于后面扩展有机会创建代理对象。</strong></li>
</ol>
<p>解决过程：</p>
<p>假设A、B循环依赖：</p>
<p>A、B的初始化过程：</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 42%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">缓存空间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">实例化： A
对象⼯⼚放⼊三级缓存，先曝光出来让大家知道</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">一级：，二级：，三级：A</td>
</tr>
<tr class="even">
<td style="text-align: center;">属性赋值：发现依赖B，去实例化B</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">实例化，B对象工厂放⼊三级缓存...</td>
<td style="text-align: center;">一级：，二级：，三级：A,B</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">属性赋值：发现依赖A，找A</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td
style="text-align: center;">去缓存中找A对象，拿到A的对象工厂,从对象工厂取出A（不完善）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">将A放入二级缓存，删除三级缓存中的A</td>
<td style="text-align: center;">一级：，二级：A，三级：B</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td
style="text-align: center;">B属性装配完成（装配的不完备的A），然后初始化完成</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">B放入一级缓存，是一个完备的对象</td>
<td style="text-align: center;">一级：B，二级：A，三级：</td>
</tr>
<tr class="odd">
<td
style="text-align: center;">A属性装配，去一级缓存找到B，装配完成，然后初始化完成</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">删除二级缓存的A，放入一级缓存</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">一级：A,B，二级：，三级：</td>
</tr>
</tbody>
</table>
<h6
id="为什么不能只使用一级三级缓存"><strong>为什么不能只使用一级+三级缓存</strong></h6>
<ol type="1">
<li>动态代理的创建时机就是<strong>存在于初始化后</strong>，为这个bean对象生成代理对象，如果先创建的话，这样不管这个类是否存在循环依赖，都会先生成，违反Bean的初始化设计。</li>
<li>如果只使用这两层缓存，在使用三级缓存中的工厂对象生成的动态代理对象都是<strong>新创建的</strong>，循环依赖的时候，<strong>注入到别的bean里面去的那个动态代理对象和最终这个bean在初始化后自己创建的bean地址值不一样</strong>，或者说有2个以上的bean循环依赖的时候，他们各自拿到的bean的动态代理对象都是不一样的。所以需要一个二级缓存来存，如果二级里面有就不用查三级了。这也三级缓存和二级缓存的初始容量只有16的原因出现循环依赖本身就是代码设计不合理的，不要为了那少部分的本身不合理情况的循环依赖去改变一个大多数都合理的设计。</li>
</ol>
<h3 id="aop-1">Aop</h3>
<p>AOP(Aspect-Oriented
Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>基于动态代理实现：</p>
<ul>
<li>如果目标对象实现了某个接口，会用jdk动态代理</li>
<li>目标对象没有实现接口，会使用 <strong>Cglib</strong>
生成一个被代理对象的<strong>子类</strong>来作为代理</li>
</ul>
<figure>
<img src="230ae587a322d6e4d09510161987d346.jpeg"
alt="SpringAOPProcess" />
<figcaption aria-hidden="true">SpringAOPProcess</figcaption>
</figure>
<p>AOP 切面编程设计到的一些专业术语：</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">术语</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">目标(Target)</td>
<td style="text-align: center;">被通知的对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">代理(Proxy)</td>
<td
style="text-align: center;">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr class="odd">
<td style="text-align: left;">连接点(JoinPoint)</td>
<td
style="text-align: center;">目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr class="even">
<td style="text-align: left;">切入点(Pointcut)</td>
<td style="text-align: center;">被切面拦截 /
增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">通知(Advice)</td>
<td style="text-align: center;">增强的逻辑 /
代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr class="even">
<td style="text-align: left;">切面(Aspect)</td>
<td style="text-align: center;">切入点(Pointcut)+通知(Advice)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Weaving(织入)</td>
<td
style="text-align: center;">将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody>
</table>
<h4 id="aspectj-aop">AspectJ AOP</h4>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong>
Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode
Manipulation)。</p>
<h5 id="通知类型">通知类型</h5>
<p><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</p>
<p><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</p>
<p><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p>
<p><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出
/ 触发异常后触发。AfterReturning 和 AfterThrowing
两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p>
<p><strong>Around</strong>
（环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</p>
<h4 id="应用场景">应用场景</h4>
<ol type="1">
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading 懒加载</li>
<li>Debugging 调试</li>
<li>logging，tracing，profiling and monitoring 记录跟踪 优化 校准</li>
<li>Performance optimization 性能优化</li>
<li>Persistence 持久化</li>
<li>Resource pooling 资源池</li>
<li>Synchronization 同步</li>
<li>Transactions 事务</li>
<li>Logging 日志</li>
</ol>
<ul>
<li></li>
</ul>
<h3 id="spring事务">Spring事务</h3>
<h4 id="管理事务的方式">管理事务的方式</h4>
<ul>
<li>声明式（推荐）：AOP 实现（基于<code>@Transactional</code>
的全注解方式使用最多）</li>
<li>编程式：<strong>通过编程的方式自己去实现事务</strong>，比如事务的开启、提交、回滚操作，需要开发人员自己调用commit()或者rollback()等方法来实现。</li>
</ul>
<h5 id="声明式">声明式</h5>
<p>基于<code>@Transactional</code> 的全注解方式</p>
<h5 id="编程式">编程式</h5>
<p>通过 java.sql.Connection 控制事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		testManualTransaction();<span class="comment">//测试函数式控制事务</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testManualTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring_transaction.xml&quot;</span>);</span><br><span class="line">		<span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource)context.getBean(<span class="string">&quot;datasource&quot;</span>);</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			initTable(conn);<span class="comment">//初始化表</span></span><br><span class="line">			conn.setAutoCommit(<span class="literal">false</span>);<span class="comment">//设置不自动提交事务</span></span><br><span class="line">			queryUsers(conn);<span class="comment">//查询打印用户表</span></span><br><span class="line">			deleteUser(conn);<span class="comment">//删除 id=1 用户</span></span><br><span class="line">			conn.rollback();<span class="comment">//回滚</span></span><br><span class="line">			queryUsers(conn);<span class="comment">//查询打印用户表</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			conn.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initTable</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		conn.createStatement().execute(<span class="string">&quot;drop table if exists user&quot;</span>);</span><br><span class="line">		conn.createStatement().execute(<span class="string">&quot;create table user(id int, username varchar(60)) ENGINE=InnoDB DEFAULT CHARSET=utf8 &quot;</span>);<span class="comment">//是否支持事务与数据库引擎有关，此处删除 ENGINE=InnoDB DEFAULT CHARSET=utf8 可能不支持事务</span></span><br><span class="line">		conn.createStatement().execute(<span class="string">&quot;insert into user values(1, &#x27;user1&#x27;)&quot;</span>);</span><br><span class="line">		conn.createStatement().execute(<span class="string">&quot;insert into user values(2, &#x27;user2&#x27;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		conn.createStatement().execute(<span class="string">&quot;delete from user where id = 1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queryUsers</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">		st.execute(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.getResultSet();</span><br><span class="line">		<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">			System.out.print(rs.getString(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">			System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			System.out.print(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Spring为我们提供的TransactionTemplate：</p>
<p>它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个TransactionTemplate</span></span><br><span class="line"><span class="type">TransactionTemplate</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(); </span><br><span class="line">	<span class="comment">// 执行execute方法进行事务管理</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> tt.execute(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TransactionCallback</span>()&#123;  </span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">doTransaction</span><span class="params">(TransactionStatus status)</span>&#123;  </span><br><span class="line">            updateOperation();  </span><br><span class="line">            <span class="keyword">return</span> resultOfUpdateOperation();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<h4 id="事务管理接口">事务管理接口</h4>
<ul>
<li><strong><code>PlatformTransactionManager</code></strong>：（平台）事务管理器，Spring
事务策略的核心。</li>
<li><strong><code>TransactionDefinition</code></strong>：事务定义属性信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li><strong><code>TransactionStatus</code></strong>：事务运行状态。</li>
</ul>
<h5
id="platformtransactionmanager事务管理接口">PlatformTransactionManager:事务管理接口</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="transactiondefinition事务属性">TransactionDefinition:事务属性</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TransactionDefinition <span class="title function_">withDefaults</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="transactionstatus事务状态">TransactionStatus:事务状态</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务属性">事务属性</h4>
<p>五方面属性：</p>
<ul>
<li>隔离级别</li>
<li>传播行为：<strong>解决业务层方法之间互相调用的事务问题</strong></li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ul>
<h5 id="事务传播行为的种类">事务传播行为的种类</h5>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。</p>
<p>对于事务B，如果当前存在事务A，则B加入A事务；</p>
<p>如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p>
<p>也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且<strong>开启的事务相互独立，互不干扰。</strong></p>
<p>案例：</p>
<p>A：PROPAGATION_REQUIRED B：PROPAGATION_REQUIRES_NEW</p>
<ul>
<li>A回滚，B并不会，因为B隔离于A新开了事务。</li>
<li>B回滚，A会回滚，因为A检测到B的存在并且回滚。</li>
</ul>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<h4 id="transactional注解">Transactional注解</h4>
<p>Transactional(rollbackFor =
Exception.class)：表示事务在执行过程中遇到Exception（包括全部子类），事务自动回滚。</p>
<ul>
<li><span class="citation"
data-cites="Transactional注解作用在类上">@Transactional注解作用在类上</span>：所有的public方法具有该类型的事务属性，</li>
<li><code>@Transactional</code>
注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上
<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</li>
</ul>
<h2 id="springmvc">SpringMVC</h2>
<ul>
<li>模型Model：</li>
<li>视图View：</li>
<li>控制器controller：</li>
</ul>
<p>业务逻辑、数据、显示分离来组织代码。</p>
<p>Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao
层（数据库操作）、Entity 层（实体类）、Controller
层(控制层，返回数据给前台页面)。</p>
<h3 id="核心组件">核心组件</h3>
<ul>
<li><strong><code>DispatcherServlet</code></strong>：<strong>核心的中央处理器</strong>，负责接收请求、分发，并响应给客户端。</li>
<li><strong><code>HandlerMapping</code></strong>：<strong>处理器映射器</strong>，根据
uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和
<code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code></strong>：<strong>处理器适配器</strong>，根据
<code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的
<code>Handler</code>；</li>
<li><strong><code>Handler</code></strong>：<strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code></strong>：<strong>视图解析器</strong>，根据
<code>Handler</code> 返回的逻辑视图 /
视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code>
响应客户端</li>
</ul>
<h3 id="常用注解">常用注解</h3>
<p><span class="citation" data-cites="Controller">@Controller</span></p>
<p>控制器Controller 负责<strong>处理由DispatcherServlet
分发的请求</strong>，它把用户请求的数据经过业务处理层处理之后封装成一个Model
，然后再把该Model 返回给对应的View 进行展示。在SpringMVC
中使用@Controller
，就无需继承特定的类或实现特定的接口，只需使用@Controller
标记一个类是Controller，然后使用@RequestMapping 和@RequestParam
等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller
就能被外界访问到。</p>
<p><span class="citation"
data-cites="RequestMapping">@RequestMapping</span></p>
<p>作用：建立请求URL和处理方法之间的对应关系</p>
<p><span class="citation"
data-cites="RequestMapping可以作用在方法和类上">@RequestMapping可以作用在方法和类上</span></p>
<ul>
<li>作用在类上：第一级的访问目录</li>
<li>作用在方法上：第二级的访问目录</li>
</ul>
<p><span class="citation"
data-cites="RequestMapping的属性">@RequestMapping的属性</span></p>
<ul>
<li>path-指定请求路径的URL</li>
<li>value属性和path属性是一样的</li>
<li>mthod 指定该方法的请求方式</li>
<li>params 指定限制请求参数的条件</li>
<li>headers 发送的请求中必须包含的请求头</li>
</ul>
<p><strong><span class="citation"
data-cites="PathVariable">@PathVariable</span></strong></p>
<p>作用：取出请求中占位符对应的参数</p>
<p><span class="citation"
data-cites="ResponseBody">@ResponseBody</span></p>
<p>作用：<span class="citation"
data-cites="ResponseBody注解通常使用在控制层的方法上">@ResponseBody注解通常使用在控制层的方法上</span>，用于将Controller的方法返回的对象，通过springmvc提供的<code>HttpMessageConverter</code>接口转换为指定格式的数据如：json、xml等，通过Response响应给客户端。</p>
<p>假如是字符串则直接将字符串写到客户端；假如是一个对象，此时会将对象转化为json串然后写到客户端。这里需要注意的是，如果返回对象，按utf-8编码。如果返回String，页面可能出现乱码。因此在注解中我们可以手动修改编码格式，例如@RequestMapping(value="/cat/query",produces="text/html;charset=utf-8")，前面是请求的路径，后面是编码格式。</p>
<h3 id="工作原理">工作原理</h3>
<figure>
<img src="de6d2b213f112297298f3e223bf08f28.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li>客户端（浏览器）发送请求，
<code>DispatcherServlet</code>拦截请求。</li>
<li>找hanlder
<ol type="1">
<li><code>DispatcherServlet</code> 根据请求信息调用
<code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据
<strong>uri</strong> 去匹配查找能处理的
<code>Handler</code>（也就是我们平常说的 <code>Controller</code>
控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code>
一起封装。</li>
<li><code>DispatcherServlet</code> 调用
<code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li>
</ol></li>
<li><code>handler</code>处理后返回的 <code>ModelAndView</code>的处理
<ol type="1">
<li><code>ModelAndView</code>
顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code>
是返回的数据对象，<code>View</code> 是个逻辑上的
<code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的
<code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给
<code>View</code>（视图渲染）。</li>
</ol></li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="统一异常处理">统一异常处理</h3>
<p>推荐使用注解的方式统一异常处理，具体会使用到
<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>
这两个注解 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ResponseEntity：统一返回值定义对象</p></li>
<li><p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code>
<strong>织入异常处理的逻辑（AOP）</strong>当 <code>Controller</code>
中的方法抛出异常的时候，由被<code>@ExceptionHandler</code>
注解修饰的方法进行处理。</p></li>
</ul>
<h2 id="springboot">SpringBoot</h2>
<h3 id="自动装配">自动装配</h3>
<h4 id="概念">概念</h4>
<blockquote>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot
在启动时会扫描 外部引用 jar
包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到
Spring 容器（此处涉及到 JVM 类加载机制与 Spring
的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照
SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
</blockquote>
<p>自动装配流程：</p>
<ol type="1">
<li><p>注解开启<code>@SpringBootApplication</code></p></li>
<li><p>自动加载外部类路径下的<code>META-INF/spring.factories</code>，读取以<strong>EnableAutoConfiguration</strong>的全限定类名对应的值</p>
<figure>
<img src="java面试整理/image-20231129085503815.png"
alt="image-20231129085503815" />
<figcaption aria-hidden="true">image-20231129085503815</figcaption>
</figure></li>
<li><p>导入其它依赖（<span class="citation"
data-cites="Import注解标识">@Import注解标识</span>），或者是@Bean注解</p></li>
</ol>
<h4 id="源码原理">源码原理</h4>
<figure>
<img src="java面试整理/image-20231229113214101.png"
alt="image-20231229113214101" />
<figcaption aria-hidden="true">image-20231229113214101</figcaption>
</figure>
<p><span class="citation"
data-cites="*">@*</span>*SpringBootApplication：以下三个注解的集合**</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot
的自动配置机制</li>
<li><code>@Configuration</code>：允许在上下文中注册额外的 bean
或导入其他配置类</li>
<li><code>@ComponentScan</code>：扫描被<code>@Component</code>
(<code>@Service</code>,<code>@Controller</code>)注解的
bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些
bean。</li>
</ul>
<p><span class="citation"
data-cites="EnableAutoConfiguration:实现自动装配的核心注解">@EnableAutoConfiguration:实现自动装配的核心注解</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AutoConfigurationImportSelector：加载自动装配类</p>
<p>继承体系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoConfigurationImportSelector</code>实现了<code>DeferredImportSelector</code>接口，其顶层接口<code>ImportSelector</code>。</p>
<p>顶级接口实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getAutoConfigurationEntry</code>方法：负责加载自动配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AutoConfigurationEntry</span> <span class="variable">EMPTY_ENTRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>();</span><br><span class="line"></span><br><span class="line">AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">	<span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="built_in">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在
<code>application.properties</code> 或 <code>application.yml</code>
中设置</p></li>
<li><p>用于获取<code>EnableAutoConfiguration</code>注解中的
<code>exclude</code> 和 <code>excludeName</code>。</p>
<figure>
<img src="3d6ec93bbda1453aa08c52b49516c05atplv-k3u1fbpfcp-zoom-1.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p>
<p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有
Spring Boot Starter
下的<code>META-INF/spring.factories</code>都会被读取到。</p></li>
<li><p>不能一次性加载全部配置类，筛选一部分.</p>
<p>有的starter如果启用，<code>@ConditionalOnXXX</code>
就会满足，就能被自动装配</p>
<p>例如,rabbitMQ的依赖信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class="line"><span class="meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用到，就会加载。</p></li>
</ol>
<h5 id="条件注解">条件注解</h5>
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean
的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean
在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL
表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI
存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web
项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项
目的条件下</li>
</ul>
<h3 id="配置文件加载顺序">配置文件加载顺序</h3>
<ol type="1">
<li>同文件夹下：加载application.yml加载application.properties，如果两者存在相同内容，properties文件会对yml文件的相同内容进行覆盖</li>
<li>不同文件夹下：类路径（resources的根目录） -&gt; 类路径下的config文件
-&gt; 项目根路径 -&gt; 项目根路径的config文件夹</li>
</ol>
<p>类路径classpath概念：指的是编译后存在于<strong>本项目[或模块目录]/target/[项目或模块名]/WEB-INF/classes</strong>里。</p>
<h3 id="实现starter">实现starter</h3>
<p>1、在工程里引入 starter 打包相关的依赖。</p>
<p>2、在我们工程内建spring.factories文件，编写我们配置类的全限类名。</p>
<h2 id="springcloud">SpringCloud</h2>
<p>概念：</p>
<ul>
<li>Spring
Cloud是一个微服务系统架构的一站式解决方案，提供的全套的分布式系统解决方案。</li>
<li>Spring
Cloud对微服务基础框架Netflix的多个开源组件进行了封装，<strong>又实现了和Spring
Boot开发框架以及云端平台的集成</strong>。</li>
<li>Spring
Cloud为微服务架构开发涉及的<strong>配置管理，服务治理，熔断机制，智能路由，微代理，控制总线，一次性token，全局一致性锁</strong>，<strong>leader选举，分布式session</strong>，集群状态管理等操作提供了一种简单的开发方式。（贼多，记住几个就行）</li>
<li>Spring Cloud
为开发者提供了<strong>快速构建分布式系统</strong>的工具，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>与分布式系统相关的复杂性</strong>：这种开销包括网络问题,延迟开销,带宽问题,安全问题。</li>
<li><strong>服务发现</strong>：服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录,在该目录中注册服务,然后能够查找并连接到该目录中的服务。</li>
<li><strong>冗余</strong>：分布式系统中的冗余问题。</li>
<li><strong>负载平衡</strong>：负载平衡改善跨多个计算资源的工作负荷,诸如计算机,计算机集群,网络链路,中央处理单元,或磁盘驱动器的分布。</li>
<li><strong>性能问题</strong>：由于各种运营开销导致的性能问题。</li>
<li><strong>部署复杂性</strong>：Devops技能的要求。</li>
</ul>
<h3 id="微服务概念">微服务概念</h3>
<p>本质是一个分布式系统，将单体应用的多个服务拆分成<strong>一个个小的服务单元</strong>，<strong>微服务之间使用HTTP的API进行访问操作</strong>。</p>
<p>每个微服务都<strong>独自运行在自己的进程（或者服务器里）中独立部署</strong>，而且每个微服务可以使用单独的语言开发以及不同的数据库存储。</p>
<p>优点：</p>
<ul>
<li><p>服务的<strong>独立部署</strong>：每个服务都是一个独立的项目，服务之间互不影响，可以独立部署，不依赖于其他服务，耦合性低。</p></li>
<li><p>服务的<strong>快速启动</strong>：拆分之后服务启动的速度必然要比拆分之前快很多，因为依赖的库少了，代码量也少了。</p></li>
<li><p>更加适合<strong>敏捷开发</strong>：敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行。服务拆分可以快速发布新版本，修改哪个服务只需要发布对应的服务即可，不用整体重新发布。（啥是敏捷开发？）</p></li>
<li><p>服务可以<strong>动态按需扩容</strong>：当某个服务的访问量较大时，我们只需要将这个服务扩容即可。</p></li>
<li><p>服务的数据库独立：<strong>分库分表</strong>，正因为与单体架构一样都在一个数据库里面就会给数据库造成压力最好的办法及时分库分表。</p></li>
<li><p>分布式服务集中化管理（说的就是注册中心）。</p>
<p>服务的管理中心对微服务集中化管理，Eureka和Zookeeper和Consul。</p></li>
<li><p>熔断机制</p>
<p>微服务之间相互依赖，一个服务A不可用（超时或者网络延迟），导致调用服务A的其他服务也不可用，导致系统瘫痪（雪崩效应），为了解决这一问题采用“熔断机制”。</p></li>
</ul>
<h3 id="服务熔断">服务熔断</h3>
<p>概念：一种<strong>微服务链路保护机制</strong>。</p>
<p>作用：应对<strong>雪崩效应</strong></p>
<p>过程：当<strong>链路</strong>的某个微服务<strong>不可用或者响应时间太长</strong>时，会进行<strong>服务降级</strong>，进而熔断该节点微服务的调用，并快速返回“错误”的响应信息</p>
<p>当检测到该节点微服务调用响应正常后恢复调用链路。</p>
<p>实现：通过Hystrix实现</p>
<h4 id="服务降级">服务降级</h4>
<p>服务熔断以后，为了不让服务挂掉，自己设立一个fallback回调，返回一个缺省值</p>
<h4 id="hystrix">Hystrix</h4>
<p>介绍：是Netflix针对微服务分布式系统采用的熔断保护中间件，相当于电路中的保险丝。</p>
<p>作用：对相互依赖的服务进行隔离，Hystrix
通过HystrixCommand对调用进行隔离，这样可以<strong>阻止故障的连锁反应</strong>，能够让接口调用<strong>快速失败并迅速恢复正常</strong>，或者回退并<strong>优雅降级</strong>。</p>
<h5 id="如何实现容错">如何实现容错</h5>
<ol type="1">
<li>包裹请求</li>
<li>跳闸机制：当<strong>服务错误率</strong>达到一定阈值时，自动跳闸或者手动跳闸</li>
<li>资源隔离：为每个服务依赖都维护了一个小型的线程池</li>
<li>监控</li>
<li>回退机制（降级）：</li>
<li>自我修复：</li>
</ol>
<h3 id="rpc实现原理">RPC实现原理</h3>
<figure>
<img
src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54ix5ZCD6bG86aW855qE54yr,size_13,color_FFFFFF,t_70,g_se,x_16.png"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54ix5ZCD6bG86aW855qE54yr,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p>
<h4 id="建立通信">建立通信</h4>
<p>首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。</p>
<p>主要是通过在<strong>客户端和服务器之间建立TCP连接</strong>，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p>
<p>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。</p>
<h4 id="服务寻址">服务寻址</h4>
<p>问题描述：A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。通常情况下我们需要提供B机器（<strong>主机名或IP地址</strong>）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。</p>
<p>服务提供者角度：</p>
<ul>
<li>把自己的服务注册到注册中心</li>
<li>时刻监测自己服务，管理自己的服务
<ul>
<li>当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；</li>
<li>服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果<strong>一段时间未收到来自服务提供者的心跳</strong>后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉</li>
</ul></li>
</ul>
<p>服务调用者角度：</p>
<ul>
<li>根据自己需要调用的服务，去注册中心查找对应服务提供者的信息</li>
<li>调用者下线的时候，取消对服务的订阅</li>
</ul>
<h4 id="网络传输">网络传输</h4>
<p>序列化：</p>
<p>当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行<strong>序列化</strong>（Serialize）或者<strong>编组</strong>（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</p>
<p>反序列化：</p>
<p>当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,
通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</p>
<h4 id="服务调用">服务调用</h4>
<h3 id="feign">Feign</h3>
<ul>
<li><p>Feign 运行在消费者端的，使用 Ribbon 进行负载均衡，所以 Feign
直接内置了 Ribbon</p></li>
<li><p>Feign是Spring
Cloud组件中的一个<strong>轻量级RESTful的HTTP服务客户端</strong></p></li>
<li><p>Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。</p></li>
<li><p>Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</p></li>
<li><p>Feign本身不支持Spring
MVC的注解，它有一套自己的注解（和OpenFeign的区别）</p></li>
</ul>
<h1 id="jvm">JVM</h1>
<h2 id="java内存区域">java内存区域</h2>
<p><img src="java面试整理/image-20231126210202537.png" alt="image-20231126210202537" style="zoom:80%;" /></p>
<ul>
<li>堆：</li>
<li>方法区：</li>
<li>虚拟机（方法）栈：</li>
<li>本地方法栈：</li>
<li>程序计数器：</li>
</ul>
<h3 id="运行时数据区">运行时数据区</h3>
<p><img src="java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:67%;" /></p>
<p>线程私有：</p>
<ul>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ul>
<p>线程共享：</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<p>运行时数据区大小非常弹性，以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展
。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p>
<h4 id="程序计数器">程序计数器</h4>
<p>一块较小的内存区间，可以看成线程在字节码文件上运行的<strong>行号指示器</strong>。</p>
<p>作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器，实现代码流程控制:如：顺序执行、选择、循环、异常处理。</li>
<li>多线程情况下，程序计数器用于记录当前线程执行到哪一位置，方便接下来线程上下文切换的时候能快速定位到代码上次运行到哪。</li>
</ul>
<p>注意：</p>
<p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code>
的内存区域，它的<strong>生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h4 id="java虚拟机栈">java虚拟机栈</h4>
<p>所有的java方法调用都是通过栈来实现的。</p>
<p>栈内基本元素单位：<strong>栈帧</strong>，方法对应栈帧，每调用一个方法，一个栈帧压栈，调用结束，栈帧弹出。</p>
<p>栈帧的结构：</p>
<p><img src="image-20230922152758136.png" alt="image-20230922152758136" style="zoom: 67%;" /></p>
<ul>
<li><p>局部变量表：存放了<strong>编译期可知</strong>的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference
类型，它不同于对象本身，可能是一个<strong>指向对象起始地址的引用指针</strong>，也可能是指向一个<strong>代表对象的句柄</strong>或其他与此对象相关的位置）</p></li>
<li><p>操作数栈：存储方法执行过程中的中间计算结果，计算过程中产生的临时变量。</p></li>
<li><p>动态链接：应用于方法间互相调用的场景。当一个方法要调用另一个方法时需要将常量池中指向方法区的方法的<strong>符号引用转化为其在内存地址中的直接引用。</strong></p>
<ul>
<li>Class
文件的常量池里保存有大量的符号引用比如方法引用的符号引用。</li>
</ul>
<figure>
<img src="jvmimage-20220331175738692.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>方法返回地址：jaav两种返回方式：return、异常抛出。这两种方法都会使得栈帧抛出。</p></li>
</ul>
<p>栈帧的生命周期 = 调用方法的生命周期</p>
<p>栈可能会报的错</p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong>
若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java
虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code>
错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong>
如果栈的内存大小可以动态扩展，
如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h4 id="本地方法栈">本地方法栈</h4>
<p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行
Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native
方法服务。</strong></p>
<p>其它和栈类似。</p>
<h4 id="堆">堆</h4>
<p>管理内存最大的一块，主要目的就是存放对象实例以及数组。</p>
<blockquote>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT
编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从
JDK 1.7
开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
</blockquote>
<p>又称GC堆，分为老年代、新生代再细致一点：Eden、Survivor、Old
等空间。</p>
<p><img src="hotspot-heap-structure.png" alt="堆内存结构" style="zoom: 80%;" /></p>
<p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间)
取代，元空间使用的是本地内存。</strong></p>
<p>对象分配流程：</p>
<p>eden区出生，每次垃圾回收之后，对象如果还存活，年龄会+1，并且会根据年龄分配到S1、S0区。</p>
<p>堆可能出现的异常：</p>
<ul>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong>：当
JVM
花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong>
:假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象,
就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值</li>
</ul>
<h4 id="方法区">方法区</h4>
<p>是一种概念，不同的虚拟机其方法区实现不同。</p>
<p><img src="image-20230922165020342.png" alt="image-20230922165020342" style="zoom:67%;" /></p>
<p>永久代替换成元空间的原因：</p>
<ol type="1">
<li>永久代是jvm固定设置大小的，无法调整元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
<ul>
<li>你可以使用 <code>-XX：MaxMetaspaceSize</code>
标志设置最大元空间大小，默认值为
unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code>
调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace
将根据运行时的应用程序需求动态地重新调整大小。</li>
</ul></li>
<li>可存的类会多</li>
</ol>
<p>方法区常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>
<h4 id="运行时常量区">运行时常量区</h4>
<p>Class
文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic
Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>《深入理解 Java 虚拟机》7.34
节第三版对符号引用和直接引用的解释如下：</p>
<figure>
<img src="image-20230922172054361.png" alt="image-20230922172054361" />
<figcaption aria-hidden="true">image-20230922172054361</figcaption>
</figure>
<p>当常量池满了，也会抛出<code>OutOfMemoryError</code> 错误。</p>
<h4 id="字符串常量池">字符串常量池</h4>
<p>JVM 为了提升性能和减少内存消耗针对字符串（String
类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="直接内存区">直接内存区</h4>
<p>是一种特殊的内存缓冲区，是通过JNI的方式在<strong>本地内存</strong>分配。</p>
<h3 id="hotspot虚拟机">HotSpot虚拟机</h3>
<h4 id="对象的创建">对象的创建</h4>
<h5 id="类加载检查">类加载检查</h5>
<p>虚拟机遇到一条 new
指令时，去检查这个指令的参数是否能在常量池中定位到这个类的符号引用</p>
<p>然后判断这个对象所在的类有无加载、解析和初始化过，如果没有，执行类加载过程。</p>
<h5 id="分配内存">分配内存</h5>
<p>指针碰撞</p>
<ul>
<li>适用场合：堆内存规整、一片连续的内存空间。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个<strong>分界指针</strong>，为对象分配内存只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的GC收集器：Serial, ParNew</li>
</ul>
<p>空闲列表</p>
<ul>
<li>适用场合：堆内存不规整、碎片化</li>
<li>原理：将碎片化的空间串成一个链表，又虚拟机来维护，分配内存的时候，为对象选取一块差不多大小的内存块分配。</li>
<li>使用该分配方式的GC收集器：CMS</li>
</ul>
<h6 id="内存分配并发问题">内存分配并发问题</h6>
<p>虚拟机创建对象保证线程安全的手段：</p>
<ul>
<li>CAS + 失败重试：</li>
<li>TLAB：为每一个线程预先在eden区分配一块内存，然后线程创建对象的时候，jvm首先在TLAB分配，当对象大于
TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS
进行内存分配</li>
</ul>
<h5 id="初始化零值">初始化零值</h5>
<p>这一步操作保证了对象的实例字段在 Java
代码中可以<strong>不赋初始值就直接使用</strong>。</p>
<h5 id="设置对象头">设置对象头</h5>
<p>关于对象的一些信息存入对象头，如：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的
GC 分代年龄等信息。</p>
<h5 id="执行init">执行init</h5>
<p>从虚拟机的视角来看，一个新的对象已经产生了。</p>
<p>从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code>
方法还没有执行，所有的字段都还为零。</p>
<p>此时执行init方法，按照程序员意愿初始化。</p>
<p>这里init方法相当于构造函数。</p>
<h4 id="对象内存布局">对象内存布局</h4>
<p><strong>对象头</strong></p>
<ul>
<li>存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志等等</li>
<li>类型指针：指向对象自己类的元数据，用于标识自己是哪个类的产物。</li>
</ul>
<p><strong>实例数据</strong></p>
<p>对象的属性等等。</p>
<p><strong>对齐补充</strong></p>
<blockquote>
<p><strong>填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong>
因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8
字节的整数倍，换句话说就是对象的大小必须是 8
字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2
倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
</blockquote>
<h4 id="对象的访问">对象的访问</h4>
<p><strong>句柄</strong></p>
<p><img src="access-location-of-object-handle.png" alt="对象的访问定位-使用句柄" style="zoom:67%;" /></p>
<p><strong>直接指针</strong></p>
<p><img src="access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针" style="zoom:67%;" /></p>
<h3 id="java引用类型">java引用类型</h3>
<p>强度自上而下递减。</p>
<p><strong>强引用</strong></p>
<p><code>String x = new Striong("666");</code>此时x就是强引用。</p>
<p>不会回收被此引用引用的对象，堆内存满了直接抛出<code>OutOfMemoryError</code></p>
<p><strong>软引用</strong></p>
<p>可有可无的引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p>
<p>配合引用队列使用，队列存的都是被垃圾回收的软引用对象。</p>
<p>作用：加速jvm的内存回收速度。</p>
<p><strong>弱引用</strong></p>
<p>垃圾回收器遇到弱引用就回收，不会管堆内存大小。</p>
<p>应用：ThreadLocal等</p>
<p><strong>虚引用</strong></p>
<p>目的：跟踪对象被垃圾回收的活动。</p>
<p>注意：必须配合引用队列，当一个对象即将被回收，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p>
<h2 id="垃圾回收">垃圾回收</h2>
<h3 id="内存分配和回收原则">内存分配和回收原则</h3>
<h4 id="对象优先在eden区分配">对象优先在eden区分配</h4>
<p>大多数情况下，对象在新生代中 Eden
区分配。eden区空间不够的时候，虚拟机发起一次 Minor gc。</p>
<p>案例：</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">		allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行时带上虚拟机参数：-XX:+PrintGCDetails</li>
</ul>
<p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p>
<figure>
<img src="28954286.jpg" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>eden区已经分配完全，</p>
<p>假如我们再为 <code>allocation2</code>
分配内存<code>allocation2 = new byte[900*1024];</code></p>
<figure>
<img src="28128785.jpg" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>给 <code>allocation2</code> 分配内存的时候 Eden
区内存几乎已经被分配完了，当 Eden
区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现
<code>allocation1</code> 无法存入 Survivor 空间，所以只好通过
<strong>分配担保机制</strong>
把新生代的对象提前转移到老年代中去，老年代上的空间足够存放
<code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC
后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden
区分配内存。可以执行如下代码验证：</p>
<h5 id="空间分配担保">空间分配担保</h5>
<p>目的：确保Minor
GC之前老年代本身还有容纳<strong>所有新生代对象</strong>的剩余空间。</p>
<blockquote>
<p>JDK 6 Update 24 之前，在发生 Minor GC
之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次
Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看
<code>-XX:HandlePromotionFailure</code>
参数的设置值是否允许担保失败(Handle Promotion
Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次
Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者
<code>-XX: HandlePromotionFailure</code>
设置不允许冒险，那这时就要改为进行一次 Full GC。</p>
<p>JDK 6 Update 24
之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行
Minor GC，否则将进行 Full GC。</p>
</blockquote>
<h4 id="大对象进入老年代">大对象进入老年代</h4>
<p>目的：减少新生代的gc频率。</p>
<p>根据不同的虚拟机以及垃圾回收器决定操作：</p>
<ul>
<li><p>G1垃圾回收器会根据-XX:G1HeapRegionSize参数设置的堆区域大小和-XX:G1MixedGCLiveThresholdPercent参数设置的阈值，来决定哪些对象会直接进入老年代。</p></li>
<li><p>Parallel
Scavenge垃圾回收器中，默认情况下，并没有一个固定的阈值(XX:ThresholdTolerance是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。</p></li>
</ul>
<h4 id="长期存活对象进入老年代">长期存活对象进入老年代</h4>
<p>对象创建在eden区 ——&gt; 第一次Minor GC后仍然存活 ——&gt;
分配到survivor(年龄初始设为1岁) ——&gt;
在survivor区每熬过一岁，年龄增加一次 ——&gt;
年龄增加到老年代年龄阈值（不同的虚拟机垃圾回收器有不同的阈值，默认15）</p>
<p>动态年龄计算：</p>
<p>修正（<a
target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552open
in new window</a>）：“Hotspot
遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了
survivor 区的 50% 时（默认值是 50%，可以通过
<code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a
target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199open
in new window</a> ），取这个年龄和 MaxTenuringThreshold
中更小的一个值，作为新的晋升年龄阈值”。</p>
<p>jdk8
官方文档引用：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
。</p>
<figure>
<img src="image-20210523201742303.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"><span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">total += sizes[age];</span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="gc收集方式区域">gc收集方式区域</h4>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old
GC）：只对老年代进行垃圾收集。需要注意的是 Major GC
在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h3 id="死亡对象判断方法">死亡对象判断方法</h3>
<h4 id="引用计数法">引用计数法</h4>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<h5 id="循环引用问题">循环引用问题</h5>
<figure>
<img src="object-circular-reference.png" alt="对象之间循环引用" />
<figcaption aria-hidden="true">对象之间循环引用</figcaption>
</figure>
<p>当两个对象都不用的时候，互相都有个引用指针指向彼此，也不会造成gc。</p>
<h4 id="可达性分析算法">可达性分析算法</h4>
<p>通过一系列称为 GC Roots
的对象结点作为起点，从这些结点开始往下搜索，走的路径就是引用链，这个引用链上的结点都不会被gc，未达到的结点可以被gc清除。</p>
<h5 id="可作为gc-roots的结点">可作为gc roots的结点</h5>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
<li>JNI（Java Native Interface）引用的对象</li>
</ul>
<h5
id="对象可以被回收不一定会被回收"><strong>对象可以被回收，不一定会被回收</strong></h5>
<p><strong>至少经历两次</strong>标记过程，对象才会彻底死亡。</p>
<p>可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行
<code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code>
方法，或 <code>finalize</code>
方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<h3 id="废弃常量">废弃常量</h3>
<p>字符串常量：没有String对象引用的字符串称为废弃（字符串）常量。</p>
<h3 id="无用的类">无用的类</h3>
<ul>
<li>所有实例对象都被回收</li>
<li>加载该类的类加载器已被回收</li>
<li>该类对应的<code>Class</code>对象，没有被引用</li>
</ul>
<h3 id="垃圾回收算法">垃圾回收算法</h3>
<h4 id="标记清除">标记清除</h4>
<p>原理：遍历所有对象，标记不需要回收的对象，标记完成后统一回收掉所有没有被标记的对象。</p>
<p>缺陷：</p>
<ol type="1">
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会<strong>产生大量</strong>不连续的<strong>内存碎片</strong>。</li>
</ol>
<h4 id="标记复制">标记复制</h4>
<p>原理：内存均分成两块，每次使用其中的一块，当一块内存用完以后，标记所有不需要回收的对象，复制到另一半空闲内存中，然后清理这一半内存。</p>
<p>缺陷：</p>
<ol type="1">
<li>可用内存变小（仅有50%）</li>
<li>不适用老年代：因为存活的对象数量太多，复制效率低下。</li>
</ol>
<h4 id="标记整理">标记整理</h4>
<p>原理：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>缺陷：效率低，仅适用老年代这样低gc频率的场景</p>
<p><img src="mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;" /></p>
<h4 id="分代收集">分代收集</h4>
<p>新生代：标记-复制算法</p>
<ul>
<li>每次收集都会有大量对象死去</li>
</ul>
<p>老年代：“标记-清除”或“标记-整理”</p>
<ul>
<li>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保</li>
</ul>
<h3 id="垃圾收集器">垃圾收集器</h3>
<ul>
<li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li>
<li>JDK 9 ~ JDK20: G1</li>
</ul>
<h4 id="serial-收集器">Serial 收集器</h4>
<p>单线程；</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<figure>
<img src="serial-garbage-collector.png" alt="Serial 收集器" />
<figcaption aria-hidden="true">Serial 收集器</figcaption>
</figure>
<h4 id="parnew-收集器">ParNew 收集器</h4>
<p>Serial 多线程版本；</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<figure>
<img src="parnew-garbage-collector.png" alt="ParNew 收集器" />
<figcaption aria-hidden="true">ParNew 收集器</figcaption>
</figure>
<h4 id="cms-收集器">CMS 收集器</h4>
<p>CMS（Concurrent Mark
Sweep）是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，注重用户体验。</p>
<p>并发收集器，能和用户线程一起工作。</p>
<p>采用标记-清除算法。</p>
<p>gc过程：</p>
<ol type="1">
<li>初始标记：暂停所有的其他线程，并记录下直接与 root
相连的对象，速度很快 ；</li>
<li>并发标记：同时开启用户线程和gc线程，通过闭包结构，记录可达对象。
<ul>
<li>注意：由于用户线程也在运行，无法保证在这期间有新的对象被GC
roots直接或者间接引用，因此要有重新标记</li>
</ul></li>
<li>重新标记：为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，停顿时间略长。</li>
<li>并发清除：</li>
</ol>
<blockquote>
<p>闭包：能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/局部变量/9844788?fromModule=lemma_inlink">局部变量</a>，所以闭包可以理解成“定义在一个<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/函数/301912?fromModule=lemma_inlink">函数</a>内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
</blockquote>
<p>缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h4 id="g1-收集器">G1 收集器</h4>
<p><strong>G1 (Garbage-First)
是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器.
以极高概率满足 GC
停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>特征：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用
CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短
Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC
动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1
可以不需要其他收集器配合就能<strong>独立管理整个 GC
堆</strong>，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1
从<strong>整体</strong>来看是<strong>基于“标记-整理”算法实现的收集器</strong>；从<strong>局部</strong>上来看是基于“<strong>标记-复制</strong>”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS
的另一个大优势，<strong>降低停顿时间</strong>是 G1 和 CMS
共同的关注点，但 G1
除了追求低停顿外，还能建立可预测的停顿时间模型，<strong>能让使用者明确指定在一个长度为
M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N
毫秒。</strong></li>
</ul>
<p>gc过程：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<figure>
<img src="g1-garbage-collector.png" alt="G1 收集器" />
<figcaption aria-hidden="true">G1 收集器</figcaption>
</figure>
<p>后台维护了<strong>优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的
Region(这也就是它的名字 Garbage-First 的由来)** 。</p>
<h2 id="类加载过程">类加载过程</h2>
<h3 id="类声明周期">类声明周期</h3>
<p><img src="lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:67%;" /></p>
<h3 id="类加载过程-1">类加载过程</h3>
<h4 id="加载">加载</h4>
<ol type="1">
<li>通过全类名获取定义此类的<strong>二进制字节流</strong>：<code>ZIP</code>、
<code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如
<code>JSP</code>...</li>
<li>将字节流所代表的<strong>静态存储结构转换为方法区的运行时数据结构</strong>。</li>
<li>内存中生成一个代表该类的 <code>Class</code> 对象</li>
</ol>
<p>交由类加载器完成，具体交由哪个类加载器由<strong>双亲委派模型</strong>
决定</p>
<p><strong>每个 Java 类都有一个引用指向加载它的
<code>ClassLoader</code>。</strong></p>
<ul>
<li>数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM
在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取
<code>ClassLoader</code> 的时候和该数组的元素类型的
<code>ClassLoader</code> 是一致的。</li>
</ul>
<h4 id="链接">链接</h4>
<h5 id="验证">验证</h5>
<p>过程：</p>
<ol type="1">
<li>文件格式验证（Class 文件格式检查）</li>
<li>元数据验证（字节码语义检查）</li>
<li>字节码验证（程序语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ol>
<figure>
<img src="class-loading-process-verification.png"
alt="验证阶段示意图" />
<figcaption aria-hidden="true">验证阶段示意图</figcaption>
</figure>
<p>验证是否是必须经过的流程？</p>
<p>否，使用 <code>-Xverify:none</code>
参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h6 id="符号引用验证">符号引用验证</h6>
<p>符号引用验证的主要目的是<strong>确保解析阶段能正常执行</strong>。</p>
<p>如果无法通过符号引用验证，JVM 会抛出异常，比如：</p>
<ul>
<li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li>
<li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li>
<li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li>
</ul>
<h5 id="准备">准备</h5>
<p><strong>正式为类变量分配内存并设置类变量初始值的阶段</strong>。</p>
<p>注意：</p>
<ol type="1">
<li>这时候只对<strong>类变量</strong>进行内存分配（ Class Variables
，即静态变量，被 <code>static</code>
关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在
Java 堆中。</li>
<li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong>
中进行分配。JDK 7 之前，HotSpot
使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 在 JDK 7
及之后，HotSpot
已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候<strong>类变量则会随着
Class 对象一起存放在 Java 堆</strong>中。</li>
<li>这里所设置的初始值"通常情况"下是数据类型默认的零值（如
0、0L、null、false
等），比如我们定义了<code>public static int value=111</code> ，那么
value 变量在准备阶段的初始值就是 0 而不是
111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final
关键字<code>public static final int value=111</code> ，那么准备阶段
value 的值就被赋值为 111。</li>
</ol>
<p>零值表：</p>
<figure>
<img src="基本数据类型的零值.png" alt="基本数据类型的零值" />
<figcaption aria-hidden="true">基本数据类型的零值</figcaption>
</figure>
<h5 id="解析">解析</h5>
<p><strong>将常量池内的符号引用替换为直接引用的过程。</strong></p>
<p>解析目标：针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符等</p>
<p>符号引用就是就是得到类或者字段、方法在<strong>内存中的指针或者偏移量</strong>。</p>
<blockquote>
<p>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java
虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
</blockquote>
<h4 id="初始化">初始化</h4>
<p><strong>初始化阶段是执行初始化方法
<code>&lt;clinit&gt; ()</code>方法的过程</strong>，这一步之后，jvm真正开始执行类定义中的java程序代码。</p>
<p>六种情况必须初始化：</p>
<ol type="1">
<li><p>当遇到 <code>new</code>、
<code>getstatic</code>、<code>putstatic</code> 或
<code>invokestatic</code> 这 4 条字节码指令时：</p>
<ul>
<li><p>当 jvm 执行 <code>new</code>
指令时会初始化类。即当程序创建一个类的实例对象。</p></li>
<li><p>当 jvm 执行 <code>getstatic</code>
指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</p></li>
<li><p>当 jvm 执行 <code>putstatic</code>
指令时会初始化类。即程序给类的静态变量赋值。</p></li>
<li><p>当 jvm 执行 <code>invokestatic</code>
指令时会初始化类。即程序调用类的静态方法。</p></li>
</ul></li>
<li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如
<code>Class.forname("...")</code>, <code>newInstance()</code>
等等。如果类没初始化，需要触发其初始化。</p></li>
<li><p>初始化一个类，如果其父类还未初始化，则<strong>先触发父类</strong>的<strong>初始化</strong>。</p></li>
<li><p>当虚拟机启动时，用户需要定义一个要执行的主类 (包含
<code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</p></li>
<li><p><code>MethodHandle</code> 和 <code>VarHandle</code>
可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用
<code>findStaticVarHandle</code> 来初始化要调用的类。</p></li>
<li><p>当一个接口中定义了 JDK8 新加入的默认方法（被 default
关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li>
</ol>
<h2 id="类加载器">类加载器</h2>
<blockquote>
<p>类加载器是一个负责加载类的对象。<code>ClassLoader</code>
是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p>
<p>每个 Java 类都有一个引用指向加载它的
<code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code>
创建的，而是 JVM
在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取
<code>ClassLoader</code> 的时候和该数组的元素类型的
<code>ClassLoader</code> 是一致的。</p>
</blockquote>
<p>作用：加载java类的字节码到jvm中（在内存生成一个该类的class对象）。</p>
<h3 id="类加载器加载规则">类加载器加载规则</h3>
<p><strong>动态加载：</strong>按需加载。</p>
<ul>
<li><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。</p></li>
<li><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。<strong>对于一个类加载器来说，相同二进制名称的类只会被加载一次。</strong></p></li>
</ul>
<h3 id="三个重要类加载器">三个重要类加载器</h3>
<ul>
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由
C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK
内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的
<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等
jar 包和类）以及被
<code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载
<code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被
<code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用
classpath 下的所有 jar 包和类。</li>
</ul>
<blockquote>
<p><strong><code>rt.jar</code></strong>：rt
代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc
里面看到的所有的类的类文件。也就是说，我们常用内置库
<code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</p>
<p>Java 9
引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform
class loader）。Java SE 中除了少数几个关键模块，比如说
<code>java.base</code>
是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p>
</blockquote>
<p><img src="class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom:67%;" /></p>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM
自身的一部分之外，<strong>其他所有的类加载器都是在 JVM
外部实现的，并且全都继承自
<code>ClassLoader</code>抽象类。</strong>这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<h4 id="自定义类加载器">自定义类加载器</h4>
<p>自定义类加载器需要继承<code>ClassLoader</code>抽象类。其中两个关键方法：</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，<strong>实现了双亲委派机制</strong>
。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为
true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code>
方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
</ul>
<h3 id="双亲委派模型">双亲委派模型</h3>
<p>具体的类用哪一个类加载器加载，由双亲委派模型决定：</p>
<ul>
<li><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p></li>
<li><p><strong>每个 <code>ClassLoader</code>
实例都有一个相关的父类加载器。</strong></p></li>
<li><p>需要查找类或资源时，<code>ClassLoader</code>
实例会在试图亲自查找类或资源之前，<strong>将搜索类或资源的任务委托给其父类加载器。</strong></p>
<ul>
<li>虚拟机中被称为 "bootstrap class
loader"的内置类加载器本身没有父类加载器，但是可以作为
<code>ClassLoader</code> 实例的父类加载器。</li>
</ul></li>
</ul>
<p>父子关系的实现——合成复用原则：</p>
<p>类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好处：</p>
<p>保证了 Java 程序的稳定运行，可以避免类的重复加载。</p>
<ul>
<li><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：</p>
<ul>
<li><p>类的全名</p></li>
<li><p>是否由同一个类加载器加载</p></li>
</ul></li>
</ul>
<blockquote>
<p>比如我们编写一个称为 <code>java.lang.Object</code>
类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code>
类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code>
类，而不是你写的 <code>Object</code> 类。这是因为
<code>AppClassLoader</code> 在加载你的 <code>Object</code>
类时，会委托给 <code>ExtClassLoader</code> 去加载，而
<code>ExtClassLoader</code> 又会委托给
<code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>
发现自己已经加载过了 <code>Object</code>
类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>
</blockquote>
<h4 id="执行流程">执行流程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>检查是否加载过：每个父加载器都要走一遍这个流程</li>
<li>类加载器在进行类加载的时候，它首先<strong>不会自己去尝试加载这个类</strong>，<strong>而是把这个请求委派给父类加载器去完成</strong>（调用父加载器
<code>loadClass()</code>方法来加载类）。
<ul>
<li>当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的
<code>findClass()</code> 方法来加载类）。</li>
</ul></li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个
<code>ClassNotFoundException</code> 异常。</li>
</ol>
<h4 id="如何打破">如何打破</h4>
<p>重写 <code>loadClass()</code>方法：</p>
<ul>
<li>原因：类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器
<code>loadClass()</code>方法来加载类）。</li>
</ul>
<p>案例：</p>
<p>Tomcat 服务器为了能够优先加载 Web
应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器
<code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web
应用之间的类实现隔离的具体原理。</p>
<p>Tomcat类加载器层次：</p>
<p><img src="tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构" style="zoom:67%;" /></p>
<ul>
<li>CommonClassLoader<code>对应</code><Tomcat>/common/*</li>
<li>CatalinaClassLoader<code>对应</code><Tomcat >/server/*</li>
<li>SharedClassLoader<code>对应</code><Tomcat >/shared/*</li>
<li>WebAppClassloader<code>对应</code><Tomcat >/webapps/<app>/WEB-INF/*</li>
</ul>
<p>自上而下分析：</p>
<ol type="1">
<li><code>CommonClassLoader</code>作为 <code>CatalinaClassLoader</code>
和 <code>SharedClassLoader</code>
的父加载器。<code>CommonClassLoader</code> 能加载的类都可以被
<code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code>
使用。因此，<code>CommonClassLoader</code>
是为了实现公共类库（可以被所有 Web 应用和 Tomcat
内部组件使用的类库）的共享和隔离。</li>
<li><code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code>
能加载的类则与对方相互隔离。<code>CatalinaClassLoader</code> 用于加载
Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web
应用的类。<code>SharedClassLoader</code> 作为
<code>WebAppClassLoader</code> 的父加载器，专门来加载 Web
应用之间共享的类比如 Spring、Mybatis。</li>
<li>每个 Web 应用都会创建一个单独的
<code>WebAppClassLoader</code>，并在启动 Web
应用的线程里设置线程线程上下文类加载器为
<code>WebAppClassLoader</code>。各个 <code>WebAppClassLoader</code>
实例之间相互隔离，进而实现 Web 应用之间的类隔。</li>
</ol>
<p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。</p>
<ol type="1">
<li><p>SPI 中，SPI 的接口（如 <code>java.sql.Driver</code>）是由 Java
核心库提供的，由<code>BootstrapClassLoader</code> 加载。而 SPI
的实现（如<code>com.mysql.cj.jdbc.Driver</code>）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载SPI
的接口的类加载器（<code>BootstrapClassLoader</code>）也会用来加载SPI
的实现。按照双亲委派模型，<code>BootstrapClassLoader</code> 是无法找到
SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。</p></li>
<li><p>假设我们的项目中有 Spring 的 jar 包，由于其是 Web
应用之间共享的，因此会由 <code>SharedClassLoader</code> 加载（Web
服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了
Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring
的类加载器（也就是
<code>SharedClassLoader</code>）也会用来加载这些业务类。但是业务类在 Web
应用目录下，不在 <code>SharedClassLoader</code> 的加载路径下，所以
<code>SharedClassLoader</code> 无法找到业务类，也就无法加载它们。</p>
<ul>
<li><p><strong>线程上下文类加载器</strong>解决：当 Spring
需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。</p>
<p>每个 Web 应用都会<strong>创建一个单独的
<code>WebAppClassLoader</code></strong>，并在启动 Web
应用的线程里设置线程线程上下文类加载器为
<code>WebAppClassLoader</code>。这样就可以让高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（
<code>WebAppClassLoader</code>）来加载业务类，破坏了 Java
的类加载委托机制，让应用<strong>逆向使用类加载器</strong>。</p></li>
</ul></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2023/07/31/java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">https://vlsmhd.github.io/2023/07/31/java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/07/leetcode%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode脑筋急转弯题目专项训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leetcode脑筋急转弯题目专项训练</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/24/2023%E5%B9%B47%E8%87%B38%E6%9C%88%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="2023年7至8月第六届字节青训营学习记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2023年7至8月第六届字节青训营学习记录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">71</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">几种基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">基本类型和包装类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">包装类型的缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">1.1.4.</span> <span class="toc-text">自动装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.1.5.</span> <span class="toc-text">浮点数运算的精度丢失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">成员变量与局部变量的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">静态方法为什么不能调用非静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.2.</span> <span class="toc-text">重载和重写有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.3.</span> <span class="toc-text">深拷贝和浅拷贝区别，什么是引用拷贝？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">1.4.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84equals%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">String的equals()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">hashCode() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">hashCode存在的意义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">1.5.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stringstringbufferstringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.</span> <span class="toc-text">String、StringBuffer、StringBuilder
的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">String 为什么是不可变的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder"><span class="toc-number">1.5.3.</span> <span class="toc-text">字符串拼接用“+” 还是
StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">字符串常量池的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string-s1-new-stringabc%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">String s1 &#x3D;
new String(&quot;abc&quot;);这句话创建了几个字符串对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%9A%84intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">String的intern
方法有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.6.</span> <span class="toc-text">String
类型的变量和常量做“+”运算时发生了什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exception-%E5%92%8C-error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">Exception 和 Error
有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.6.2.</span> <span class="toc-text">Throwable 类常用方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">try-catch-finally 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">1.6.4.</span> <span class="toc-text">finally
中的代码是否一定会执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally"><span class="toc-number">1.6.5.</span> <span class="toc-text">使用
try-with-resources 代替try-catch-finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.6.6.</span> <span class="toc-text">异常使用有哪些需要注意的地方？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">泛型的使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">项目中哪里用到了泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.8.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">获取 Class 对象的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">反射基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">1.9.2.</span> <span class="toc-text">注解的解析方法有哪几种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi"><span class="toc-number">1.9.3.</span> <span class="toc-text">SPI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.10.</span> <span class="toc-text">序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.11.</span> <span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">1.12.</span> <span class="toc-text">比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#comparator"><span class="toc-number">1.12.1.</span> <span class="toc-text">Comparator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">排序一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">排序二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">排序对象数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#comparable"><span class="toc-number">1.12.2.</span> <span class="toc-text">Comparable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.</span> <span class="toc-text">本地方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-number">2.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist"><span class="toc-number">2.1.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">各类操作的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%AE%A1%E7%AE%97api"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">集合计算API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E9%9B%86"><span class="toc-number">2.1.1.3.1.</span> <span class="toc-text">交集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E9%9B%86"><span class="toc-number">2.1.1.3.2.</span> <span class="toc-text">并集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E9%9B%86"><span class="toc-number">2.1.1.3.3.</span> <span class="toc-text">补集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">部分源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.1.4.1.</span> <span class="toc-text">扩容机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist"><span class="toc-number">2.1.2.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%88%E7%8E%87-1"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">各类操作的效率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist%E4%B8%8Earraylist%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.</span> <span class="toc-text">LinkedList与ArrayList区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue"><span class="toc-number">2.2.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#arraydeque-%E4%B8%8E-linkedlist-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">ArrayDeque 与 LinkedList
的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap"><span class="toc-number">2.3.</span> <span class="toc-text">Hash&amp;Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.1.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">HashMap 的长度为什么是 2
的幂次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%8C%96%E9%98%88%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF8"><span class="toc-number">2.3.3.</span> <span class="toc-text">树化阈值为什么是8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E6%98%AF0.75"><span class="toc-number">2.3.4.</span> <span class="toc-text">为什么负载因子是0.75</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E5%92%8C-hashset-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.5.</span> <span class="toc-text">HashMap 和 HashSet 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="toc-number">2.3.6.</span> <span class="toc-text">HashSet 如何检查重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treemap-%E7%9B%B8%E6%AF%94%E4%BA%8Ehashmap%E7%89%B9%E6%80%A7"><span class="toc-number">2.3.7.</span> <span class="toc-text">TreeMap 相比于HashMap特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.8.</span> <span class="toc-text">HashMap 常见的遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">2.3.9.</span> <span class="toc-text">hashmap如何解决哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.9.1.</span> <span class="toc-text">hash算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.9.2.</span> <span class="toc-text">解决hash冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">2.3.9.2.1.</span> <span class="toc-text">开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.9.2.1.1.</span> <span class="toc-text">删除元素过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AF%BB%E5%9D%80%E6%B3%95%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">2.3.9.2.2.</span> <span class="toc-text">链式寻址法（拉链法）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.10.</span> <span class="toc-text">HashMap底层源码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.10.1.</span> <span class="toc-text">构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.10.2.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.10.3.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize%E6%89%A9%E5%AE%B9"><span class="toc-number">2.3.10.4.</span> <span class="toc-text">resize扩容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">2.4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset%E4%B8%8Etreeset%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">HashSet与TreeSet区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">程序计数器为什么线程私有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">3.1.4.</span> <span class="toc-text">虚拟机栈和本地方法栈为什么是私有的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.1.5.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">3.1.6.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.7.</span> <span class="toc-text">线程的生命周期和状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.7.1.</span> <span class="toc-text">java中线程状态与操作系统对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.1.8.</span> <span class="toc-text">线程的上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.1.9.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">3.1.9.1.</span> <span class="toc-text">避免死锁、预防死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep%E6%96%B9%E6%B3%95%E4%B8%8Ewait%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.10.</span> <span class="toc-text">sleep()方法与wait()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait%E6%98%AFobject%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.10.1.</span> <span class="toc-text">为什么wait是object方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmmjava-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">JMM（Java 内存模型）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.1.</span> <span class="toc-text">CPU缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmm"><span class="toc-number">3.2.3.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jmm%E5%87%BA%E7%8E%B0%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">JMM出现的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jmm-%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">JMM
如何抽象线程和主内存之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">设计思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="toc-number">3.2.4.</span> <span class="toc-text">happens-before 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%A7%84%E5%88%99"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">常见规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">3.2.5.</span> <span class="toc-text">并发三特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">重要的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">如何保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">为什么禁止指令重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.3.3.</span> <span class="toc-text">乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">版本号机制实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cas%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">CAS实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">乐观锁存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#aba%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.3.1.</span> <span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%97%B6%E9%95%BF%E4%B9%85"><span class="toc-number">3.3.3.3.2.</span> <span class="toc-text">循环等待时长久</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.3.4.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-number">3.3.5.</span> <span class="toc-text">可中断锁和不可中断锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">3.3.6.</span> <span class="toc-text">共享锁和独占锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">3.3.7.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E9%94%81"><span class="toc-number">3.3.8.</span> <span class="toc-text">synchronized 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.8.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.8.2.</span> <span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantlock"><span class="toc-number">3.3.9.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantreadwritelock"><span class="toc-number">3.3.10.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal"><span class="toc-number">3.4.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.2.</span> <span class="toc-text">内存泄露问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0"><span class="toc-number">3.5.2.</span> <span class="toc-text">线程池参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">四种拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">3.5.3.</span> <span class="toc-text">常用的阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs"><span class="toc-number">3.6.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs%E5%BA%95%E5%B1%82"><span class="toc-number">3.6.1.</span> <span class="toc-text">AQS底层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#clh%E9%98%9F%E5%88%97"><span class="toc-number">3.6.1.1.1.</span> <span class="toc-text">CLH队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">3.6.1.1.2.</span> <span class="toc-text">自定义同步器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.7.</span> <span class="toc-text">同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">Semaphore(信号量)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdownlatch-%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">CountDownLatch （倒计时器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.8.</span> <span class="toc-text">Atomic 原子类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io"><span class="toc-number">4.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">4.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81inputstream"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">字节输入流InputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81outputstream"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">字节输出流OutputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">4.1.2.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reader%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">Reader（字符输入流）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section"><span class="toc-number">4.1.3.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#writer%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">Writer（字符输出流）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">4.1.4.</span> <span class="toc-text">字节缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bufferedinputstream%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">BufferedInputStream（字节缓冲输入流）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bufferedoutputstream%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">BufferedOutputStream（字节缓冲输出流）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">4.1.5.</span> <span class="toc-text">字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E4%B8%80%E7%A7%8D"><span class="toc-number">4.1.6.</span> <span class="toc-text">打印流——输出流的一种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81"><span class="toc-number">4.1.7.</span> <span class="toc-text">随机访问流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">涉及设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">观察者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">I&#x2F;O模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#javaweb"><span class="toc-number">5.</span> <span class="toc-text">JavaWeb</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E5%92%8Csession"><span class="toc-number">5.1.</span> <span class="toc-text">Cookie和Session</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#servlet"><span class="toc-number">5.2.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E6%A0%B7%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-number">5.2.2.</span> <span class="toc-text">为什么有这样的规范</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">6.</span> <span class="toc-text">常用框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis"><span class="toc-number">6.1.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1"><span class="toc-number">6.1.1.1.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E6%AC%A1%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-number">6.1.1.1.2.</span> <span class="toc-text">判断两次查询是否相同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">二级缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring"><span class="toc-number">6.2.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E6%A8%A1%E5%9D%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">Spring模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#core-container"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">Core Container</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aop"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data-accessintegration"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">Data Access&#x2F;Integration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-web"><span class="toc-number">6.2.1.4.</span> <span class="toc-text">Spring Web</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-test"><span class="toc-number">6.2.1.5.</span> <span class="toc-text">Spring Test</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ioc"><span class="toc-number">6.2.2.</span> <span class="toc-text">Ioc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-bean"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">Spring Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BAbean%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.2.2.2.1.</span> <span class="toc-text">类声明为bean的注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#component-%E5%92%8C-bean-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.2.2.2.</span> <span class="toc-text">@Component 和 @Bean 的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5bean%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.2.2.2.3.</span> <span class="toc-text">注入bean的注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#autowired-%E5%92%8Cresource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.2.2.4.</span> <span class="toc-text">@Autowired
和Resource的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.2.2.2.5.</span> <span class="toc-text">bean的作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bean%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">6.2.2.2.6.</span> <span class="toc-text">bean是否线程安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.2.2.2.7.</span> <span class="toc-text">bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8bean%E8%A3%85%E9%85%8D%E9%98%B6%E6%AE%B5%E8%BF%9B%E8%A1%8Cbean%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%A4%8D%E5%88%B6"><span class="toc-number">6.2.2.2.7.1.</span> <span class="toc-text">在bean装配阶段进行bean的替换、复制</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.2.2.8.</span> <span class="toc-text">三级缓存解决循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BA%A7%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">6.2.2.2.8.1.</span> <span class="toc-text">为什么不能只使用一级+三级缓存</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aop-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">Aop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aspectj-aop"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">AspectJ AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.3.1.1.</span> <span class="toc-text">通知类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.2.4.</span> <span class="toc-text">Spring事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">管理事务的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-number">6.2.4.1.1.</span> <span class="toc-text">声明式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F"><span class="toc-number">6.2.4.1.2.</span> <span class="toc-text">编程式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">事务管理接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#platformtransactionmanager%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.4.2.1.</span> <span class="toc-text">PlatformTransactionManager:事务管理接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transactiondefinition%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.4.2.2.</span> <span class="toc-text">TransactionDefinition:事务属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transactionstatus%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">6.2.4.2.3.</span> <span class="toc-text">TransactionStatus:事务状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.4.3.</span> <span class="toc-text">事务属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">6.2.4.3.1.</span> <span class="toc-text">事务传播行为的种类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transactional%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.2.4.4.</span> <span class="toc-text">Transactional注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springmvc"><span class="toc-number">6.3.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">6.3.1.</span> <span class="toc-text">核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.3.2.</span> <span class="toc-text">常用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.3.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.3.4.</span> <span class="toc-text">统一异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springboot"><span class="toc-number">6.4.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">6.4.1.</span> <span class="toc-text">自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">源码原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.4.1.2.1.</span> <span class="toc-text">条件注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">配置文件加载顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0starter"><span class="toc-number">6.4.3.</span> <span class="toc-text">实现starter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springcloud"><span class="toc-number">6.5.</span> <span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">6.5.1.</span> <span class="toc-text">微服务概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">6.5.2.</span> <span class="toc-text">服务熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">服务降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hystrix"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">Hystrix</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%B9%E9%94%99"><span class="toc-number">6.5.2.2.1.</span> <span class="toc-text">如何实现容错</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rpc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.5.3.</span> <span class="toc-text">RPC实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">6.5.3.1.</span> <span class="toc-text">建立通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.3.2.</span> <span class="toc-text">服务寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">6.5.3.3.</span> <span class="toc-text">网络传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-number">6.5.3.4.</span> <span class="toc-text">服务调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#feign"><span class="toc-number">6.5.4.</span> <span class="toc-text">Feign</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm"><span class="toc-number">7.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">7.1.</span> <span class="toc-text">java内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">7.1.1.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">java虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">7.1.1.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E5%8C%BA"><span class="toc-number">7.1.1.6.</span> <span class="toc-text">运行时常量区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">7.1.1.7.</span> <span class="toc-text">字符串常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%8C%BA"><span class="toc-number">7.1.1.8.</span> <span class="toc-text">直接内存区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hotspot%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.1.2.</span> <span class="toc-text">HotSpot虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="toc-number">7.1.2.1.1.</span> <span class="toc-text">类加载检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">7.1.2.1.2.</span> <span class="toc-text">分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.2.1.2.1.</span> <span class="toc-text">内存分配并发问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="toc-number">7.1.2.1.3.</span> <span class="toc-text">初始化零值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">7.1.2.1.4.</span> <span class="toc-text">设置对象头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cinit"><span class="toc-number">7.1.2.1.5.</span> <span class="toc-text">执行init</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">对象内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">对象的访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.3.</span> <span class="toc-text">java引用类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">7.2.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99"><span class="toc-number">7.2.1.</span> <span class="toc-text">内存分配和回收原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8eden%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">对象优先在eden区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">7.2.1.1.1.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">大对象进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">7.2.1.3.</span> <span class="toc-text">长期存活对象进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gc%E6%94%B6%E9%9B%86%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%9F%9F"><span class="toc-number">7.2.1.4.</span> <span class="toc-text">gc收集方式区域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">死亡对象判断方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">引用计数法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.2.1.1.</span> <span class="toc-text">循环引用问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BD%9C%E4%B8%BAgc-roots%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">7.2.2.2.1.</span> <span class="toc-text">可作为gc roots的结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-number">7.2.2.2.2.</span> <span class="toc-text">对象可以被回收，不一定会被回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="toc-number">7.2.3.</span> <span class="toc-text">废弃常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">7.2.4.</span> <span class="toc-text">无用的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.5.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6"><span class="toc-number">7.2.5.2.</span> <span class="toc-text">标记复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">7.2.5.3.</span> <span class="toc-text">标记整理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-number">7.2.5.4.</span> <span class="toc-text">分代收集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.2.6.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.2.6.1.</span> <span class="toc-text">Serial 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parnew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.2.6.2.</span> <span class="toc-text">ParNew 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cms-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.2.6.3.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.2.6.4.</span> <span class="toc-text">G1 收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-number">7.3.1.</span> <span class="toc-text">类声明周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-1"><span class="toc-number">7.3.2.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">7.3.2.2.1.</span> <span class="toc-text">验证</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81"><span class="toc-number">7.3.2.2.1.1.</span> <span class="toc-text">符号引用验证</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">7.3.2.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">7.3.2.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99"><span class="toc-number">7.4.1.</span> <span class="toc-text">类加载器加载规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.4.2.</span> <span class="toc-text">三个重要类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.4.3.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">如何打破</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/04/2024%E6%98%A5%E6%8B%9B%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/" title="2024春招投递记录">2024春招投递记录</a><time datetime="2024-01-04T03:36:29.885Z" title="发表于 2024-01-04 11:36:29">2024-01-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/18/JVM%E5%AD%A6%E4%B9%A0/" title="JVM学习">JVM学习</a><time datetime="2023-12-18T02:10:13.777Z" title="发表于 2023-12-18 10:10:13">2023-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/29/%E6%B8%90%E8%BF%9B%E5%BC%8Fredis%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7Vedis/" title="渐进式redis缓存工具Vedis">渐进式redis缓存工具Vedis</a><time datetime="2023-11-29T13:45:19.032Z" title="发表于 2023-11-29 21:45:19">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/27/%E6%89%8B%E5%86%99springMVC/" title="手写springMVC">手写springMVC</a><time datetime="2023-11-27T11:36:12.156Z" title="发表于 2023-11-27 19:36:12">2023-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/17/LCR%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="LCR题目专项训练">LCR题目专项训练</a><time datetime="2023-11-17T02:01:30.758Z" title="发表于 2023-11-17 10:01:30">2023-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>