<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>leetcode图题目专项训练 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="其它类型 中等 841. 钥匙和房间 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。 给你一个数组 rooms 其中">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode图题目专项训练">
<meta property="og:url" content="https://vlsmhd.github.io/2023/08/14/leetcode%E5%9B%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="其它类型 中等 841. 钥匙和房间 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。 给你一个数组 rooms 其中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-08-14T04:38:02.219Z">
<meta property="article:modified_time" content="2024-03-20T01:45:42.824Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2023/08/14/leetcode%E5%9B%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode图题目专项训练',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-20 09:45:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">117</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leetcode图题目专项训练</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-14T04:38:02.219Z" title="发表于 2023-08-14 12:38:02">2023-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-20T01:45:42.824Z" title="更新于 2024-03-20 09:45:42">2024-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/leetcode/">leetcode</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/leetcode/%E5%9B%BE/">图</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leetcode图题目专项训练"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="其它类型">其它类型</h1>
<h2 id="中等">中等</h2>
<h3 id="钥匙和房间"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/keys-and-rooms/">841.
钥匙和房间</a></h3>
<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到
<code>n - 1</code> 编号。最初，除 <code>0</code>
号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>
<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入
<code>i</code> 号房间可以获得的钥匙集合。如果能进入
<strong>所有</strong> 房间返回 <code>true</code>，否则返回
<code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：rooms = [[1],[2],[3],[]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure>
<h4 id="算法分析">算法分析</h4>
<h5 id="dfs-递归">DFS + 递归</h5>
<p>我们从第0号房间开始递归，每拿到一把钥匙，就去这个钥匙对应的房间，这就是D的精髓。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rooms.size();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第0号房间开始遍历</span></span><br><span class="line">        dfs(rooms, visited, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">boolean</span> visit: visited)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="type">boolean</span>[] visited, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[key])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; keys = rooms.get(key);</span><br><span class="line">        visited[key] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k : keys)&#123;</span><br><span class="line">            dfs(rooms, visited, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被围绕的区域"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">130.
被围绕的区域</a></h3>
<h4 id="dfs">DFS</h4>
<p>从边缘开始遍历，与边缘相连接的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//与边缘O连接的区域更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="comment">//第一列</span></span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//最后一列</span></span><br><span class="line">            dfs(board,  i, c-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">//最后一行</span></span><br><span class="line">            dfs(board, r-<span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c) || grid[r][c] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把遍历过的O变成A</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重新规划路线"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">1466.
重新规划路线</a></h3>
<p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code>
编号，其间共有 <code>n-1</code>
条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>
<p>路线用 <code>connections</code> 表示，其中
<code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到
<code>b</code> 的一条有向路线。</p>
<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0
。请你帮助重新规划路线方向，使每个城市都可以访问城市 0
。返回需要变更方向的最小路线数。</p>
<p>题目数据 <strong>保证</strong>
每个城市在重新规划路线方向后都能到达城市 0 。</p>
<h4 id="建图深搜dfs">建图+深搜DFS</h4>
<p>题目得出的结论：</p>
<ol type="1">
<li>路线网形成一颗树：图是有路线连通的。</li>
<li>要求最少规划方案，运用贪心策略，把部分有向边反向一下，就能实现目的。</li>
<li>采用DFS或者BFS必须的元素：visited</li>
</ol>
<p>小技巧：</p>
<p>反向路径在邻接表存负边值，这样从0正向推进的时候，只要&gt;0就说明路径是从0正向推进的，需要反转这条路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minReorder</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = buildGraph(n, connections);</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dfs(visited, graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> idx)</span>&#123;</span><br><span class="line">        visited[idx] = <span class="literal">true</span>;</span><br><span class="line">        List&lt;Integer&gt; list = graph.get(idx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> neighbor : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[Math.abs(neighbor)])&#123;</span><br><span class="line">                <span class="keyword">if</span>(neighbor &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(visited, graph, Math.abs(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建正向图——邻接表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span>&#123;</span><br><span class="line">        <span class="comment">// 用邻接表表示有向图</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化每个节点的邻居列表</span></span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] connection : connections)&#123;</span><br><span class="line">            <span class="comment">//正向路径</span></span><br><span class="line">            graph.get(connection[<span class="number">0</span>]).add(connection[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//反向路径</span></span><br><span class="line">            graph.get(connection[<span class="number">1</span>]).add(-connection[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="除法求值">**<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/">399.
除法求值</a></h3>
<p>给你一个变量对数组 <code>equations</code> 和一个实数值数组
<code>values</code> 作为已知条件，其中
<code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code>
共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或
<code>Bi</code> 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 <code>queries</code> 表示的问题，其中
<code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code>
个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code>
的结果作为答案。</p>
<p>返回 <strong>所有问题的答案</strong>
。如果存在某个无法确定的答案，则用 <code>-1.0</code>
替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用
<code>-1.0</code> 替代这个答案。</p>
<p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为
0 的情况，且不存在任何矛盾的结果。</p>
<p><strong>注意：</strong>未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = 2.0, b / c = 3.0</span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br><span class="line">注意：x 是未定义的 =&gt; -1.0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= equations.length &lt;= 20</code></li>
<li><code>equations[i].length == 2</code></li>
<li><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></li>
<li><code>values.length == equations.length</code></li>
<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>
<li><code>1 &lt;= queries.length &lt;= 20</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></li>
<li><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</li>
</ul>
<h4 id="建图-dfs">建图 + DFS</h4>
<p>如何建图：</p>
<figure>
<img src="leetcode图题目专项训练/image-20230903084528732.png"
alt="image-20230903084528732" />
<figcaption aria-hidden="true">image-20230903084528732</figcaption>
</figure>
<p>边的权值 = 起始边/终止边的值。</p>
<p>如图：边是可以出现反向的情况。</p>
<p>有向边虽然是a -&gt; b，但是b -&gt; a也成立，结果就是0.5</p>
<p>用Java的Map建图：</p>
<p>Map&lt; 分子顶点，&lt;分母顶点， 计算结果&gt;&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashmap建图</span></span><br><span class="line"><span class="comment">//初始化Graph(以HashMap形式),一个顶点可能有多个边，所以用list</span></span><br><span class="line">Map&lt;String, List&lt;Cell&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>), s2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//正向边 a-&gt;b</span></span><br><span class="line">    graph.computeIfAbsent(s1, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Cell</span>(s2, values[i]));</span><br><span class="line">    <span class="comment">//反向边 b -&gt; a</span></span><br><span class="line">    graph.computeIfAbsent(s2, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Cell</span>(s1, <span class="number">1.0</span> / values[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>边的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="comment">//存分母</span></span><br><span class="line">    String str;</span><br><span class="line">    <span class="comment">//存边权值（计算结果）</span></span><br><span class="line">    <span class="type">double</span> div;</span><br><span class="line"></span><br><span class="line">    Cell(String str, <span class="type">double</span> div) &#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">        <span class="built_in">this</span>.div = div;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果集构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建答案result数组以及访问过的HashSet: visited</span></span><br><span class="line"><span class="type">double</span>[] res = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line"><span class="comment">//首先将答案中所有答案值置为-1.0，出现(x / x)情况可以直接不用修改</span></span><br><span class="line">Arrays.fill(res, -<span class="number">1.0</span>);</span><br><span class="line"> <span class="comment">//对于每个query中的值调用dfs函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">    dfs(queries.get(i).get(<span class="number">0</span>), queries.get(i).get(<span class="number">1</span>), <span class="number">1.0</span>, graph, res, i, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>DFS函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//src: 当前位置; dst: 答案节点; </span></span><br><span class="line"><span class="comment">//cur: 当前计算值; </span></span><br><span class="line"><span class="comment">//graph: 之前建的图; </span></span><br><span class="line"><span class="comment">//res: 答案array; </span></span><br><span class="line"><span class="comment">//index: 当前遍历到第几个query; </span></span><br><span class="line"><span class="comment">//visited: 查重Set ———————————防止出现环</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String src, String dst, <span class="type">double</span> cur, Map&lt;String, List&lt;Cell&gt;&gt; graph, <span class="type">double</span>[] res, <span class="type">int</span> index, Set&lt;String&gt; visited)</span> &#123;</span><br><span class="line">      <span class="comment">//base case: 在visited中加入当前位置信息；如果加不了代表已经访问过，直接返回</span></span><br><span class="line">      <span class="keyword">if</span>(!visited.add(src)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果当前位置src = 答案节点dst，并且此节点在graph中(避免x/x的情况)，用当前计算值cur来填充答案res[index] </span></span><br><span class="line">      <span class="keyword">if</span>(src.equals(dst) &amp;&amp; graph.containsKey(src)) &#123;</span><br><span class="line">          res[index] = cur;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对于邻居节点，调用dfs函数</span></span><br><span class="line">      <span class="keyword">for</span>(Cell nei : graph.getOrDefault(src, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">          dfs(nei.str, dst, cur * nei.div, graph, res, index, visited);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="克隆图"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/clone-graph/">133.
克隆图</a></h3>
<p>给你无向 <strong><a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin">连通</a></strong>
图中一个节点的引用，请你返回该图的 <a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p>
<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>）
和其邻居的列表（<code>list[Node]</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例格式：</strong></p>
<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为
1（<code>val = 1</code>），第二个节点值为
2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>
<p><strong>邻接列表</strong>
是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>
<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将
<strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="leetcode图题目专项训练/133_clone_graph_question.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure>
<img src="leetcode图题目专项训练/graph.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure>
<img src="leetcode图题目专项训练/graph-1.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure>
<h4 id="dfs-递归-1">DFS +递归</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//哈希表记录已经遍历过的结点</span></span><br><span class="line">    <span class="comment">//key:旧结点  value: 新结点</span></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        map.put(node, clone);</span><br><span class="line">        <span class="keyword">for</span>(Node neighbor : node.neighbors)&#123;</span><br><span class="line">            clone.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截取评论的一句话：</p>
<blockquote>
<p>课本上总说deep copy和shallow
copy，似懂非懂的，不觉得这东西有什么用。慢慢地，发现deep
copy背后隐藏的逻辑其实是一种对象图（Object
Graph）的遍历行为——这东西广泛出现在各语言的垃圾回收、序列化机制里。内存里各个对象存储空间中放置的引用域/指针就好像有向图里一条边，你沿着它去到达内存中的每个角落、去到当前对象所有的关联对象。题设里的<code>neibours</code>就像一道开胃菜，它可以是其他collection、甚至object，学会这个deep
copy，你也就学会了GC里的可达性分析、你也就学会了如何把RAM中的数据固化到硬盘里。</p>
</blockquote>
<h1 id="深度优先搜索">深度优先搜索</h1>
<h2 id="岛屿问题">岛屿问题</h2>
<p>岛屿问题也是经典的<strong>网格问题</strong>，网格遍历相当于<strong>四叉树遍历</strong></p>
<p>DFS模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r row 行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c col 列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(&lt;T&gt;[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//防止重复遍历</span></span><br><span class="line">    <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(&lt;T&gt;[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="岛屿数量"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200.
岛屿数量</a></h3>
<p>给你一个由 <code>'1'</code>（陆地）和
<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="dfs-循环遍历">DFS + 循环遍历</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找岛屿入口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历过的岛屿，设置为2</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="广度优先搜索">广度优先搜索</h1>
<p>优先宽度遍历。</p>
<p>代码实现必备要素：</p>
<ul>
<li>迭代模式</li>
<li>辅助队列</li>
<li>visited表（可以以另一种形式，只要保证知道某个元素被访问过即可）</li>
</ul>
<h2 id="网格模型题目">网格模型题目</h2>
<h3 id="网格模型总结">网格模型总结</h3>
<p>基本上都是上下左右四个方向遍历，重点在于对队列的使用，队列可存二元组、三元组这样，灵活取舍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">BFS</span><span class="params">(<span class="type">char</span>[][] graph, ...)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果题目给了初始地点，就加入队列</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">		<span class="comment">//offer后的一些处理</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="comment">//对于二维网格，x、y坐标必不可少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> poll[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> poll[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//其它参数</span></span><br><span class="line">			...</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//接下来往四个方向遍历</span></span><br><span class="line">            <span class="comment">//上</span></span><br><span class="line">            <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ...)&#123;<span class="comment">//在某个格子内，向上走只是x坐标-1，判断一下x坐标是否出界即可，下面同理</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">        		...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下</span></span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">1</span> &lt; m &amp;&amp; ...)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">        		...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ...)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">            	...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; n &amp;&amp; ...)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">        		...</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//满足结果集的条件</span></span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                res.add();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="腐烂的橘子"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">994.
腐烂的橘子</a></h3>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code>
中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong>
的新鲜橘子都会腐烂。</p>
<p>返回
<em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回
<code>-1</code></em> 。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="oranges.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<h4 id="广搜方格遍历">广搜——方格遍历</h4>
<p>注意：</p>
<ol type="1">
<li>广搜的队列初始化。</li>
<li>广搜队列存的值要有意义，比如本题中存下标，可以方便后续进行上下左右的遍历。</li>
<li>网格搜索会有上下左右四个方向。</li>
<li>注意本题，每一轮循环是每一分钟，每一分钟腐烂的橘子可以同时感染，所以需要嵌套循环。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//队列记录腐烂橘子下标</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化新鲜橘子数量，并初始化队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果有多个腐烂的橘子，是可以同时感染的，而不是一个一个感染，所以应该嵌套循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] xy = queue.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> xy[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> xy[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//上</span></span><br><span class="line">                <span class="keyword">if</span>(x-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x-<span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//别忘记感染</span></span><br><span class="line">                    grid[x-<span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x-<span class="number">1</span>,y&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//下</span></span><br><span class="line">                <span class="keyword">if</span>(x+<span class="number">1</span> &lt; m &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[x+<span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x+<span class="number">1</span>,y&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(y-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y-<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[x][y-<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y-<span class="number">1</span>&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(y+<span class="number">1</span> &lt; n &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[x][y+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y+<span class="number">1</span>&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迷宫中离入口最近的出口"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/">1926.
迷宫中离入口最近的出口</a></h3>
<p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code>
（<strong>下标从 0 开始</strong>），矩阵中有空格子（用 <code>'.'</code>
表示）和墙（用 <code>'+'</code> 表示）。同时给你迷宫的入口
<code>entrance</code> ，用
<code>entrance = [entrancerow, entrancecol]</code>
表示你一开始所在格子的行和列。</p>
<p>每一步操作，你可以往
<strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者
<strong>右</strong>
移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离
<code>entrance</code> <strong>最近</strong>
的出口。<strong>出口</strong> 的含义是 <code>maze</code>
<strong>边界</strong> 上的
<strong>空格子</strong>。<code>entrance</code> 格子
<strong>不算</strong> 出口。</p>
<p>请你返回从 <code>entrance</code> 到最近出口的最短路径的
<strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code>
。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="nearest1-grid.jpg" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[&quot;+&quot;,&quot;+&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;,&quot;.&quot;]], entrance = [1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。</span><br><span class="line">一开始，你在入口格子 (1,2) 处。</span><br><span class="line">- 你可以往左移动 2 步到达 (1,0) 。</span><br><span class="line">- 你可以往上移动 1 步到达 (0,2) 。</span><br><span class="line">从入口处没法到达 (2,3) 。</span><br><span class="line">所以，最近的出口是 (0,2) ，距离为 1 步。</span><br></pre></td></tr></table></figure>
<h4 id="广搜-距离判断最短">广搜 + 距离判断最短</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nearestExit</span><span class="params">(<span class="type">char</span>[][] maze, <span class="type">int</span>[] entrance)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> maze.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> maze[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//第三个参数为到当前结点移动的距离</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entrance[<span class="number">0</span>], entrance[<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">//走过的格子变成墙</span></span><br><span class="line">        maze[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> poll[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> poll[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> poll[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上</span></span><br><span class="line">            <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; maze[x-<span class="number">1</span>][y] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x-<span class="number">1</span>, y, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x-<span class="number">1</span>][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下</span></span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">1</span> &lt; m &amp;&amp; maze[x+<span class="number">1</span>][y] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x+<span class="number">1</span>, y, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x+<span class="number">1</span>][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; maze[x][y-<span class="number">1</span>] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y-<span class="number">1</span>, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x][y-<span class="number">1</span>] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; n &amp;&amp; maze[x][y+<span class="number">1</span>] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y+<span class="number">1</span>, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x][y+<span class="number">1</span>] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((x == <span class="number">0</span> || x == m-<span class="number">1</span> || y == <span class="number">0</span> || y == n-<span class="number">1</span>) &amp;&amp; !(x == entrance[<span class="number">0</span>] &amp;&amp; y == entrance[<span class="number">1</span>]))&#123;</span><br><span class="line">                min = Math.min(min, d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE? -<span class="number">1</span>:min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊">特殊</h2>
<h3 id="蛇梯棋"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/snakes-and-ladders/">909.
蛇梯棋</a></h3>
<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code>
，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/牛耕式转行书写法/17195786">转行交替方式</a>
，<strong>从左下角开始</strong> （即，从 <code>board[n - 1][0]</code>
开始）每一行交替方向。</p>
<p>玩家从棋盘上的方格 <code>1</code>
（总是在最后一行、第一列）开始出发。</p>
<p>每一回合，玩家需要从当前方格 <code>curr</code>
开始出发，按下述要求前进：</p>
<ul>
<li><p>选定目标方格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure>
<p>，目标方格的编号符合范围</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[curr + 1, min(curr + 6, n2)]</span><br></pre></td></tr></table></figure>
<p>。</p>
<ul>
<li>该选择模拟了掷 <strong>六面体骰子</strong>
的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>
</ul></li>
<li><p>传送玩家：如果目标方格 <code>next</code>
处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格
<code>next</code> 。</p></li>
<li><p>当玩家到达编号 <code>n2</code> 的方格时，游戏结束。</p></li>
</ul>
<p><code>r</code> 行 <code>c</code>
列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果
<code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是
<code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n2</code>
的方格上没有蛇或梯子。</p>
<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也
<strong>不能</strong> 继续移动。</p>
<ul>
<li>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code>
，第一次移动，玩家的目标方格是 <code>2</code>
。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但
<strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格
<code>4</code> 。</li>
</ul>
<p>返回达到编号为 <code>n2</code>
的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="leetcode图题目专项训练/snakes.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class="line">先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span><br><span class="line">然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span><br><span class="line">接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 </span><br><span class="line">最后决定移动到方格 36 , 游戏结束。 </span><br><span class="line">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[-1,-1],[-1,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h4 id="bfs寻路">BFS寻路</h4>
<p>核心寻路逻辑在于第二层for循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> poll[<span class="number">0</span>] + i;</span><br><span class="line">                <span class="comment">//边界判断</span></span><br><span class="line">                <span class="keyword">if</span>(next &gt; n * n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//蛇或梯子</span></span><br><span class="line">                <span class="type">int</span>[] rc = id2rc(next, n);</span><br><span class="line">                <span class="keyword">if</span>(board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    next = board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//到达终点</span></span><br><span class="line">                <span class="keyword">if</span>(next == n * n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> poll[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//蛇会回退，判断是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[next])&#123;</span><br><span class="line">                    vis[next] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;next, poll[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据当前格子序号计算出所在的行列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> id, <span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (id - <span class="number">1</span>) / n;<span class="comment">//减一的目的：防止id是n的倍数的时候，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - t - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (id - <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">if</span>(t % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            c = n - c - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;r, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转化类型">字符串转化类型</h2>
<p>题目描述：给定start和end字符串，要求从start -&gt;
end，且必须经过中间数组<code>wordList</code>。</p>
<h3 id="最小基因变化"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-genetic-mutation/">433.
最小基因变化</a></h3>
<p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是
<code>'A'</code>、<code>'C'</code>、<code>'G'</code> 和 <code>'T'</code>
之一。</p>
<p>假设我们需要调查从基因序列 <code>start</code> 变为 <code>end</code>
所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>
<ul>
<li>例如，<code>"AACCGGTT" --&gt; "AACCGGTA"</code>
就是一次基因变化。</li>
</ul>
<p>另有一个基因库 <code>bank</code>
记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库
<code>bank</code> 中）</p>
<p>给你两个基因序列 <code>start</code> 和 <code>end</code>
，以及一个基因库 <code>bank</code> ，请你找出并返回能够使
<code>start</code> 变化为 <code>end</code>
所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p>
<p>注意：起始基因序列 <code>start</code>
默认是有效的，但是它并不一定会出现在基因库中。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h4 id="bfs-哈希表">BFS + 哈希表</h4>
<p>哈希表作用：对bank元素去重，顺带判断后续新加的结点是否在bank中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> &#123;</span><br><span class="line">        <span class="comment">//哈希表去重bank</span></span><br><span class="line">        HashSet&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//visited表</span></span><br><span class="line">        HashSet&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : bank) &#123;</span><br><span class="line">            cnt.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cnt.contains(endGene))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(startGene.equals(endGene))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] keys = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(startGene);</span><br><span class="line">        vis.add(startGene);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//广搜BFS数组</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//遍历修改的每一种情况</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(keys[k] != poll.charAt(j))&#123;</span><br><span class="line">                            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(poll);</span><br><span class="line">                            sb.setCharAt(j,keys[k]);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                            <span class="comment">//下一个要遍历的字符</span></span><br><span class="line">                            <span class="keyword">if</span>(!vis.contains(next) &amp;&amp; cnt.contains(next))&#123;</span><br><span class="line">                                <span class="keyword">if</span>(next.equals(endGene))&#123;</span><br><span class="line">                                    <span class="keyword">return</span> ans;</span><br><span class="line">                                &#125;</span><br><span class="line">                                queue.offer(next);</span><br><span class="line">                                vis.add(next);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;<span class="comment">//这里queue即使有多个选项，for循环结束还是会选择一个存在cnt里的元素，因此只是经过了一轮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词接龙">*<a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和
<code>endWord</code> 的 <strong>转换序列</strong>
是一个按下述规格形成的序列
<code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在
<code>wordList</code> 中。注意， <code>beginWord</code> 不需要在
<code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code>
和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到
<code>endWord</code> 的 <strong>最短转换序列</strong> 中的
<strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回
<code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
<h4 id="优化建图bfs">优化建图+BFS</h4>
<h5 id="建图过程"><strong>建图过程</strong></h5>
<p><strong>状态推进思想：</strong>创建虚拟节点。对于单词
hit，我们创建三个虚拟节点 *it、h*t、hi*，并让 hit
向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为
hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的
id 与这些虚拟节点对应的 id 相连即可。</p>
<p>示例一：</p>
<p><img src="leetcode图题目专项训练/2DCBB225E30E69B483ACE39B538FDC93.jpg" alt="2DCBB225E30E69B483ACE39B538FDC93" style="zoom:67%;" /></p>
<p>中间过程走了8步，根据建图规律，符合题意的话，就是 8 /
2走了四步，算上开头的一步，正好五步</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(String word)</span>&#123;</span><br><span class="line">    addWord(word);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> wordId.get(word);</span><br><span class="line">    <span class="comment">//给当前单词每个可能的单词变换建立结点</span></span><br><span class="line">    <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> word.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//添加新字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> chars[i];</span><br><span class="line">        chars[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        addWord(newWord);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id1</span> <span class="operator">=</span> wordId.get(newWord);</span><br><span class="line">        edges.get(id).add(id1);</span><br><span class="line">        edges.get(id1).add(id);</span><br><span class="line">        chars[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!wordId.containsKey(word))&#123;</span><br><span class="line">        wordId.put(word, nodeNum++);</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    addEdge(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (String s : wordList) &#123;</span><br><span class="line">        addEdge(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!wordId.containsKey(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="bfs">BFS</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个顶点编号</span></span><br><span class="line">Map&lt;String, Integer&gt; wordId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//每个顶点包含的边</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    addEdge(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (String s : wordList) &#123;</span><br><span class="line">        addEdge(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!wordId.containsKey(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录到达每个结点的路径长度,同样也可作为vis</span></span><br><span class="line">    <span class="type">int</span>[] dit = <span class="keyword">new</span> <span class="title class_">int</span>[nodeNum];</span><br><span class="line">    Arrays.fill(dit, -<span class="number">1</span>);</span><br><span class="line">    dit[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">beginId</span> <span class="operator">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(beginId);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(x == endId)&#123;</span><br><span class="line">            <span class="keyword">return</span> dit[x] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer id : edges.get(x)) &#123;</span><br><span class="line">            <span class="comment">//去重，防止循环搜索</span></span><br><span class="line">            <span class="keyword">if</span>(dit[id] == -<span class="number">1</span>)&#123;</span><br><span class="line">                dit[id] = dit[x] + <span class="number">1</span>;</span><br><span class="line">                queue.offer(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集">并查集</h1>
<h3 id="省份数量"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/">547.
省份数量</a></h3>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市
<code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code>
与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市
<code>c</code> 间接相连。</p>
<p><strong>省份</strong>
是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中
<code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第
<code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code>
表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="graph1.jpg" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h4 id="等级制-路径压缩优化并查集">等级制 + 路径压缩优化并查集</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">DisjointSet</span> <span class="variable">disjointSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSet</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    disjointSet.union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> disjointSet.unionNums();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] s;</span><br><span class="line">    <span class="comment">//这里size采用等级制度，侵略完同级的其它结点，自身等级+1</span></span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">//领导数量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSet</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s[x])&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[x] = find(s[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//找到各自的领导</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ldx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ldy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span>(ldx != ldy)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.size[ldx] &lt; <span class="built_in">this</span>.size[ldy])&#123;</span><br><span class="line">                s[ldx] = ldy;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.size[ldx] &gt; <span class="built_in">this</span>.size[ldy])&#123;</span><br><span class="line">                s[ldy] = ldx;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[ldy] = ldx;</span><br><span class="line">                <span class="built_in">this</span>.size[ldx]++;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unionNums</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冗余连接"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/">684.
冗余连接</a></h3>
<p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong>
图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>)
的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到
<code>n</code>
中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为
<code>n</code> 的二维数组 <code>edges</code>
，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和
<code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code>
个节点的树。如果有多个答案，则返回数组 <code>edges</code>
中最后出现的那个。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="leetcode图题目专项训练/1626676174-hOEVUL-image.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: edges = [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure>
<img src="leetcode图题目专项训练/1626676179-kGxcmu-image.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>n == edges.length</code></li>
<li><code>3 &lt;= n &lt;= 1000</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= ai &lt; bi &lt;= edges.length</code></li>
<li><code>ai != bi</code></li>
<li><code>edges</code> 中无重复元素</li>
<li>给定的图是连通的</li>
</ul>
<h4 id="算法分析-1">算法分析</h4>
<h5 id="并查集无优化">并查集（无优化）</h5>
<p>通过并查集寻找<strong>附加的边</strong>。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。（其实就是找构成环的那一条边，找到了就返回即可，从前往后遍历，根据题意，会返回靠后的边）</p>
<ul>
<li><p>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</p></li>
<li><p>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>], y = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (find(parent, x) != find(parent, y)) &#123;</span><br><span class="line">                union(parent, x, y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把x一整个集合合并过去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        parent[find(parent, x)] = find(parent, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent, parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拓扑排序">拓扑排序</h1>
<h2 id="课程表问题">课程表问题</h2>
<h3 id="课程表"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207.
课程表</a></h3>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为
<code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组
<code>prerequisites</code> 给出，其中
<code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程
<code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code>
。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程
<code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code>
；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对
<strong>互不相同</strong></li>
</ul>
<h4 id="拓扑排序邻接表-入度表-bfs">拓扑排序（邻接表 + 入度表 +
BFS）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="comment">//构建入度表</span></span><br><span class="line">        <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//BFS的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建邻接表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表 and  邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            indegrees[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">            adjacency.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacency.get(poll)) &#123;</span><br><span class="line">                indegrees[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课程表-ii"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表
II</a></h3>
<p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code>
到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code>
，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程
<code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code>
，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回
<strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回
<strong>一个空数组</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>ai != bi</code></li>
<li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li>
</ul>
<h4 id="拓扑排序邻接表-入度表-bfs-1">拓扑排序（邻接表 + 入度表 +
BFS）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//构建入度表</span></span><br><span class="line">        <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//BFS的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建邻接表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表 and  邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            indegrees[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">            adjacency.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始BFS</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            res[j] = poll;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacency.get(poll)) &#123;</span><br><span class="line">                indegrees[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>?res : <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2023/08/14/leetcode%E5%9B%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/">https://vlsmhd.github.io/2023/08/14/leetcode%E5%9B%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/20/leetcode%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode滑动窗口题目专项训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leetcode滑动窗口题目专项训练</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/11/leetcode%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode回溯题目专项训练"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode回溯题目专项训练</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">117</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">其它类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%AD%89"><span class="toc-number">1.1.</span> <span class="toc-text">中等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">841.
钥匙和房间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dfs-%E9%80%92%E5%BD%92"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">DFS + 递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">130.
被围绕的区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">1466.
重新规划路线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE%E6%B7%B1%E6%90%9Cdfs"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">建图+深搜DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="toc-number">1.1.4.</span> <span class="toc-text">**399.
除法求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE-dfs"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">建图 + DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E5%9B%BE"><span class="toc-number">1.1.5.</span> <span class="toc-text">133.
克隆图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs-%E9%80%92%E5%BD%92-1"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">DFS +递归</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">2.</span> <span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">岛屿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">200.
岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">DFS + 循环遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.</span> <span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="toc-number">3.1.</span> <span class="toc-text">网格模型题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">网格模型总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-number">3.1.2.</span> <span class="toc-text">994.
腐烂的橘子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%90%9C%E6%96%B9%E6%A0%BC%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">广搜——方格遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%A6%BB%E5%85%A5%E5%8F%A3%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%BA%E5%8F%A3"><span class="toc-number">3.1.3.</span> <span class="toc-text">1926.
迷宫中离入口最近的出口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%90%9C-%E8%B7%9D%E7%A6%BB%E5%88%A4%E6%96%AD%E6%9C%80%E7%9F%AD"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">广搜 + 距离判断最短</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A"><span class="toc-number">3.2.</span> <span class="toc-text">特殊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9B%87%E6%A2%AF%E6%A3%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">909.
蛇梯棋</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bfs%E5%AF%BB%E8%B7%AF"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">BFS寻路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">字符串转化类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96"><span class="toc-number">3.3.1.</span> <span class="toc-text">433.
最小基因变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bfs-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">BFS + 哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-number">3.3.2.</span> <span class="toc-text">*127. 单词接龙</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BEbfs"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">优化建图+BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.2.1.1.</span> <span class="toc-text">建图过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bfs"><span class="toc-number">3.3.2.1.2.</span> <span class="toc-text">BFS</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">547.
省份数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E7%BA%A7%E5%88%B6-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">等级制 + 路径压缩优化并查集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.0.2.</span> <span class="toc-text">684.
冗余连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E4%BC%98%E5%8C%96"><span class="toc-number">4.0.2.1.1.</span> <span class="toc-text">并查集（无优化）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">课程表问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">207.
课程表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E9%82%BB%E6%8E%A5%E8%A1%A8-%E5%85%A5%E5%BA%A6%E8%A1%A8-bfs"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">拓扑排序（邻接表 + 入度表 +
BFS）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii"><span class="toc-number">5.1.2.</span> <span class="toc-text">210. 课程表
II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E9%82%BB%E6%8E%A5%E8%A1%A8-%E5%85%A5%E5%BA%A6%E8%A1%A8-bfs-1"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">拓扑排序（邻接表 + 入度表 +
BFS）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/31/Spring%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Spring深度学习">Spring深度学习</a><time datetime="2024-03-31T11:41:11.573Z" title="发表于 2024-03-31 19:41:11">2024-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/" title="软件测试入门">软件测试入门</a><time datetime="2024-03-27T07:10:53.727Z" title="发表于 2024-03-27 15:10:53">2024-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="深入理解分布式系统-阅读笔记">深入理解分布式系统-阅读笔记</a><time datetime="2024-03-26T03:26:08.300Z" title="发表于 2024-03-26 11:26:08">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/19/%E9%AB%98%E6%80%A7%E8%83%BDIM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="高性能IM即时通讯系统设计">高性能IM即时通讯系统设计</a><time datetime="2024-03-19T13:31:13.565Z" title="发表于 2024-03-19 21:31:13">2024-03-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/15/Leetcode-SQL%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode-SQL专项训练">leetcode-SQL专项训练</a><time datetime="2024-03-15T14:04:55.480Z" title="发表于 2024-03-15 22:04:55">2024-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>