<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VLS_Blog</title>
  
  <subtitle>starry sky</subtitle>
  <link href="https://vlsmhd.github.io/atom.xml" rel="self"/>
  
  <link href="https://vlsmhd.github.io/"/>
  <updated>2023-09-26T13:40:35.380Z</updated>
  <id>https://vlsmhd.github.io/</id>
  
  <author>
    <name>Vlong_shen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>maven学习</title>
    <link href="https://vlsmhd.github.io/2023/09/26/maven%E5%AD%A6%E4%B9%A0/"/>
    <id>https://vlsmhd.github.io/2023/09/26/maven%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-26T12:52:34.829Z</published>
    <updated>2023-09-26T13:40:35.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven介绍">Maven介绍</h1><p>Maven的本质是一个<strong>项目管理工具</strong>，将项目开发和管理过程抽象成一个项目对象模型(POM)</p><ul><li>POM (Project Object Model):项目对象模型</li></ul><p>架构：</p><figure><img src="image-20230926210335974.png" alt="image-20230926210335974" /><figcaption aria-hidden="true">image-20230926210335974</figcaption></figure><p>作用：</p><ul><li>项目构建：提供标准的、跨平台的自动化项目构建方式</li><li>依赖管理：方便快捷的管理项目依赖的资源(jar包)，避免资源间的版本冲突问题</li><li>统一开发结构：提供标准的、统一的项目结构</li></ul><h2 id="下载安装">下载安装</h2><p>解压安装目录：</p><ul><li>bin：核心运行文件</li><li>boot：类加载目录</li><li>lib：依赖jar包</li><li>conf：核心配置文件</li></ul><p>配置环境变量：</p><ol type="1"><li><p>依赖Java，需要配置JAVA_HOME</p></li><li><p>设置MAVEN自身的运行环境，需要配置MAVEN_HOME环境</p></li></ol><p>配置结果：</p><figure><img src="image-20230926210537346.png" alt="image-20230926210537346" /><figcaption aria-hidden="true">image-20230926210537346</figcaption></figure><h2 id="基础概念">基础概念</h2><h3 id="仓库">仓库</h3><p>定义：存储资源，包含各种jar包。</p><p>分类：</p><ul><li>本地仓库：自己电脑存储的仓库，连接远程仓库获取资源。</li><li>远程仓库：非本地，为本地提供资源。<ul><li>中央仓库：存储所有资源的仓库（Maven维护）</li><li>私服：部门/公司范围内存储资源的仓库，从中央仓库获取资源<ul><li>作用：版权设立，服务内部。作为本地与远程仓库连接的枢纽。提供远程镜像供本地快速下载。</li></ul></li></ul></li></ul><h3 id="坐标">坐标</h3><p>定义：maven中用于描述仓库资源的位置。 链接：https://repo1.maven.org/maven2/</p><p>Maven坐标主要组成</p><ul><li><p>groupld：定义当前Maven<strong>项目隶属组织名称</strong>(通常是域名反写，例如:org.mybatis)</p></li><li><p>artifactld：定义当前Maven<strong>项目名称</strong>(通常是模块名称，例如CRM、SMS)</p></li><li><p>version：定义<strong>当前项目版本号</strong></p></li><li><p>packaging：定义该项目的打包方式</p></li></ul><p>Maven坐标的作用：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p><p>https://mvnrepository.com/ 仓库中心网站。</p><ul><li><ul><li>里面有各种资源的坐标。</li></ul></li></ul><h3 id="基础配置">基础配置</h3><p>镜像仓库配置：在settings.xml中配置</p><figure><img src="image-20230926211007117.png" alt="image-20230926211007117" /><figcaption aria-hidden="true">image-20230926211007117</figcaption></figure><h1 id="maven高级">Maven高级</h1><h2 id="依赖管理">依赖管理</h2><h3 id="依赖配置">依赖配置</h3><p>概念：当前项目运行所需要的jar，可配置多个依赖。</p><p>格式：</p><p><img src="image-20230926211152233.png" alt="image-20230926211152233" style="zoom:80%;" /></p><h3 id="依赖传递">依赖传递</h3><p>依赖具有传递性。</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：所依赖的直接依赖如果依赖其它资源，当前项目间接依赖其它资源。</li></ul><figure><img src="image-20230926211539298.png" alt="image-20230926211539298" /><figcaption aria-hidden="true">image-20230926211539298</figcaption></figure><p>注意：相对于本项目而言。</p><h4 id="依赖冲突解决">依赖冲突解决</h4><ul><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。（项目的ID是不同的,在同度下，但是属于不同的直接依赖。直接依赖在前的，用直接依赖的。）</li><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。（项目的ID是相同的，相当于在一个项目的pom.xml文件中有多个相同的依赖）。</li></ul><figure><img src="image-20230926211611529.png" alt="image-20230926211611529" /><figcaption aria-hidden="true">image-20230926211611529</figcaption></figure><h3 id="可选依赖">可选依赖</h3><p>作用：对外隐藏当前所依赖的资源。</p><p>配置方法：</p><figure><img src="image-20230926211654725.png" alt="image-20230926211654725" /><figcaption aria-hidden="true">image-20230926211654725</figcaption></figure><p>案例：</p><p>比如项目二依赖了项目三，项目三在所依赖的资源写了optional标签，这样一来，项目二看不到项目三的依赖。</p><h3 id="排除依赖">排除依赖</h3><p>概念：<strong>主动</strong>断开依赖的资源，被排除的资源无需指定版本。</p><figure><img src="image-20230926211731266.png" alt="image-20230926211731266" /><figcaption aria-hidden="true">image-20230926211731266</figcaption></figure><h3 id="依赖范围">依赖范围</h3><p>scope设定依赖作用范围。</p><p>作用：通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p><p>scope取值：</p><figure><img src="image-20230926211853073.png" alt="image-20230926211853073" /><figcaption aria-hidden="true">image-20230926211853073</figcaption></figure><ul><li>compile ：作用于编译环境、测试环境、运行环境。<ul><li>test：作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值。</li></ul></li><li>provided ：作用于编译环境、测试环境。<ul><li>servlet-api ，在使用它时，必须将 scope设置为该值，不然运行时就会报错。</li></ul></li><li>runtime ： 作用于测试环境、运行环境。<ul><li>jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题。</li></ul></li></ul><p>注意：如果坐标不引入scope标签，默认是compile。</p><h2 id="生命周期与插件">生命周期与插件</h2><p>Maven对项目构建的生命周期划分为3套</p><ul><li>clean：清理工作</li><li>default：核心工作，例如编译，测试，打包，部署等</li><li>site：产生报告，发布站点等</li></ul><h3 id="clean">clean</h3><figure><img src="image-20230926212130745.png" alt="image-20230926212130745" /><figcaption aria-hidden="true">image-20230926212130745</figcaption></figure><h3 id="default">default</h3><figure><img src="image-20230926212153949.png" alt="image-20230926212153949" /><figcaption aria-hidden="true">image-20230926212153949</figcaption></figure><h3 id="site">site</h3><figure><img src="image-20230926212237672.png" alt="image-20230926212237672" /><figcaption aria-hidden="true">image-20230926212237672</figcaption></figure><h2 id="分模块开发">分模块开发</h2><figure><img src="image-20230926212317298.png" alt="image-20230926212317298" /><figcaption aria-hidden="true">image-20230926212317298</figcaption></figure><h3 id="模块拆分">模块拆分</h3><p>案例：抽取domain层</p><ol type="1"><li><p>创建新模块</p><p><img src="image-20230926212420163.png" alt="image-20230926212420163" style="zoom: 80%;" /></p></li><li><p>项目中创建domain包，复制原项目的内容。</p></li><li><p>建立依赖关系</p></li></ol><p>​ 总项目里的pom文件，添加分离出去的模块的坐标依赖</p><ol start="4" type="1"><li><p>在本地仓库里，安装这个分离出去的模块</p><figure><img src="image-20230926212500120.png" alt="image-20230926212500120" /><figcaption aria-hidden="true">image-20230926212500120</figcaption></figure></li></ol><h2 id="聚合">聚合</h2><p>概念：</p><ul><li><p>所谓聚合：将<strong>多个模块组织成一个整体</strong>，同时进行项目构建的过程称为聚合</p></li><li><p>聚合工程：通常是一个不具有业务功能的"空"工程（有且仅有一个pom文件）</p></li><li><p>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建</p></li><li><ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>实现：</p><ol type="1"><li><p>创建空的maven项目</p></li><li><p>项目的打包方式改成pom</p><figure><img src="image-20230926212751252.png" alt="image-20230926212751252" /><figcaption aria-hidden="true">image-20230926212751252</figcaption></figure></li><li><p>pom.xml添加要管理的项目</p><figure><img src="image-20230926212806821.png" alt="image-20230926212806821" /><figcaption aria-hidden="true">image-20230926212806821</figcaption></figure></li><li><p>运行</p><p>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序，和配置的顺序无关。</p></li></ol><h2 id="继承">继承</h2><p>概念：</p><ul><li><p>所谓继承：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p></li><li><p>作用：</p></li><li><ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>实现：</p><ol type="1"><li><p>创建一个空的Maven项目并将其打包方式设置为pom</p></li><li><p>在子项目中设置其父工程</p><figure><img src="image-20230926213027423.png" alt="image-20230926213027423" /><figcaption aria-hidden="true">image-20230926213027423</figcaption></figure></li><li><p>优化子项目共有依赖导入问题</p><ol type="1"><li><p>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中</p></li><li><p>删除子项目中已经被抽取到父项目的pom.xml中的jar包</p></li></ol></li><li><p>优化子项目依赖版本问题</p><p>有部分项目，需要依赖独有的jar包。或者说，有部分项目，不需要父类的某个或多个jar包</p><ol type="1"><li><p>在父工程mavne_01_parent的pom.xml来定义依赖管理</p><figure><img src="image-20230926213225766.png" alt="image-20230926213225766" /><figcaption aria-hidden="true">image-20230926213225766</figcaption></figure><p><dependencyManagement>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖==</p></li><li><p>子项目添加依赖</p><figure><img src="image-20230926213250736.png" alt="image-20230926213250736" /><figcaption aria-hidden="true">image-20230926213250736</figcaption></figure><p>可以不写版本，默认跟父项目版本一致。</p></li></ol></li></ol><h2 id="属性">属性</h2><p>作用：解决更改版本的牵连繁杂问题</p><p>属性分类：</p><figure><img src="image-20230926213711498.png" alt="image-20230926213711498" /><figcaption aria-hidden="true">image-20230926213711498</figcaption></figure><p>实现：</p><p>父工程中定义属性：</p><figure><img src="image-20230926213531412.png" alt="image-20230926213531412" /><figcaption aria-hidden="true">image-20230926213531412</figcaption></figure><p>修改依赖的version</p><figure><img src="image-20230926213544328.png" alt="image-20230926213544328" /><figcaption aria-hidden="true">image-20230926213544328</figcaption></figure><p>配置文件存储属性值</p><p>设置maven过滤文件范围</p><figure><img src="image-20230926213741832.png" alt="image-20230926213741832" /><figcaption aria-hidden="true">image-20230926213741832</figcaption></figure><h3 id="版本管理">版本管理</h3><ul><li><p>SNAPSHOT（快照版本）</p></li><li><ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li><p>RELEASE（发布版本）</p></li><li><ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><h2 id="多环境开发配置">多环境开发配置</h2><p>多环境概念</p><figure><img src="image-20230926213904274.png" alt="image-20230926213904274" /><figcaption aria-hidden="true">image-20230926213904274</figcaption></figure><p>实现：</p><ol type="1"><li><p>父工程配置多个环境,并指定默认激活环境</p><ul><li><p>格式：</p><figure><img src="image-20230926213927144.png" alt="image-20230926213927144" /><figcaption aria-hidden="true">image-20230926213927144</figcaption></figure><p>案例：</p><figure><img src="image-20230926213953496.png" alt="image-20230926213953496" /><figcaption aria-hidden="true">image-20230926213953496</figcaption></figure></li></ul></li><li><p>命令实现环境切换</p><p>格式：</p><figure><img src="image-20230926214018770.png" alt="image-20230926214018770" /><figcaption aria-hidden="true">image-20230926214018770</figcaption></figure></li></ol><h1 id="配置文件帮助文档">配置文件帮助文档</h1><h2 id="附件1pom文件总体配置说明">附件1：POM文件总体配置说明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd &quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。</span></span><br><span class="line"><span class="comment">         坐标包括group ID，artifact ID和 version。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 被继承的父项目的构件标识符 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 被继承的父项目的版本 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。</span></span><br><span class="line"><span class="comment">             Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），</span></span><br><span class="line"><span class="comment">             然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，</span></span><br><span class="line"><span class="comment">         这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span> 4.0.0 <span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， </span></span><br><span class="line"><span class="comment">         如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID</span></span><br><span class="line"><span class="comment">         和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven</span></span><br><span class="line"><span class="comment">         为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span> jar <span class="tag">&lt;/<span class="name">packaging</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.0-SNAPSHOT <span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的名称, Maven产生的文档用 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span> xxx-maven <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目主页的URL, Maven产生的文档用 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://maven.apache.org <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，</span></span><br><span class="line"><span class="comment">         就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的</span></span><br><span class="line"><span class="comment">         索引页文件，而不是调整这里的文档。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span> A maven project to study maven. <span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span>&gt;</span><span class="tag">&lt;/<span class="name">maven</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 问题管理系统（例如jira）的名字， --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span> jira <span class="tag">&lt;/<span class="name">system</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 该项目使用的问题管理系统的URL --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://jira.baidu.com/banseon <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目持续集成信息 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 持续集成系统的名字，例如continuum --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 传送通知的途径 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 发生错误时是否通知 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span>&gt;</span><span class="tag">&lt;/<span class="name">sendOnError</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 构建失败时是否通知 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span>&gt;</span><span class="tag">&lt;/<span class="name">sendOnFailure</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 构建成功时是否通知 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span>&gt;</span><span class="tag">&lt;/<span class="name">sendOnSuccess</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 发生警告时是否通知 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span>&gt;</span><span class="tag">&lt;/<span class="name">sendOnWarning</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 不赞成使用。通知发送到哪里 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span>&gt;</span><span class="tag">&lt;/<span class="name">address</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 扩展配置项 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目相关邮件列表信息 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 邮件的名称 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> Demo <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span> banseon@126.com <span class="tag">&lt;/<span class="name">post</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span> banseon@126.com <span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span> banseon@126.com <span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 你可以浏览邮件信息的URL --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span> http:/hi.baidu.com/banseon/demo/dev/ <span class="tag">&lt;/<span class="name">archive</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目开发者列表 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 某个项目开发者的信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- SCM里项目开发者的唯一标识符 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span> HELLO WORLD <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者的全名 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> banseon <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者的email --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span> banseon@126.com <span class="tag">&lt;/<span class="name">email</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者的主页的URL --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span> Project Manager <span class="tag">&lt;/<span class="name">role</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span> Architect <span class="tag">&lt;/<span class="name">role</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者所属组织 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span> demo <span class="tag">&lt;/<span class="name">organization</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者所属组织的URL --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span> http://hi.baidu.com/xxx <span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span> No <span class="tag">&lt;/<span class="name">dept</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span> -5 <span class="tag">&lt;/<span class="name">timezone</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的其他贡献者列表 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者的全名 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span><span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span><span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span><span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span> Project Manager <span class="tag">&lt;/<span class="name">role</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span> Architect <span class="tag">&lt;/<span class="name">role</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者所在时区， -11到12范围内的整数。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span><span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 项目贡献者属性，如即时消息如何处理等 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span> No <span class="tag">&lt;/<span class="name">dept</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。</span></span><br><span class="line"><span class="comment">         如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- license用于法律上的名称 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> Apache 2 <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 官方的license正文页面的URL --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://www.baidu.com/banseon/LICENSE-2.0.txt <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 项目分发的主要方式： </span></span><br><span class="line"><span class="comment">                    repo，可以从Maven库下载 </span></span><br><span class="line"><span class="comment">                    manual， 用户必须手动下载和安装依赖 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span> repo <span class="tag">&lt;/<span class="name">distribution</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 关于license的补充信息 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span> A business-friendly OSS license <span class="tag">&lt;/<span class="name">comments</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span> </span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span> </span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk </span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span><span class="tag">&lt;/<span class="name">tag</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://svn.baidu.com/banseon <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 组织的全名 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> demo <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 组织主页的URL --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://www.baidu.com/banseon <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构建项目需要的信息 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对</span></span><br><span class="line"><span class="comment">             于pom.xml的相对路径。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span><span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会</span></span><br><span class="line"><span class="comment">             被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span><span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。</span></span><br><span class="line"><span class="comment">             该路径是相对于pom.xml的相对路径。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span><span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span><span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 被编译过的测试class文件存放的目录。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span><span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用来自该项目的一系列构建扩展 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 描述使用到的构建扩展。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 构建扩展的groupId --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 构建扩展的artifactId --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 构建扩展的版本 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span><span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在</span></span><br><span class="line"><span class="comment">             最终的打包文件里。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。</span></span><br><span class="line"><span class="comment">                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为</span></span><br><span class="line"><span class="comment">                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span><span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素</span></span><br><span class="line"><span class="comment">                     里列出。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span><span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 包含的模式列表，例如**/*.xml. --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span><span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 描述了测试相关的资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。</span></span><br><span class="line"><span class="comment">                     举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为</span></span><br><span class="line"><span class="comment">                    org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span><span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素</span></span><br><span class="line"><span class="comment">                     里列出。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span><span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 描述存放测试相关的资源的目录，该路径相对POM路径 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 包含的模式列表，例如**/*.xml. --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span><span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 构建产生的所有文件存放的目录 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span>&gt;</span><span class="tag">&lt;/<span class="name">filters</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本</span></span><br><span class="line"><span class="comment">             地配置都会覆盖这里的配置 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 使用的插件列表 。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- plugin元素包含描述插件所需要的信息。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 插件在仓库里的group ID --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 插件在仓库里的artifact ID --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 被使用的插件的版本（或版本范围） --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该</span></span><br><span class="line"><span class="comment">                         元素才被设置成enabled。 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- execution元素包含了插件执行需要的信息 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span> </span><br><span class="line">                            <span class="comment">&lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span>&gt;</span><span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 配置的执行目标 --&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 配置是否被传播到子POM --&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 作为DOM对象的配置 --&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 项目引入插件所需要的额外依赖 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 作为DOM对象的配置 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 该项目使用的插件列表 。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- plugin元素包含描述插件所需要的信息。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 插件在仓库里的group ID --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 插件在仓库里的artifact ID --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 被使用的插件的版本（或版本范围） --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该</span></span><br><span class="line"><span class="comment">                     元素才被设置成enabled。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- execution元素包含了插件执行需要的信息 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span><span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 配置的执行目标 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 配置是否被传播到子POM --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 作为DOM对象的配置 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 项目引入插件所需要的额外依赖 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 作为DOM对象的配置 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它能够</span></span><br><span class="line"><span class="comment">                 在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元</span></span><br><span class="line"><span class="comment">                 素并不是激活profile的唯一方式。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- profile默认是否激活的标志 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本</span></span><br><span class="line"><span class="comment">                     不是以1.4开头的JDK。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>jdk版本，如:1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 激活profile的操作系统的名字 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span> Windows XP <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span> Windows <span class="tag">&lt;/<span class="name">family</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 激活profile的操作系统体系结构 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span> x86 <span class="tag">&lt;/<span class="name">arch</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 激活profile的操作系统版本 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 5.1.2600 <span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile</span></span><br><span class="line"><span class="comment">                     就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹</span></span><br><span class="line"><span class="comment">                     配属性值字段 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 激活profile的属性的名称 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span> mavenVersion <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 激活profile的属性的值 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span> 2.0.3 <span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 </span></span><br><span class="line"><span class="comment">                     profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 如果指定的文件存在，则激活profile。 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ <span class="tag">&lt;/<span class="name">exists</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                    <span class="comment">&lt;!-- 如果指定的文件不存在，则激活profile。 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ <span class="tag">&lt;/<span class="name">missing</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 构建项目所需要的信息。参见build元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span><span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span><span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span><span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span><span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span><span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span><span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span>&gt;</span><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span>&gt;</span><span class="tag">&lt;/<span class="name">filters</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span> </span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span> </span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span><span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">                                <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span> </span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span>&gt;</span><span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">                            <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的</span></span><br><span class="line"><span class="comment">                 相对路径 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--子项目相对路径--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">modules</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 参见repositories/repository元素 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span>&gt;</span><span class="tag">&lt;/<span class="name">layout</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span>&gt;</span><span class="tag">&lt;/<span class="name">layout</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的</span></span><br><span class="line"><span class="comment">                 仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看</span></span><br><span class="line"><span class="comment">                 到所有报表的链接。参见reporting元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 参见dependencyManagement元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 参见distributionManagement元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 参见properties元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目相对路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 包含需要连接到远程仓库的信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里发布版本的下载 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），</span></span><br><span class="line"><span class="comment">                     daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，</span></span><br><span class="line"><span class="comment">                 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span><span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span> banseon-repository-proxy <span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 远程仓库名称 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> banseon-repository-proxy <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://192.168.1.169:9999/repository/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认</span></span><br><span class="line"><span class="comment">                 的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span> default <span class="tag">&lt;/<span class="name">layout</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。</span></span><br><span class="line"><span class="comment">         要获取更多信息，请看项目依赖机制。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 依赖的group ID --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.apache.maven <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的artifact ID --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> maven-artifact <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span> 3.8.1 <span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展</span></span><br><span class="line"><span class="comment">                 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。</span></span><br><span class="line"><span class="comment">                 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span> jar <span class="tag">&lt;/<span class="name">type</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，</span></span><br><span class="line"><span class="comment">                 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生</span></span><br><span class="line"><span class="comment">                 成两个单独的JAR构件。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 </span></span><br><span class="line"><span class="comment">                - compile ：默认范围，用于编译 </span></span><br><span class="line"><span class="comment">                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 </span></span><br><span class="line"><span class="comment">                - test: 用于test任务时使用 </span></span><br><span class="line"><span class="comment">                - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 </span></span><br><span class="line"><span class="comment">                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span> test <span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件</span></span><br><span class="line"><span class="comment">                 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的</span></span><br><span class="line"><span class="comment">                 依赖。此元素主要用于解决版本冲突问题 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-core <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。</span></span><br><span class="line"><span class="comment">                 可选依赖阻断依赖的传递性。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span> true <span class="tag">&lt;/<span class="name">optional</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用的报表插件和他们的配置。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- plugin元素包含描述报表插件需要的信息 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 报表插件在仓库里的group ID --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 报表插件在仓库里的artifact ID --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 被使用的报表插件的版本（或版本范围） --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 报表插件的配置 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，</span></span><br><span class="line"><span class="comment">                     有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报</span></span><br><span class="line"><span class="comment">                     表集，对应另一个执行目标 --&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 产生报表集合时，被使用的报表的配置 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 配置是否被继承到子POMs --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true/false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 这个集合里使用到哪些报表 --&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖</span></span><br><span class="line"><span class="comment">        （必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过</span></span><br><span class="line"><span class="comment">            group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 参见dependencies/dependency元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者</span></span><br><span class="line"><span class="comment">         把构件部署到远程仓库。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见</span></span><br><span class="line"><span class="comment">                 repositories/repository元素 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span> banseon-maven2 <span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> banseon maven2 <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span> file://$&#123;basedir&#125;/target/deploy <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span><span class="tag">&lt;/<span class="name">layout</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见</span></span><br><span class="line"><span class="comment">             distributionManagement/repository元素 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span> banseon-maven2 <span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> Banseon-maven2 Snapshot Repository <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 部署项目的网站需要的信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span> banseon-site <span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 部署位置的名称 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span> business api website <span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span> </span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web </span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位</span></span><br><span class="line"><span class="comment">             那些不在仓库里的构件（由于license限制）。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 构件新的group ID --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 构件新的artifact ID --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 构件新的版本号 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span>&gt;</span><span class="tag">&lt;/<span class="name">message</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值</span></span><br><span class="line"><span class="comment">             有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven </span></span><br><span class="line"><span class="comment">             2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span>&gt;</span><span class="tag">&lt;/<span class="name">status</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里</span></span><br><span class="line"><span class="comment">         activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>value<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="附件2pom文件单项配置说明">附件2：POM文件单项配置说明</h2><h3 id="localrepository">localRepository</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 本地仓库的路径。默认值为$&#123;user.home&#125;/.m2/repository。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>usr/local/maven<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="interactivemode">interactiveMode</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interactiveMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">interactiveMode</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="usepluginregistry">usePluginRegistry</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件$&#123;user.home&#125;/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">usePluginRegistry</span>&gt;</span>false<span class="tag">&lt;/<span class="name">usePluginRegistry</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="offline">offline</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">offline</span>&gt;</span>false<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="plugingroups">pluginGroups</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了org.apache.maven.plugins和org.codehaus.mojo --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--plugin的组织Id（groupId） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="proxies">proxies</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--用来配置不同的代理，多代理profiles 可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--代理元素包含配置代理时需要的信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--代理的唯一定义符，用来区分不同的代理元素。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>myproxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。  --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.somewhere.com<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">password</span>&gt;</span>somepassword<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>*.google.com|ibiblio.org<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="servers">servers</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--服务器元素包含配置服务器时需要的信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>server001<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">username</span>&gt;</span>my_login<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是$&#123;user.home&#125;/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>$&#123;usr.home&#125;/.ssh/id_dsa<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--鉴权时使用的私钥密码。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>some_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--目录被创建时的权限。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mirrors">mirrors</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--为仓库列表配置的下载镜像列表。高级设置请参阅镜像设置页面 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--给定仓库的下载镜像。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>planetmirror.com<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--镜像名称 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>PlanetMirror Australia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="profiles">profiles</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--根据环境参数来调整的构件的配置--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--该配置的唯一标识符。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="activation">Activation</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--profile默认是否激活的标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;)  --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--激活profile的操作系统体系结构  --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--激活profile的操作系统版本--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;name&#125;引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--激活profile的属性的名称--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="repositories">Repositories</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库唯一标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。  --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span><span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span><span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span>           </span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span>      </span><br><span class="line">     <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span><span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span><span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span><span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span><span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>/&gt;</span><span class="tag">&lt;<span class="name">name</span>/&gt;</span><span class="tag">&lt;<span class="name">url</span>/&gt;</span><span class="tag">&lt;<span class="name">layout</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="activeprofiles">activeProfiles</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的</span></span><br><span class="line"><span class="comment">        profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>env-test<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;maven介绍&quot;&gt;Maven介绍&lt;/h1&gt;
&lt;p&gt;Maven的本质是一个&lt;strong&gt;项目管理工具&lt;/strong&gt;，将项目开发和管理过程抽象成一个项目对象模型(POM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POM (Project Object Model):项目</summary>
      
    
    
    
    <category term="开发工具" scheme="https://vlsmhd.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="maven" scheme="https://vlsmhd.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/maven/"/>
    
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="https://vlsmhd.github.io/2023/09/26/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://vlsmhd.github.io/2023/09/26/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-26T08:06:58.379Z</published>
    <updated>2023-10-11T05:13:49.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git核心概念">git核心概念</h1><h2 id="版本控制">版本控制</h2><p>版本控制是一种<strong>记录文件内容变化，以便查阅特定版本修订情况</strong>的系统。</p><p>作用：方便回溯版本。</p><h3 id="本地版本控制系统">本地版本控制系统</h3><p>在本地利用数据库存储文件历次版本之间的差异。</p><p><img src="https://oss.javaguide.cn/github/javaguide/tools/git/%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" alt="本地版本控制系统" style="zoom:80%;" /></p><h3 id="集中化版本控制系统">集中化版本控制系统</h3><p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><figure><imgsrc="https://oss.javaguide.cn/github/javaguide/tools/git/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png"alt="集中化的版本控制系统" /><figcaption aria-hidden="true">集中化的版本控制系统</figcaption></figure><p>会出现的问题：</p><ul><li>单点故障：中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。</li><li>断网：<strong>必须联网才能工作：</strong> 受网络状况、带宽影响</li></ul><h3 id="分布式版本控制系统">分布式版本控制系统</h3><p>（Distributed Version Control System，简称 DVCS），git属于这个。</p><p>特点：客户端不只提取最新版本的文件快照，而是<strong>把整个代码仓库复制下来</strong></p><p><img src="git学习/分布式版本控制系统.png" alt="分布式版本控制系统" style="zoom:80%;" /></p><p>优势：</p><ul><li>不用联网：每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了</li><li>中央服务器：方便交换大家的修改。</li></ul><h2 id="git">git</h2><blockquote><p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用BitKeeper时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。</p></blockquote><h3 id="与其它版本管理工具的区别">与其它版本管理工具的区别</h3><p>大部分版本管理工具都是基于<strong>差异比较</strong>来对待数据，以文件变更列表的形式存储信息。</p><p><img src="git学习/2019-3deltas.png" alt="img" style="zoom: 80%;" /></p><p>原理：每提交一个修改，记录增量以△标记。</p><p>如何得到最终版本：遍历链表把全部增量添加到初始文件中。</p><p>缺陷：遍历链表耗时。</p><p>git采用<strong>快照流</strong>的形式，对待每一版本数据：</p><p>每次你提交更新，或在 Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。</p><figure><img src="git学习/2019-3snapshots.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>Version 2：FileA和C更改，B没更改，但是也会把B快照记录下来。</li></ul><h3 id="git的状态及工作区">git的状态及工作区</h3><ol type="1"><li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li><li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li><li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ol><p>工作区：</p><p><strong>Git 仓库(.git directory)</strong>、<strong>工作目录(WorkingDirectory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p><figure><img src="git学习/2019-3areas.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>工作流程：</p><ol type="1"><li>在工作目录修改文件</li><li>将文件的快照暂存到暂存区域</li><li>提交更新，提交到git仓库</li></ol><h1 id="git使用">git使用</h1><h2 id="基础命令">基础命令</h2><h3 id="获取git仓库">获取git仓库</h3><p>现有目录初始化仓库：进入某一项目目录，输入<code>git init</code>，该命令将创建一个名为<code>.git</code> 的子目录。</p><p>从服务器克隆一个现有的git仓库：<code>git clone</code></p><p>定义本地仓库的名字: <code>git clone [url] directoryname</code></p><h3 id="记录每次更新到仓库">记录每次更新到仓库</h3><ol type="1"><li><strong>检测当前文件状态</strong> : <code>git status</code></li><li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code>(针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有.txt 文件）</li><li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li><li><strong>提交更新:</strong> <code>git commit -m "代码提交信息"</code>（每次准备提交前，先用 <code>git status</code>看下，是不是都已暂存起来了， 然后再运行提交命令<code>git commit</code>）</li><li><strong>跳过使用暂存区域更新的方式</strong> :<code>git commit -a -m "代码提交信息"</code>。 <code>git commit</code>加上 <code>-a</code> 选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code> 步骤。</li><li><strong>移除文件</strong>：<code>git rm filename</code>（从暂存区域移除，然后提交。）</li><li><strong>对文件重命名</strong>：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code>这三条命令的集合)</li></ol><h4 id="git-commit">Git Commit</h4><p>Git仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样。</p><p>Git希望<strong>提交记录尽可能地轻量</strong>，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>提交结点链表：</p><figure><img src="git学习/image-20230926174535281.png"alt="image-20230926174535281" /><figcaption aria-hidden="true">image-20230926174535281</figcaption></figure><p>每一次gitcommit，都会创建一个cx结点，结点的parent指针指向上次提交的结点。</p><h3 id="推送改到远程仓库">推送改到远程仓库</h3><ul><li>如果你还没有克隆现有仓库，并<strong>欲将你的仓库连接到某个远程服务器</strong>，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code><ul><li>比如我们要让本地的一个仓库和 GitHub上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code></li></ul></li><li>将这些改动提交到远端仓库：<code>git push origin master</code>(可以把 <em>master</em> 换成你想要推送的任何分支)</li></ul><h3 id="远程仓库的移除重命名">远程仓库的移除、重命名</h3><ul><li>将 test 重命名为test1：<code>git remote rename test test1</code></li><li>移除远程仓库 test1:<code>git remote rm test1</code></li></ul><h3 id="查看提交历史">查看提交历史</h3><p>列出所有更新：<code>git log</code></p><p>查看某个人的：<code>git log --author=bob</code></p><h3 id="撤销操作">撤销操作</h3><p>重新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>取消暂存的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure><p>撤消对文件的修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="分支操作">分支操作</h3><p>在创建仓库的时候，<em>master</em>是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。我们通常在开发新功能、修复一个紧急bug等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p><p>建议：多用分支、早用分支</p><p><strong>操作演示：</strong></p><ol type="1"><li>初始状态：</li></ol><p>两次提交，主分支指向最新的提交</p><figure><img src="git学习/image-20230926175007156.png"alt="image-20230926175007156" /><figcaption aria-hidden="true">image-20230926175007156</figcaption></figure><ol start="2" type="1"><li>创建一个名字叫做 newImage 的分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch newImage</span><br></pre></td></tr></table></figure><figure><img src="git学习/image-20230926175037271.png"alt="image-20230926175037271" /><figcaption aria-hidden="true">image-20230926175037271</figcaption></figure><ul><li>新建的分支都会指向主节点在指向的提交。</li></ul><ol start="3" type="1"><li><p>不切换分支提交一份代码</p><figure><img src="git学习/image-20230926194924511.png"alt="image-20230926194924511" /><figcaption aria-hidden="true">image-20230926194924511</figcaption></figure></li></ol><ul><li>因为本次提交是在主分支的提交，所以仅有main指向最新的提交C2、</li></ul><ol start="4" type="1"><li><p>切换分支再提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout newImage;</span><br><span class="line"></span><br><span class="line">git commit;</span><br></pre></td></tr></table></figure><figure><img src="git学习/image-20230926195054090.png"alt="image-20230926195054090" /><figcaption aria-hidden="true">image-20230926195054090</figcaption></figure></li></ol><p>注意：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code>的新命令，最终会取代 <code>git checkout</code>，因为<code>checkout</code>作为单个命令有点超载（它承载了很多独立的功能）。</p><p>把新建的分支删掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>将分支推送到远端仓库（推送成功后其他人可见）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure><h4 id="分支合并">分支合并</h4><h5 id="git-merge">git merge</h5><ul><li>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent节点。翻译成自然语言相当于：“我要把这两个 parent节点本身及它们所有的祖先都包含进来。”</li></ul><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230926204311275.png" alt="image-20230926204311275" style="zoom:80%;" /></p></li><li><p>合并bugFix到main</p><p>当前所在分支：main</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230926204406178.png" alt="image-20230926204406178" style="zoom:80%;" /></p></li></ol><ul><li>C2和C3合并成C4，然后main指向C4</li><li><code>main</code> 现在指向了一个拥有两个 parent节点的提交记录。假如从 <code>main</code>开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着<code>main</code> 包含了对代码库的所有修改。</li></ul><ol start="3" type="1"><li><p>再把main合并到bugFix</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//合并到哪，切换分支到哪</span><br><span class="line">git checkout bugFix;</span><br><span class="line">//把main合并过来</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230926204647629.png" alt="image-20230926204647629" style="zoom:80%;" /></p></li></ol><ul><li>因为main继承bugFix，把 <code>bugFix</code> 移动到 <code>main</code>所指向的那个提交记录即可。</li></ul><h5 id="git-rebase">git rebase</h5><p>概念：Rebase实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>优势：可以创造更线性的提交历史。如果只允许使用 Rebase的话，代码库的提交历史将会变得异常清晰。</p><p>语法：</p><p><code>git rebase A B</code>：把分支B移到A上。</p><p><code>git rebase A</code>：把A移到HEAD所在地方</p><p>rebase可以理解为：改变基地到...</p><p>案例：</p><ol type="1"><li><p>初始化：</p><p><img src="git学习/image-20230926205410807.png" alt="image-20230926205410807" style="zoom:80%;" /></p></li></ol><p>目标：把 bugFix 分支里的工作直接移到 main分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。</p><ol start="2" type="1"><li><p>合并到main</p><p>当前所在分支：bugFix</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230926205618554.png" alt="image-20230926205618554" style="zoom:80%;" /></p></li></ol><ul><li>现在 bugFix 分支上的工作在 main的最顶端，同时我们也得到了一个更线性的提交序列。</li><li>提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase到 main 分支上的 C3 的副本。</li></ul><ol start="3" type="1"><li><p>切换分支到main，把main更新到bugFix上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230926205903609.png" alt="image-20230926205903609" style="zoom:80%;" /></p></li></ol><h2 id="高级特性">高级特性</h2><h3 id="分离head">分离head</h3><p>HEAD 是一个对当前所在分支的符号引用 ——也就是<strong>指向你正在其基础上进行工作的提交记录</strong>。</p><p>head总是指向当前分支上最近一次提交记录，通常情况指向分支名。</p><p>案例：</p><p>从main分离出去：</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230927143659502.png" alt="image-20230927143659502" style="zoom:80%;" /></p></li><li><p>开始分离</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230927143728033.png" alt="image-20230927143728033" style="zoom:80%;" /></p></li></ol><h3 id="相对引用移动">相对引用——移动</h3><p>为什么引入相对引用：通过哈希值指定提交记录不方便，还要gitlog查看一长串的字符。</p><p>使用：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录<ul><li><code>^</code>加在引用名称的后面，表示寻找这个提交记录的<code>parent</code>结点</li></ul></li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如<code>~3</code></li></ul><p>案例1：向上移动一个提交记录</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230927144208639.png" alt="image-20230927144208639" style="zoom:80%;" /></p></li><li><p>向上移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230927144503570.png" alt="image-20230927144503570" style="zoom:80%;" /></p></li></ol><ul><li>这里HEAD会自动分离</li></ul><p>案例2：使用head作为相对引用的指针参照</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230927144644440.png" alt="image-20230927144644440" style="zoom:80%;" /></p></li><li><p>分离head、向上移动一位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout c3</span><br><span class="line"></span><br><span class="line">git checkout HEAD^</span><br></pre></td></tr></table></figure><figure><img src="git学习/image-20230927144805362.png"alt="image-20230927144805362" /><figcaption aria-hidden="true">image-20230927144805362</figcaption></figure></li></ol><p>案例3：强制修改分支位置</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230927145227852.png" alt="image-20230927145227852" style="zoom:80%;" /></p></li><li><p>移动分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//让main分支回退HEAD所在结点处三个版本</span><br><span class="line">git branch -f main HEAD^3</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230927145312813.png" alt="image-20230927145312813" style="zoom:80%;" /></p></li></ol><h3 id="撤销变更">撤销变更</h3><p>方法：</p><ul><li>git reset：把分支回退几个提交记录</li><li>gitrevert：向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</li></ul><p>案例1：reset实战</p><ol type="1"><li><p>初始化：</p><p><img src="git学习/image-20230927145909531.png" alt="image-20230927145909531" style="zoom:80%;" /></p></li><li><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~1</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230927150014697.png" alt="image-20230927150014697" style="zoom:80%;" /></p></li></ol><p>案例2：revert实战</p><ol type="1"><li><p>初始化：</p><p><img src="git学习/image-20230927150413680.png" alt="image-20230927150413680" style="zoom:80%;" /></p></li><li><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD/C2</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230927150456259.png" alt="image-20230927150456259" style="zoom:80%;" /></p></li></ol><ul><li>新提交记录 <code>C2'</code>相当于一个<strong>更改</strong>：用来撤销 <code>C2</code> 这个提交，因此C2' = C1</li></ul><h3 id="移动提交记录">移动提交记录</h3><h4 id="整理提交记录">整理提交记录</h4><ul><li><code>git cherry-pick &lt;提交号&gt;...</code>：将一些提交(提交树上任何地方)复制到当前所在的位置（<code>HEAD</code>）下面</li></ul><p>案例：将 <code>side</code> 分支上的工作复制到 <code>main</code>分支</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230930181312137.png" alt="image-20230930181312137" style="zoom:67%;" /></p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure><figure><img src="git学习/image-20230930181415507.png"alt="image-20230930181415507" /><figcaption aria-hidden="true">image-20230930181415507</figcaption></figure></li></ol><p>可以看到，把side分支上的C2、C4提交记录直接按命令输入顺序复制到main（当前head所在的分支上）上了。</p><h4 id="交互式rebase">交互式rebase</h4><p>在清楚提交记录名称（C2、C4...）的情况下，使用cherry-pick可以，在未知情的情况下，利用交互式rebase：用带参数<code>--interactive</code> 的 rebase 命令。</p><ul><li>在命令后增加了这个选项, Git 会打开一个 UI界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</li><li>可以缩写为 <code>-i</code></li></ul><p>UI界面操作：</p><ul><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code>的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交。遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。</li></ul><p>案例：</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20230930182821022.png" alt="image-20230930182821022" style="zoom:67%;" /></p></li><li><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20230930182907601.png" alt="image-20230930182907601" style="zoom: 67%;" /></p></li><li><p>结果（自定义）</p><p><img src="git学习/image-20230930182936362.png" alt="image-20230930182936362" style="zoom:67%;" /></p></li></ol><h3 id="只提取一个提交记录">只提取一个提交记录</h3><blockquote><p>开发场景：我正在解决某个特别棘手的Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个Bug 的根本原因。最后就差把 <code>bugFix</code> 分支里的工作合并回<code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到<code>main</code> 分支上，但这样的话 <code>main</code>分支就会包含我这些调试语句了。</p></blockquote><p>更好的解决方法：</p><p>让 Git复制解决问题的那一个提交记录就可以了，把那个提交记录合并到main就可以。命令如下：</p><ul><li><code>git rebase -i</code></li><li><code>git cherry-pick</code></li></ul><h3 id="提交的技巧">提交的技巧</h3><p>开发场景1：你之前在 <code>newImage</code>分支上进行了一次提交，然后又基于它创建了 <code>caption</code>分支，然后又提交了一次。此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下<code>newImage</code>中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>使用<code>git rebase -i</code>步骤：</p><ul><li>先用 <code>git rebase -i</code>将提交重新排序，然后把我们想要修改的提交记录挪到最前</li><li>然后用 <code>git commit --amend</code> 来进行一些小修改</li><li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li><li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法）</li></ul><p>案例1：用 <code>git rebase -i</code></p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20231004175032221.png" alt="image-20231004175032221" style="zoom:67%;" /></p></li><li><p>git rebase -i调整</p><figure><img src="git学习/image-20231004175800640.png"alt="image-20231004175800640" /><figcaption aria-hidden="true">image-20231004175800640</figcaption></figure><p>复制两次</p></li><li><p>移动main到caption</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase C3<span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>目标结果</p><p><img src="git学习/image-20231004175107960.png" alt="image-20231004175107960" style="zoom: 80%;" /></p></li></ol><p>案例2：使用git cherry-pick</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20231004180311310.png" alt="image-20231004180311310" style="zoom:67%;" /></p></li><li><p>复制C2、C3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick C2</span><br><span class="line">git checkout c1</span><br><span class="line">git cherry-pick C2 C3</span><br></pre></td></tr></table></figure><figure><img src="git学习/image-20231004185159887.png"alt="image-20231004185159887" /><figcaption aria-hidden="true">image-20231004185159887</figcaption></figure></li><li><p>移动main到head</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD</span><br></pre></td></tr></table></figure></li><li><p>目标结果：</p><p><img src="git学习/image-20231004180338649.png" alt="image-20231004180338649" style="zoom:67%;" /></p></li></ol><h3 id="git-tag">git tag</h3><p><em>永远</em>指向某个提交记录的标识，比如软件发布新的大版本，或者是修正一些重要的Bug 或是增加了某些新特性。</p><blockquote><p>是提交树上的一个锚点，标识了某个特定的位置。</p></blockquote><p>语法：<code>git tag 名称 提交</code></p><p>案例：</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20231007231130175.png" alt="image-20231007231130175" style="zoom:67%;" /></p></li><li><p>执行语法：</p><figure><img src="git学习/image-20231007232054050.png"alt="image-20231007232054050" /><figcaption aria-hidden="true">image-20231007232054050</figcaption></figure></li><li><p>结果：</p><p><img src="git学习/image-20231007232106504.png" alt="image-20231007232106504" style="zoom:80%;" /></p></li></ol><h3 id="git-describe">git Describe</h3><p>Git专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），就是<code>git describe</code></p><ul><li><code>git bisect</code>：一个查找产生 Bug 的提交记录的指令</li></ul><p>语法规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;ref&gt;</code> 是<strong>任何能被 Git识别成提交记录的引用</strong>，如果你没有指定的话，Git会使用你目前所在的位置（<code>HEAD</code>）</li></ul><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><code>tag</code> 表示的是离 <code>ref</code> 最近的标签</li><li><code>numCommits</code> 是表示这个 <code>ref</code> 与<code>tag</code> 相差有多少个提交记录</li><li><code>hash</code> 表示的是你所给定的 <code>ref</code>所表示的提交记录哈希值的前几位</li></ul><p>案例：</p><p><img src="git学习/image-20231008225829759.png" alt="image-20231008225829759" style="zoom: 80%;" /></p><p><code>git describe main</code> 会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1_2_gC2</span><br></pre></td></tr></table></figure><p><code>git describe side</code> 会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v2_1_gC4</span><br></pre></td></tr></table></figure><h3 id="多分支rebase">多分支rebase</h3><p>案例：</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20231009131401336.png" alt="image-20231009131401336" style="zoom:67%;" /></p></li><li><p>命令</p><figure><img src="git学习/image-20231009131329216.png"alt="image-20231009131329216" /><figcaption aria-hidden="true">image-20231009131329216</figcaption></figure><p>简洁版</p><figure><img src="git学习/image-20231009132036143.png"alt="image-20231009132036143" /><figcaption aria-hidden="true">image-20231009132036143</figcaption></figure></li><li><p>结果</p><p><img src="git学习/image-20231009131256122.png" alt="image-20231009131256122" style="zoom:67%;" /></p></li></ol><h3 id="选择parent提交记录">选择parent提交记录</h3><p>案例1：</p><p><img src="git学习/image-20231010131119309.png" alt="image-20231010131119309" style="zoom: 80%;" /></p><p>执行代码1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20231010131812799.png" alt="image-20231010131812799" style="zoom:67%;" /></p><p>执行代码2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^2</span><br></pre></td></tr></table></figure><p><img src="git学习/image-20231010132028173.png" alt="image-20231010132028173" style="zoom:67%;" /></p><p>用 <code>^</code> 和 <code>~</code> 可以自由地在提交树中移动：</p><p><img src="git学习/image-20231010132208452.png" alt="image-20231010132208452" style="zoom:67%;" /></p><p>git checkout HEAD~;</p><p>git checkout HEAD^2;</p><p>git checkout HEAD~2;</p><p>以上三段代码缩减为：git checkout HEAD<sub>^2</sub>2</p><p><img src="git学习/image-20231010132153825.png" alt="image-20231010132153825" style="zoom:67%;" /></p><h3 id="分支提交分发">分支提交分发</h3><p>案例：</p><p><code>main</code> 分支是比 <code>one</code>、<code>two</code> 和<code>three</code> 要多几个提交。出于某种原因，我们需要把<code>main</code>分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p><p><code>one</code> 需要重新排序并删除 <code>C5</code>，<code>two</code>仅需要重排排序，而 <code>three</code> 只需要提交一次。</p><ol type="1"><li><p>初始化</p><p><img src="git学习/image-20231011124801130.png" alt="image-20231011124801130" style="zoom:67%;" /></p></li><li><p>执行代码</p><figure><img src="git学习/image-20231011131018723.png"alt="image-20231011131018723" /><figcaption aria-hidden="true">image-20231011131018723</figcaption></figure></li><li><p>结果</p><p><img src="git学习/image-20231011124816572.png" alt="image-20231011124816572" style="zoom:67%;" /></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git核心概念&quot;&gt;git核心概念&lt;/h1&gt;
&lt;h2 id=&quot;版本控制&quot;&gt;版本控制&lt;/h2&gt;
&lt;p&gt;版本控制是一种&lt;strong&gt;记录文件内容变化，以便查阅特定版本修订情况&lt;/strong&gt;的系统。&lt;/p&gt;
&lt;p&gt;作用：方便回溯版本。&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="开发工具" scheme="https://vlsmhd.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="git" scheme="https://vlsmhd.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/"/>
    
    
  </entry>
  
  <entry>
    <title>小林操作系统图解学习笔记</title>
    <link href="https://vlsmhd.github.io/2023/09/21/%E5%B0%8F%E6%9E%97%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://vlsmhd.github.io/2023/09/21/%E5%B0%8F%E6%9E%97%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-21T09:23:59.557Z</published>
    <updated>2023-10-11T09:27:45.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件结构">硬件结构</h1><h1 id="操作系统结构">操作系统结构</h1><h2 id="内核">内核</h2><p>内核的概念：应用程序和外部硬件设备交互的桥梁。</p><p><img src="小林操作系统图解学习笔记/Kernel_Layout.png" alt="内核" style="zoom: 33%;"></p><p>内核的作用：</p><ul><li>进程、线程管理：</li><li>内存管理：</li><li>硬件设施管理：</li><li>内核调用：应用程序需要更高权限运行的服务，必须要有内核调用，是用户程序与操作系统之间的接口</li></ul><p>内核的工作流程</p><p>大多数的操作系统，内存会有俩区域：</p><ul><li>内核空间，这个内存空间只有内核程序可以访问；</li><li>用户空间，这个内存空间专门给应用程序使用；</li></ul><p>系统调用过程：</p><p><img src="小林操作系统图解学习笔记/systemcall.png" alt="img" style="zoom:67%;"></p><ul><li>第一次中断：中断用户程序</li><li>第二次中断：中断内核程序</li></ul><h2 id="linux设计">linux设计</h2><p>设计理念：</p><ul><li><em>MultiTask</em>，多任务</li><li><em>SMP</em>，对称多处理</li><li><em>ELF</em>，可执行文件链接格式</li><li><em>Monolithic Kernel</em>，宏内核</li></ul><h3 id="multitask">MultiTask</h3><p>多任务机制：</p><ul><li>单CPU并发</li><li>多CPU并行</li></ul><h3 id="smp">SMP</h3><p><strong>对称多处理</strong>，每个CPU的权重低位是相同的，对资源的使用权限相同。</p><p>每个CPU都共享整个内存空间。</p><h3 id="elf">ELF</h3><p>定义：可执行文件链接格式</p><p>结构：</p><p><img src="小林操作系统图解学习笔记/Elf.png" alt="ELF 文件格式" style="zoom: 33%;"></p><p>ELF文件的生成：</p><p>编写的代码，首先通过「<strong>编译器</strong>」编译成汇编代码，接着通过「<strong>汇编器</strong>」变成目标代码，也就是目标文件，最后通过「<strong>链接器</strong>」把多个目标文件以及调用的各种函数库链接起来，形成一个可执行文件，也就是ELF 文件。</p><p>ELF文件的执行：</p><p>利用<strong>装载器</strong>把ELF文件装载到内存中，CPU读取内存中的指令和数据，于是程序就被执行起来了。</p><h3 id="monolithic-kernel">Monolithic Kernel</h3><p>Monolithic Kernel 的意思是<strong>宏内核</strong>，Linux内核架构就是宏内核，</p><figure><img src="小林操作系统图解学习笔记/OS-structure2.png" alt="分别为宏内核、微内核、混合内核的操作系统结构"><figcaption aria-hidden="true">分别为宏内核、微内核、混合内核的操作系统结构</figcaption></figure><h2 id="windows设计">windows设计</h2><p>Windows NT 的结构图片：</p><p><img src="小林操作系统图解学习笔记/windowNT.png" alt="Windows NT 的结构" style="zoom:50%;"></p><p>windows可执行文件：</p><p>可执行文件格式叫PE，称为<strong>可移植执行文件</strong>，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等。</p><p>PE结构：</p><p><img src="小林操作系统图解学习笔记/pe.png" alt="PE 文件结构" style="zoom:80%;"></p><h1 id="内存管理">内存管理</h1><h2 id="虚拟内存">虚拟内存</h2><p>单片机：一次性只能烧录一个程序运行，<strong>无法运行多个程序</strong>。</p><p>操作系统利用虚拟内存解决多程序运行的问题：</p><p>内存隔离：把进程所使用的地址隔离开，让每个进程都<strong>拥有自己的内存地址</strong>——虚拟内存</p><p>内存映射：把虚拟内存和真实物理内存一 一映射</p><ul><li>虚拟内存地址</li><li>物理内存地址</li></ul><p>转换过程：</p><p><img src="小林操作系统图解学习笔记/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="img" style="zoom:50%;"></p><p>管理虚存地址和物理内存地址的方式：内存分段、内存分页、段页混合式管理。</p><h2 id="内存分段">内存分段</h2><p>程序由多个段组成：</p><ul><li>代码段</li><li>数据分段</li><li>栈段</li><li>堆段</li></ul><p>采用分段，将以上的段分离</p><p><strong>分段机制下，虚拟——&gt;真实地址的映射</strong></p><p>虚拟地址的组成：</p><ul><li>段选择因子：保存在<strong>段寄存器</strong>里。其中包含：<ul><li>段号：段表的索引</li><li>标志位等</li></ul></li><li>段内偏移量：位于 0 和段界限之间</li></ul><p><img src="小林操作系统图解学习笔记/a9ed979e2ed8414f9828767592aadc21.png" alt="img" style="zoom: 50%;"></p><p>CPU解析虚拟地址，通过段选择因子获取段表索引，查找到对应段的段内描述符，获取段内描述符里的段基地址，配合段内偏移量找到对应的物理地址。</p><ul><li>段表：<ul><li>段内描述符<ul><li>段基地址：段的起始地址（低地址）</li><li>段界限</li><li>DPL</li></ul></li></ul></li></ul><p>程序分段示意图：</p><p><img src="小林操作系统图解学习笔记/c5e2ab63e6ee4c8db575f3c7c9c85962.png" alt="程序分段示意图" style="zoom:67%;"></p><p>分段的缺陷：内存碎片、内存交换效率低</p><p><strong>内存碎片</strong></p><p>分类：</p><ul><li>内部碎片</li><li>外部碎片</li></ul><p><img src="小林操作系统图解学习笔记/6142bc3c917e4a6298bdb62936e0d332.png" alt="img" style="zoom:50%;"></p><p>分段不会产生内部碎片，因为段根据实际需要分配内存。但是多个段之间会产生外部碎片，导致其它程序无法运行。</p><p><strong>交换效率低</strong></p><p>有外部内存碎片，就要重新swap内存区域，swap是内存和磁盘进行交互，由于磁盘IO速度过慢，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上，所以显得效率很慢。</p><h2 id="内存分页">内存分页</h2><p>分页，就是把虚拟空间和物理空间都切成一段段大小相同的内存块。通过<strong>页表</strong>来映射。</p><p><img src="小林操作系统图解学习笔记/08a8e315fedc4a858060db5cb4a654af.png" alt="img" style="zoom:50%;"></p><ul><li><p>页表存储在内存，通过MMU（内存管理单元）</p></li><li><p>缺页异常：虚拟地址在页表中查不到</p></li></ul><p><strong>分页机制下，虚拟——&gt;真实地址的映射</strong></p><p>虚拟地址组成：</p><ul><li>页号</li><li>页内偏移量</li></ul><p>页表项组成：</p><ul><li>虚拟页号</li><li>物理页号</li></ul><p><img src="小林操作系统图解学习笔记/7884f4d8db4949f7a5bb4bbd0f452609.png" alt="img" style="zoom:50%;"></p><p>分页解决内存外部碎片问题，但是出现内部碎片问题：</p><p>页与页之间紧密排列，不会出现外部碎片，但是由于每页大小固定，但是进程占多少页不清楚，而<strong>内存分配的最小单位是页</strong>，有可能进程的某部分只占了一页的一小部分大小，这时候这个页也会被标记已经使用，从而浪费掉一段空间。这浪费掉的一段空间就叫内部碎片。</p><p>分页提高内存交换效率：</p><p>内存空间不够的时候，操作系统会把正在运行的进程<strong>最近最少使用</strong>的页，给<strong>换出</strong>（swapout）到磁盘中，等待需要的时候再<strong>换入</strong>（swapin）内存。</p><p><img src="小林操作系统图解学习笔记/388a29f45fe947e5a49240e4eff13538-20230309234651917.png" alt="img" style="zoom: 40%;"></p><p>分页的最大优点就是：加载程序的时候，没必要一次性把程序都加载到物理内存，而是通过虚存的页映射到物理内存的页的时候，根据当前的需要加载特定的页即可。</p><p>缺陷：</p><ul><li><p>内部碎片</p></li><li><p>存储页表项需要耗费大量空间</p><p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code>的内存来存储页表。这 4MB大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</p><p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code>的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p></li></ul><h3 id="多级页表">多级页表</h3><p>在32位系统、页大小4KB、页表项4B的情况下，一个进程的页表需要装下 100多万个「页表项」，并且每个页表项是占用 4字节大小的，于是相当于每个页表需占用 4MB大小的空间，对这些页表项进行二级分页处理：</p><p><img src="小林操作系统图解学习笔记/19296e249b2240c29f9c52be70f611d5.png" alt="img" style="zoom: 50%;"></p><p>为什么二级页表会减少空间消耗？</p><p>假如一个进程需要4GB的内存空间，如果全部映射到物理内存，那二级页表占用空间&gt;一级页表，但是实际上程序执行的时候操作系统不会为该进程分配全部内存。</p><p>局部性原理来解释：</p><p>每个进程都有 4GB的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。</p><ul><li>假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有4KB（一级页表） + 20% * 4MB（二级页表）=<code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 小得多</li></ul><p>64位系统的分页：</p><ul><li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li><li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li><li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li><li>页表项 PTE（<em>Page Table Entry</em>）；</li></ul><p><img src="小林操作系统图解学习笔记/四级分页.png" alt="img" style="zoom: 33%;"></p><h3 id="tlb">TLB</h3><p>程序是有局部性的，即<strong>在一段时间内，整个程序的执行仅限于程序中的某一部分</strong>。相应地，执行所访问的存储空间也局限于某个内存区域。</p><p><img src="小林操作系统图解学习笔记/edce58534d9342ff89f5261b1929c754.png" alt="局部性原理" style="zoom:50%;"></p><p>把这些热点页进行缓存，无疑是提高效率的良好途径。于是CPU中添加了缓存：TLB（<em>TranslationLookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p><p><img src="小林操作系统图解学习笔记/a3cdf27646b24614a64cfc5d7ccffa35.png" alt="CPU与TLB的结构关系" style="zoom:67%;"></p><h2 id="段页式内存管理">段页式内存管理</h2><p>实现方式：</p><ol type="1"><li>把程序分成多个段：代码段、栈段...</li><li>把每个段分成多个页</li></ol><p>虚拟地址结构：</p><ul><li>段号</li><li>页号</li><li>页内偏移量</li></ul><p><img src="小林操作系统图解学习笔记/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="段页式虚存物存映射" style="zoom:50%;"></p><h2 id="内存达到上限的处理">内存达到上限的处理</h2><h3 id="内存分配的过程">内存分配的过程</h3><ol type="1"><li><p>malloc分配：申请虚拟内存，此时并没有分配物理内存</p></li><li><p>缺页中断：应用程序访问这片内存，发现没有映射到物理内存，CPU产生缺页中断，进程从用户态变为内核态，并将缺页中断交给内核的Page Fault Handler （缺页中断函数）处理。</p></li><li><p>缺页函数判断有无空闲空间，进行分配，如果没有空闲空间，进行<strong>内存回收</strong></p></li></ol><p>内存回收：</p><ul><li>后台内存回收：唤醒kswapd内核线程来<strong>异步</strong>的回收内存。</li><li>直接内存回收：假如后台回收的速度赶不上进程申请内存的速度，会将进程阻塞，转而同步回收内存。</li></ul><p>OOM机制：</p><p>触发条件：如果内存回收后依旧没有足够的内存分配给进程，则触发该机制。</p><p>作用：OOM Killer机制会根据算法选择一个占用物理内存较高的进程，杀死该进程，（循环进行），直到有足够空间分配</p><p>流程：</p><p><img src="小林操作系统图解学习笔记/2f61b0822b3c4a359f99770231981b07.png" alt="img" style="zoom:50%;"></p><h3 id="可以被回收的内存">可以被回收的内存</h3><p><strong>文件页：</strong></p><ul><li>内核缓存的磁盘、文件数据，这些都属于干净页，可以直接释放。</li><li>被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），还需要先写入磁盘，才能释放内存</li></ul><p><strong>匿名页：</strong></p><p>没有实际载体的数据，例如：堆栈数据等</p><p>回收方式：Linux的Swap机制</p><p>LRU回收算法：</p><p>LRU维护的队列：</p><ul><li><strong>active_list</strong>活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li><li><strong>inactive_list</strong>不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li></ul><p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p><p>回收影响：</p><p>动用磁盘IO，影响机器性能。</p><h4 id="降低内存回收带来的性能影响">降低内存回收带来的性能影响</h4><h5 id="调整文件页和匿名页的回收倾向">调整文件页和匿名页的回收倾向</h5><p>文件页中，干净页直接回收，效率高于脏页。一般只要动用linux的swap机制，就会触发IO</p><p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code>选项，用来调整文件页和匿名页的回收倾向。</p><p><code>swappiness</code> 的范围是 0-100，数值越大，越积极使用Swap，也就是更倾向于回收匿名页；数值越小，越消极使用Swap，也就是更倾向于回收文件页。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]# cat /proc/sys/vm/swappiness</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>一般建议 swappiness 设置为 0（默认值是60），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p><h5 id="尽早触发-kswapd-内核线程异步回收内存">尽早触发 kswapd内核线程异步回收内存</h5><p>内核定义三个内存阈值（watermark，也称为水位），用来衡量当前剩余内存（pages_free）是否充裕或者紧张，分别是：</p><ul><li>页最小阈值（pages_min）；</li><li>页低阈值（pages_low）；</li><li>页高阈值（pages_high）；</li></ul><p>对应四种内存使用情况：</p><p><img src="小林操作系统图解学习笔记/166bc9f5b7c545d89f1e36ab8dd772cf.png" alt="img" style="zoom:67%;"></p><p>kswapd会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作：</p><ul><li>在橙色范围，kswapd 0线程会<strong>异步</strong>进行内存回收</li><li>在红色范围，kswapd 会进行直接内存回收。阻塞进程</li></ul><h5 id="numa-架构下的内存回收策略">NUMA 架构下的内存回收策略</h5><p>CPU的两种架构：</p><h6 id="smp架构">SMP架构</h6><p><img src="小林操作系统图解学习笔记/image-20231011171048345.png" alt="image-20231011171048345" style="zoom:80%;"></p><p>多个CPU通过一条总线共享内存资源，CPU地位相同。也被称为一致存储访问结构（UMA，UniformMemory Access）。</p><p>缺陷：总线带宽压力大，CPU越多，每个CPU分得的带宽越少。</p><h6 id="numa架构">NUMA架构</h6><p><img src="小林操作系统图解学习笔记/image-20231011171155253.png" alt="image-20231011171155253" style="zoom:80%;"></p><p>分组CPU思想：每组称为Node，有自己独立的内存、总线、IO等，每个 Node之间可以通过<strong>互联模块总线</strong>（QPI）进行通信，</p><p>NUMA回收策略：</p><p>当一个结点的内存不足时，系统可以从其它结点找空闲内存，也可以对自己的内存空间进行释放。</p><p>具体选哪种模式，可以通过 /proc/sys/vm/zone_reclaim_mode来控制。它支持以下几个选项：</p><ul><li>0 （默认值）：在回收本地内存之前，在其他 Node 寻找空闲内存；</li><li>1：只回收本地内存；</li><li>2：只回收本地内存，在本地回收内存时，可以将文件页中的脏页写回硬盘，以回收内存。</li><li>4：只回收本地内存，在本地回收内存时，可以用 swap 方式回收内存。</li></ul><blockquote><p>虽然说访问远端 Node的内存比访问本地内存要耗时很多，但是相比内存回收的危害而言，访问远端Node 的内存带来的性能影响还是比较小的。因此，zone_reclaim_mode一般建议设置为 0。</p></blockquote><h3 id="如何保证进程不被oom杀死">如何保证进程不被OOM杀死</h3><p>linux系统根据<strong>某种标准</strong>杀死进程：</p><p>在 Linux 内核里有一个 <code>oom_badness()</code>函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。</p><p>影响得分因素：</p><ul><li>进程使用的物理页面数</li><li>每个进程的 OOM 校准值 <code>oom_score_adj</code>。它是可以通过<code>/proc/[pid]/oom_score_adj</code> 来配置的。我们可以在设置 -1000 到1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。</li></ul><p>函数 oom_badness() 里的最终计算方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// points 代表打分的结果</span></span><br><span class="line"><span class="comment">// process_pages 代表进程已经使用的物理内存页面数</span></span><br><span class="line"><span class="comment">// oom_score_adj 代表 OOM 校准值</span></span><br><span class="line"><span class="comment">// totalpages 代表系统总的可用页面数</span></span><br><span class="line">points = process_pages + oom_score_adj*totalpages/<span class="number">1000</span></span><br></pre></td></tr></table></figure><p>不想杀死一个进程，就把校准值降低。</p><blockquote><p>一般来说，我们最好将一些很重要的系统服务的 oom_score_adj 配置为-1000，比如sshd，因为这些系统服务一旦被杀掉，我们就很难再登陆进系统了。</p></blockquote><h1 id="进程管理">进程管理</h1><h1 id="调度算法">调度算法</h1><h1 id="文件系统">文件系统</h1><h1 id="设备管理">设备管理</h1><h1 id="网络系统">网络系统</h1><h1 id="section"></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;硬件结构&quot;&gt;硬件结构&lt;/h1&gt;
&lt;h1 id=&quot;操作系统结构&quot;&gt;操作系统结构&lt;/h1&gt;
&lt;h2 id=&quot;内核&quot;&gt;内核&lt;/h2&gt;
&lt;p&gt;内核的概念：应用程序和外部硬件设备交互的桥梁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;小林操作系统图解学习笔记/Kernel_</summary>
      
    
    
    
    <category term="操作系统" scheme="https://vlsmhd.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="学习" scheme="https://vlsmhd.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="操作系统" scheme="https://vlsmhd.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>jenkins</title>
    <link href="https://vlsmhd.github.io/2023/09/10/jenkins/"/>
    <id>https://vlsmhd.github.io/2023/09/10/jenkins/</id>
    <published>2023-09-10T11:18:54.846Z</published>
    <updated>2023-09-10T12:52:35.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ci概念">CI概念</h1><p>持续集成（ Continuous integration ， 简称 CI）指的是，频繁地（一天多次）将代码集成到主干</p><figure><img src="jenkins/image-20210802000658790.png"alt="image-20210802000658790" /><figcaption aria-hidden="true">image-20210802000658790</figcaption></figure><p><strong>持续集成的组成要素</strong></p><p>一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、测试统计等都是自动完成的， 无需人工干预。</p><p>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用SVN或Git。</p><p>一个持续集成服务器， Jenkins就是一个配置简单和使用方便的持续集成服务器。</p><p><strong>持续集成的好处</strong></p><p>1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；2、对系统健康持续检查，减少发布风险带来的问题； 3、减少重复性工作；4、持续部署，提供可部署单元包； 5、持续交付可供使用的版本；6、增强团队信心；</p><h1 id="jenkins安装配置">Jenkins安装配置</h1><h2 id="jenkins介绍">Jenkins介绍</h2><figure><img src="jenkins/image-20210802011553923.png"alt="image-20210802011553923" /><figcaption aria-hidden="true">image-20210802011553923</figcaption></figure><p>Jenkins 是一款流行的开源持续集成（ContinuousIntegration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。官网：http://jenkins-ci.org/。</p><p>Jenkins的特征：</p><ul><li>开源的 Java语言开发持续集成工具，支持持续集成，持续部署。</li><li>易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可方便web界面配置管理。</li><li>消息通知及测试报告：集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生成JUnit/TestNG测试报告。</li><li>分布式构建：支持 Jenkins能够让多台计算机一起构建/测试。</li><li>文件识别：Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。</li><li>丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven，docker等。</li></ul><p>Jenkins安装和持续集成环境配置</p><figure><img src="jenkins/image-20210802011607894.png"alt="image-20210802011607894" /><figcaption aria-hidden="true">image-20210802011607894</figcaption></figure><p>1 ）首先，开发人员每天进行代码提交，提交到Git仓库</p><p>2）然后，Jenkins作为持续集成工具，使用Git工具到Git仓库拉取代码到集成服务器，再配合JDK，Maven等软件完成代码编译，代码测试与审查，测试，打包等工作，在这个过程中每一步出错，都重新再执行一次整个流程。</p><p>3）最后，Jenkins把生成的jar或war包分发到测试服务器或者生产服务器，测试人员或用户就可以访问应用。</p><h2 id="jenkins环境搭建">Jenkins环境搭建</h2><h3 id="jenkins安装配置-1">Jenkins安装配置</h3><p>导入镜像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器用户名：root   密码：itcast</span><br><span class="line"></span><br><span class="line">jenkins  用户名：itcast   密码：itcast</span><br></pre></td></tr></table></figure><ol type="1"><li><p>采用YUM方式安装</p><p>加入jenkins安装源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo --no-check-certificate</span><br><span class="line"></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><p>执行yum命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install jenkins</span><br></pre></td></tr></table></figure></li><li><p>采用RPM安装包方式</p><p><ahref="https://pkg.jenkins.io/redhat-stable/">Jenkins安装包下载地址</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.jenkins.io/redhat-stable/jenkins-2.190.1-1.1.noarch.rpm</span><br></pre></td></tr></table></figure><p>执行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jenkins-2.190.1-1.1.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>配置：</p><p>修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure><p>修改内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改为对应的目标用户， 这里使用的是root</span></span><br><span class="line"><span class="variable">$JENKINS_USER</span>=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="comment"># 服务监听端口</span></span><br><span class="line">JENKINS_PORT=<span class="string">&quot;16060&quot;</span></span><br></pre></td></tr></table></figure><p>目录权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R root:root /var/lib/jenkins</span><br><span class="line"><span class="built_in">chown</span> -R root:root /var/cache/jenkins</span><br><span class="line"><span class="built_in">chown</span> -R root:root /var/log/jenkins</span><br></pre></td></tr></table></figure><p>重启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure><p>如果启动失败， 出现错误信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Starting Jenkins bash: /usr/bin/java: No such file or directory</span><br></pre></td></tr></table></figure><p>创建JAVA环境的软链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/jdk/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure></li><li><p>管理后台初始化设置</p><p>http://192.168.200.100:16060/</p><p>需要输入管理密码， 在以下位置查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><figure><img src="jenkins/image-20210802011625800.png"alt="image-20210802011625800" /><figcaption aria-hidden="true">image-20210802011625800</figcaption></figure><p>按默认设置，把建议的插件都安装上</p><figure><img src="jenkins/image-20210802011638639.png"alt="image-20210802011638639" /><figcaption aria-hidden="true">image-20210802011638639</figcaption></figure><p>这一步等待时间较长， 安装完成之后， 创建管理员用户：</p><figure><img src="jenkins/image-20210802011653454.png"alt="image-20210802011653454" /><figcaption aria-hidden="true">image-20210802011653454</figcaption></figure></li></ol><p>配置访问地址：</p><figure><img src="jenkins/image-20210802011707013.png"alt="image-20210802011707013" /><figcaption aria-hidden="true">image-20210802011707013</figcaption></figure><p>配置完成之后， 会进行重启， 之后可以看到管理后台：</p><figure><img src="jenkins/image-20210802011723835.png"alt="image-20210802011723835" /><figcaption aria-hidden="true">image-20210802011723835</figcaption></figure><h3 id="jenkins插件安装">Jenkins插件安装</h3><p>在实现持续集成之前， 需要确保以下插件安装成功。</p><ul><li>Maven Integration plugin： Maven 集成管理插件。</li><li>Docker plugin： Docker集成插件。</li><li>GitLab Plugin： GitLab集成插件。</li><li>Publish Over SSH：远程文件发布插件。</li><li>SSH: 远程脚本执行插件。</li></ul><p>安装方法：</p><ol type="1"><li><p>进入【系统管理】-【插件管理】</p></li><li><p>点击标签页的【可选插件】</p><p>在过滤框中搜索插件名称</p><figure><img src="jenkins/image-20210802011740056.png"alt="image-20210802011740056" /><figcaption aria-hidden="true">image-20210802011740056</figcaption></figure></li><li><p>勾选插件， 点击直接安装即可。</p></li></ol><blockquote><p>注意，如果没有安装按钮，需要更改配置</p><p>在安装插件的高级配置中，修改升级站点的连接为：http://updates.jenkins.io/update-center.json保存</p><figure><img src="jenkins/image-20210802011758588.png"alt="image-20210802011758588" /><figcaption aria-hidden="true">image-20210802011758588</figcaption></figure></blockquote><h4 id="git安装配置">Git安装配置</h4><ol type="1"><li><p>yum 安装方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure></li><li><p>采用源码包方式安装</p><ul><li><p>安装依赖包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br><span class="line">yum -y install gcc perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure></li><li><p>如果之前有安装旧版本， 先做卸载， 没有安装则忽略</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure></li><li><p>下载源码包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-1.8.3.1.tar.gz</span><br><span class="line">tar -xvf git-1.8.3.1.tar.gz</span><br></pre></td></tr></table></figure><p>也可以安装其他版本，地址：https://mirrors.edge.kernel.org/pub/software/scm/git/</p></li><li><p>编译安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> git-1.8.3.1</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/usr/local/git/bin&quot;</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>检查git版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]<span class="comment"># git version</span></span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure></li></ol><h4 id="maven安装配置">Maven安装配置</h4><ol type="1"><li><p>下载安装包</p><p>下载地址： https://maven.apache.org/download.cgi</p></li><li><p>解压安装包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line">unzip -o apache-maven-3.6.1.zip </span><br></pre></td></tr></table></figure><p>上传本地仓库并解压</p><figure><img src="jenkins/image-20210802013808080.png"alt="image-20210802013808080" /><figcaption aria-hidden="true">image-20210802013808080</figcaption></figure></li><li><p>配置</p><p>环境变量配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>增加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_HOME=/usr/local/maven/apache-maven-3.6.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$MAVEN_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>如果权限不够，则需要增加当前目录的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /usr/local/maven/apache-maven-3.6.1/bin/mvn</span><br></pre></td></tr></table></figure><p>修改镜像仓库配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/maven/apache-maven-3.6.1/conf/settings.xml</span><br></pre></td></tr></table></figure><p>需要把本机的仓库打包上传到服务器上（不上传会自动下载）</p><p>然后指定上传后的仓库配置</p><figure><img src="jenkins/image-20210802013533421.png"alt="image-20210802013533421" /><figcaption aria-hidden="true">image-20210802013533421</figcaption></figure></li></ol><h4 id="docker安装配置">Docker安装配置</h4><ol type="1"><li><p>更新软件包版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure></li><li><p>卸载旧版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure></li><li><p>安装软件依赖包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>设置yum源为阿里云</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装后查看docker版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><p>启动</p><p>设置开机启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li></ol><h4 id="docker-registry私有仓库安装配置">DockerRegistry私有仓库安装配置</h4><h3 id="jenkins工具配置">Jenkins工具配置</h3><ol type="1"><li><p>进入【系统管理】--&gt; 【全局工具配置】</p><figure><img src="jenkins/image-20210802011944005.png"alt="image-20210802011944005" /><figcaption aria-hidden="true">image-20210802011944005</figcaption></figure></li><li><p>MAVEN配置全局设置</p><figure><img src="jenkins/image-20210802011956261.png"alt="image-20210802011956261" /><figcaption aria-hidden="true">image-20210802011956261</figcaption></figure></li><li><p>指定JDK配置</p><figure><img src="jenkins/image-20210802012010244.png"alt="image-20210802012010244" /><figcaption aria-hidden="true">image-20210802012010244</figcaption></figure></li><li><p>指定MAVEN 目录</p><figure><img src="jenkins/image-20210802012026476.png"alt="image-20210802012026476" /><figcaption aria-hidden="true">image-20210802012026476</figcaption></figure></li><li><p>指定DOCKER目录</p><figure><img src="jenkins/image-20210802012038581.png"alt="image-20210802012038581" /><figcaption aria-hidden="true">image-20210802012038581</figcaption></figure><p>如果不清楚docker的安装的目录，可以使用<code>whereis docker</code>命令查看docker的安装的目录</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ci概念&quot;&gt;CI概念&lt;/h1&gt;
&lt;p&gt;持续集成（ Continuous integration ， 简称 CI
）指的是，频繁地（一天多次）将代码集成到主干&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;jenkins/image-202108020006</summary>
      
    
    
    
    <category term="CI/CD" scheme="https://vlsmhd.github.io/categories/CI-CD/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka学习</title>
    <link href="https://vlsmhd.github.io/2023/09/03/Kafka%E5%AD%A6%E4%B9%A0/"/>
    <id>https://vlsmhd.github.io/2023/09/03/Kafka%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-03T10:19:16.718Z</published>
    <updated>2023-10-11T12:35:11.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门">快速入门</h1><h2 id="概念">概念</h2><h3 id="介绍">介绍</h3><p>Kafka是一个分布式流媒体平台,类似于消息队列或企业消息传递系统。kafka官网：http://kafka.apache.org/</p><figure><img src="Kafka学习/image-20210525181028436.png"alt="image-20210525181028436" /><figcaption aria-hidden="true">image-20210525181028436</figcaption></figure><p>kafka介绍-名词解释</p><figure><img src="Kafka学习/image-20210525181100793.png"alt="image-20210525181100793" /><figcaption aria-hidden="true">image-20210525181100793</figcaption></figure><ul><li><p>producer：发布消息的对象称之为主题生产者（Kafka topicproducer）</p></li><li><p>topic：Kafka将消息分门别类，每一类的消息称之为一个主题（Topic）</p></li><li><p>consumer：订阅消息并处理发布的消息的对象称之为主题消费者（consumers）</p></li><li><p>broker：已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p></li></ul><h3 id="section"></h3><h2 id="环境搭建">环境搭建</h2><h3 id="docker集成">docker集成</h3><h2 id="使用">使用</h2><h3 id="java简易使用">java简易使用</h3><h3 id="springboot集成">springboot集成</h3><h1 id="原理篇">原理篇</h1><h2 id="时间轮算法">时间轮算法</h2><blockquote><p>时间轮技术其实出来很久了，在<ahref="https://so.csdn.net/so/search?q=kafka&amp;spm=1001.2101.3001.7020">kafka</a>、zookeeper等技术中都有时间轮使用的方式。</p><p>时间轮是一种高效利用线程资源进行批量化调度的一种调度模型。把大批量的调度任务全部绑定到同一个调度器上，使用这一个调度器来进行所有任务的管理、触发、以及运行。所以时间轮的模型能够高效管理各种延时任务、周期任务、通知任务。</p><ul><li>在Kafka中应用了大量的延迟操作但在Kafka中，并没用使用JDK自带的Timer或是DelayQueue用于延迟操作，而是使用自己开发的DelayedOperationPurgatory组件用于管理延迟操作。</li><li>Kafka这类分布式框架有大量延迟操作并且对性能要求及其高，而java.util.Timer与java.uti.concurrent.DelayQueue的插入和删除时间复杂度都为对数阶0(logn)并不能满足Kafka性能要求。</li><li>Kafka实现了基于时间轮的定时任务组件，该时间轮定时任务实现的插入与删除(开始定时器与暂停定时器)的时间复杂度都为常数阶O(1)。</li><li>时间轮的应用并不少见，在Netty、Akka、Quarz、Zookeeper、Redis等高性能组件中都存在时间轮定时器的踪影。</li><li>Redis的定时调度是基于时间轮实现的。</li></ul></blockquote><h3 id="时间轮数据结构">时间轮数据结构</h3><p>底层采用环形数组，数组的每个元素称为槽，可以存放一个<strong>定时任务列表</strong>（TimerTaskList）。</p><p><strong>定时任务列表（也成Bucket）</strong>：双向环形链表，链表中每一项为<strong>定时任务项</strong>（TimerTaskEntry），其中封装了真正的定时任务（TimerTask）。</p><figure><img src="Kafka学习/format,png-1696317891561-8.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><strong>tickMs：</strong>时间轮由多个时间格组成，每个<strong>时间格</strong>就是tickMs，它代表当前时间轮的<strong>基本时间跨度</strong>。<ul><li>对于秒针而言，tickMs 就是 1 秒。同理，分针是 1 分，时针是 1 小时。在Kafka 中，第 1 层时间轮的 tickMs 被固定为 1 毫秒，也就是说，向前推进一格Bucket 的时长是 1 毫秒。</li></ul></li><li><strong>wheelSize：</strong>代表每一层<strong>时间轮的格数</strong><ul><li>每一层时间轮上的 Bucket 数量。第 1 层的 Bucket 数量是 20。</li></ul></li><li><strong>interval：</strong>当前时间轮的<strong>总体时间跨度</strong>，<code>interval = tickMs × wheelSize</code></li><li><strong>startMs：</strong>构造当层时间轮时候的当前时间，第一层的时间轮的startMs是<code>TimeUnit.NANOSECONDS.toMillis(nanoseconds()),</code><strong>上层时间轮的startMs为下层时间轮的currentTime。</strong><ul><li>当前时间轮创建的起始时间戳</li></ul></li><li><strong>currentTime：</strong>表示<strong>时间轮当前所处的时间</strong>，currentTime是<strong>tickMs的整数倍</strong>（通过currentTime=startMs- (startMs %tickMs）来保正currentTime一定是tickMs的整数倍，这个运算类比钟表中分钟里65秒分钟指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，<strong>currentTime当前指向的时间格也属于到期部分</strong>，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。</li></ul><h3 id="时间轮工作过程">时间轮工作过程</h3><p><img src="Kafka学习/format,png-1696303764735-5.png" alt="img" style="zoom: 200%;" /></p><h4 id="添加任务">添加任务</h4><p>若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。</p><p>初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。</p><p>此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。</p><ul><li>整个时间轮的总体跨度是不变的，<strong>随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。</strong></li></ul><h4 id="时间轮的升降级">时间轮的升降级</h4><p><img src="Kafka学习/format,png.png" alt="img" style="zoom: 67%;" /></p><p>当添加的任务超过这一层时间的跨度interval，会将该事件向上级传递，上级的tickMs是下级的interval传递直到某一个时间满足<code>expiration &lt; currentTime + interval</code>,计算完对应哪一格子，将事件放入，重新设置超时时间，然后放进jkd延迟队列。</p><p>各层时间跨度：</p><ul><li>第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。</li><li>第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。</li><li>每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。</li><li>以此类推，400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。</li></ul><p><strong>存储位置计算公式：</strong><code>buckets[(expiration / tickMs) % wheelSize]</code></p><p>其中,</p><ul><li>expiration = delayMs + startMs</li><li>startMs = currentTime</li><li>tickMS：当前层级的</li></ul><p>案例：</p><ol type="1"><li><p>350ms的任务如何添加： 350 &lt; 20 *20，因此会被插入到第二级时间轮，计算过程： (350 / 1) % 20 = 17，(17 / 1)% 20 = 17 会放入第16个格子</p></li><li><p>如果此时有一个450ms后执行的任务，将会放在第三层时间轮中，按照刚才的计算公式，仍然假设currentTime=0ms,(450ms / tickMs(400))，会放在第1个bucket。第0个bucket里会包含[0,400)ms的任务, 第1个bucket里会包含[400, 800)ms的任务。</p><p>降级操作：</p><ol type="1"><li>当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到二层级时间轮中。</li><li>50ms的任务根据公式(50ms/tickMs(20))会放入第二个时间轮的第2个的bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，只剩10ms，开始降级</li><li>随后放到第一层的第10个bucket，到期后执行</li></ol></li></ol><h3 id="源码分析">源码分析</h3><ul><li>TimingWheel:时间轮时间类，存储定时任务的环形队列，内部使用数组实现，数组是用于存放TimerTaskList对象，</li><li>TimerTaskList：<strong>环形双向链表</strong></li><li>TimerTaskEntry：环形双向链表的<strong>链表项</strong>，封装了定时任务TimerTask</li><li>TimerTask:表示一个要执行的任务，实现了Runnable接口,TimerTask中delayMs字段用于记录任务延迟时间</li></ul><h4 id="timertask任务类">TimerTask任务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TimerTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> delayMs;<span class="comment">//表示当前任务延迟多久后执行(单位ms)，比如说延迟3s，则此值为3000     属于相对当前的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerTask</span><span class="params">(<span class="type">long</span> delayMs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delayMs = delayMs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimerTaskList.<span class="type">TimerTaskEntry</span> <span class="variable">timerTaskEntry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消当前任务，就是从TimerTaskEntry移出TimerTask，并且把当前的timerTaskEntry置空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timerTaskEntry != <span class="literal">null</span>)&#123;</span><br><span class="line">            timerTaskEntry.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        timerTaskEntry = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TimerTaskList.TimerTaskEntry <span class="title function_">getTimerTaskEntry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> timerTaskEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置当前任务绑定的TimerTaskEntry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setTimerTaskEntry</span><span class="params">(TimerTaskList.TimerTaskEntry entry)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timerTaskEntry != <span class="literal">null</span> &amp;&amp; timerTaskEntry != entry) &#123;</span><br><span class="line">            timerTaskEntry.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        timerTaskEntry = entry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类：项目中自定义的任务可以继承该类，继承该有的属性</li></ul><h4 id="timertasklist任务列表">TimerTaskList任务列表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTaskList</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger taskCounter;</span><br><span class="line">    <span class="comment">//列表头结点,哨兵</span></span><br><span class="line">    <span class="keyword">public</span> TimerTaskEntry root;</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    <span class="keyword">public</span> AtomicLong expiration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerTaskList</span><span class="params">(AtomicInteger taskCounter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskCounter = taskCounter;</span><br><span class="line">        <span class="built_in">this</span>.root =  <span class="keyword">new</span> <span class="title class_">TimerTaskEntry</span>(<span class="literal">null</span>,-<span class="number">1L</span>);</span><br><span class="line">        <span class="built_in">this</span>.expiration = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(-<span class="number">1</span>);</span><br><span class="line">        root.next = root;</span><br><span class="line">        root.prev = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给当前槽设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setExpiration</span><span class="params">(Long expirationMs)</span> &#123;</span><br><span class="line">        <span class="comment">//返回的是旧值</span></span><br><span class="line">        <span class="keyword">return</span> expiration.getAndSet(expirationMs) != expirationMs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expiration.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f  传入相应的遍历行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foreach</span><span class="params">(Consumer&lt;TimerTask&gt; f)</span>&#123;</span><br><span class="line">        <span class="type">TimerTaskEntry</span> <span class="variable">entry</span> <span class="operator">=</span> root.next;</span><br><span class="line">        <span class="keyword">while</span>(entry != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TimerTaskEntry</span> <span class="variable">entryNext</span> <span class="operator">=</span> entry.next;</span><br><span class="line">            <span class="keyword">if</span>(!entryNext.cancel())&#123;</span><br><span class="line">                f.accept(entry.timerTask);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entryNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加任务到列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TimerTaskEntry timerTaskEntry)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">            <span class="comment">//从其它列表中移除该任务entry</span></span><br><span class="line">            timerTaskEntry.remove();</span><br><span class="line">            <span class="comment">//锁当前链表，防止并发添加导致任务消失</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="comment">//防止多个线程持有同一个timerTaskEntry，重复添加</span></span><br><span class="line">                <span class="keyword">synchronized</span> (timerTaskEntry)&#123;</span><br><span class="line">                    <span class="type">TimerTaskEntry</span> <span class="variable">tail</span> <span class="operator">=</span> root.prev;</span><br><span class="line">                    timerTaskEntry.prev = tail;</span><br><span class="line">                    timerTaskEntry.next = root;</span><br><span class="line">                    tail.next = timerTaskEntry;</span><br><span class="line">                    root.prev = timerTaskEntry;</span><br><span class="line">                    done = <span class="literal">true</span>;</span><br><span class="line">                    timerTaskEntry.list = <span class="built_in">this</span>;</span><br><span class="line">                    taskCounter.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移出任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(TimerTaskEntry timerTaskEntry)</span> &#123;</span><br><span class="line">        <span class="comment">//防止两个拥有相同的timerTaskEntry对象的线程多删（导致counter多减了个1）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (timerTaskEntry)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timerTaskEntry.list == <span class="built_in">this</span>)&#123;</span><br><span class="line">                timerTaskEntry.prev.next = timerTaskEntry.next;</span><br><span class="line">                timerTaskEntry.next.prev = timerTaskEntry.prev;</span><br><span class="line">                timerTaskEntry.next = <span class="literal">null</span>;</span><br><span class="line">                timerTaskEntry.prev = <span class="literal">null</span>;</span><br><span class="line">                timerTaskEntry.list = <span class="literal">null</span>;</span><br><span class="line">                taskCounter.decrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空任务列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Consumer&lt;TimerTaskEntry&gt; f)</span>&#123;</span><br><span class="line">        <span class="type">TimerTaskEntry</span> <span class="variable">head</span> <span class="operator">=</span> root.next;</span><br><span class="line">        <span class="keyword">while</span> (head != root)&#123;</span><br><span class="line">            <span class="comment">//头删</span></span><br><span class="line">            remove(head);</span><br><span class="line">            f.accept(head);</span><br><span class="line">            head = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        expiration.set(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前任务剩余时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(Math.max(getExpiration() - System.currentTimeMillis(), <span class="number">0</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed d)</span> &#123;</span><br><span class="line">        <span class="type">TimerTaskList</span> <span class="variable">other</span> <span class="operator">=</span> (TimerTaskList) d;</span><br><span class="line">        <span class="keyword">return</span> Long.compare(getExpiration(),other.getExpiration());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimerTaskEntry</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;TimerTaskEntry&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TimerTask timerTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务的过期时间，此处的过期时间设置的过期间隔 + 系统当前时间（毫秒）</span></span><br><span class="line">        <span class="keyword">public</span> Long expirationMs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所属列表</span></span><br><span class="line">        <span class="keyword">private</span> TimerTaskList list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TimerTaskEntry prev;</span><br><span class="line">        <span class="keyword">private</span> TimerTaskEntry next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TimerTaskEntry</span><span class="params">(TimerTask timerTask,Long expirationMs)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.timerTask = timerTask;</span><br><span class="line">            <span class="built_in">this</span>.expirationMs = expirationMs;</span><br><span class="line">            <span class="comment">// 传递进来任务TimerTask，并设置TimerTask的包装类</span></span><br><span class="line">            <span class="keyword">if</span>(timerTask != <span class="literal">null</span>) &#123;</span><br><span class="line">                timerTask.setTimerTaskEntry(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(TimerTaskEntry task)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(<span class="built_in">this</span>.expirationMs, task.expirationMs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从列表中移除该任务entry</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">TimerTaskList</span> <span class="variable">currList</span> <span class="operator">=</span> list;</span><br><span class="line">            <span class="keyword">while</span> (currList != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//列表主题类加锁了，本方法不用加锁</span></span><br><span class="line">                currList.remove(<span class="built_in">this</span>);</span><br><span class="line">                currList = list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务的取消，就是判断任务TimerTask的Entry是否是当前任务 (有可能任务降级，不属于当前列表了）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> timerTask.getTimerTaskEntry() != <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间轮结构">时间轮结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimingWheel</span> &#123;</span><br><span class="line">    <span class="comment">//每一槽的时间跨度</span></span><br><span class="line">    <span class="keyword">private</span> Long tickMs;</span><br><span class="line">    <span class="comment">//槽的个数\时间轮的格数</span></span><br><span class="line">    <span class="keyword">private</span> Integer wheelSize;</span><br><span class="line">    <span class="comment">//系统开始时间</span></span><br><span class="line">    <span class="keyword">private</span> Long startMs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger taskCounter;  <span class="comment">// 当前层任务数</span></span><br><span class="line">    <span class="keyword">private</span> DelayQueue&lt;TimerTaskList&gt; queue; <span class="comment">//延迟队列，用于从队列取每个任务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long interval;<span class="comment">//每一层总时间跨度</span></span><br><span class="line">    <span class="keyword">private</span> Long currentTime;<span class="comment">//时间轮当前时间（修正）  (当前指针指的格子）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TimerTaskList&gt; buckets;  <span class="comment">// 每一层的每一个槽中的时间任务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一层时间轮</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TimingWheel</span> <span class="variable">overflowWheel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimingWheel</span><span class="params">(Long tickMs, Integer wheelSize, Long startMs, AtomicInteger taskCounter, DelayQueue&lt;TimerTaskList&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tickMs = tickMs;</span><br><span class="line">        <span class="built_in">this</span>.wheelSize = wheelSize;</span><br><span class="line">        <span class="built_in">this</span>.startMs = startMs;</span><br><span class="line">        <span class="built_in">this</span>.taskCounter = taskCounter;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        interval = tickMs * wheelSize;</span><br><span class="line">        currentTime = startMs - (startMs % tickMs); <span class="comment">//当前时间，往前推</span></span><br><span class="line"></span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(wheelSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wheelSize; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> <span class="title class_">TimerTaskList</span>(taskCounter));  <span class="comment">//创建每一个槽中的列表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建上层时间轮</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">createOverflowWheel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (overflowWheel == <span class="literal">null</span>) &#123;</span><br><span class="line">            overflowWheel = <span class="keyword">new</span> <span class="title class_">TimingWheel</span>(<span class="built_in">this</span>.interval, wheelSize, currentTime, taskCounter, queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addTask</span><span class="params">(TimerTaskList.TimerTaskEntry timerTaskEntry)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">expiration</span> <span class="operator">=</span> timerTaskEntry.expirationMs;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">thisTime</span> <span class="operator">=</span> currentTime + <span class="number">1</span> * tickMs; <span class="comment">//当前时间轮所指位置的下一个槽的开始时间，因为当前时间槽也算到期。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (timerTaskEntry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timerTaskEntry.cancel()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expiration &lt; thisTime) &#123;<span class="comment">//查看是否过期</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expiration &lt; currentTime + interval) &#123; <span class="comment">//判断是否能添加到当前时间轮</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">virtualId</span> <span class="operator">=</span> expiration / tickMs;<span class="comment">//虚拟时间标识</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">whereBucket</span> <span class="operator">=</span> (<span class="type">int</span>) virtualId % wheelSize;</span><br><span class="line">                <span class="type">TimerTaskList</span> <span class="variable">bucket</span> <span class="operator">=</span> buckets.get(whereBucket);</span><br><span class="line">                bucket.add(timerTaskEntry);</span><br><span class="line">                <span class="comment">//更新槽的过期时间</span></span><br><span class="line">                <span class="keyword">if</span> (bucket.setExpiration(virtualId * tickMs)) &#123;</span><br><span class="line">                    queue.offer(bucket);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//找上级时间轮</span></span><br><span class="line">                <span class="keyword">if</span> (overflowWheel == <span class="literal">null</span>) &#123;</span><br><span class="line">                    createOverflowWheel();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> overflowWheel.addTask(timerTaskEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间轮的推动,向前驱动时间轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">advanceClock</span><span class="params">(Long timeMs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timeMs &gt;= currentTime + tickMs)&#123;</span><br><span class="line">            currentTime = timeMs - (timeMs % tickMs);</span><br><span class="line">            <span class="keyword">if</span>(overflowWheel != <span class="literal">null</span>)&#123;</span><br><span class="line">                overflowWheel.advanceClock(currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间轮接口">时间轮接口</h4><ul><li>kafka中提供了Timer接口，用于对外提供调用，分别是<ul><li>Timer#add 添加任务；</li><li>Timer#advanceClock 驱动时间；</li><li>Timer#size 时间轮中总任务数；</li><li>Timer#shutdown 停止时间轮</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TimerTask timerTask)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">advanceClock</span><span class="params">(Long timeoutMs)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="systemtimer实现类">SystemTimer实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTimer</span> <span class="keyword">implements</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">wheelSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">tickMs</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">startMs</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">private</span> String executorName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>, (runnable) -&gt;&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.setName(<span class="string">&quot;executor-&quot;</span> + executorName);</span><br><span class="line">        thread.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimingWheel timingWheel;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger taskCounter;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> DelayQueue&lt;TimerTaskList&gt; delayQueue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理并发</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来执行时间轮的重新排列，及上一个槽中的任务列表被执行后，后面的槽中的任务列表移动</span></span><br><span class="line">    <span class="keyword">private</span> Consumer&lt;TimerTaskList.TimerTaskEntry&gt; reinsert = (timerTaskEntry) -&gt; addTimerTaskEntry(timerTaskEntry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemTimer</span><span class="params">(Integer wheelSize, Long tickMs, Long startMs, String executorName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wheelSize = wheelSize;</span><br><span class="line">        <span class="built_in">this</span>.tickMs = tickMs;</span><br><span class="line">        <span class="built_in">this</span>.startMs = startMs;</span><br><span class="line">        <span class="built_in">this</span>.executorName = executorName;</span><br><span class="line">        taskCounter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        timingWheel = <span class="keyword">new</span> <span class="title class_">TimingWheel</span>(tickMs, wheelSize, startMs, taskCounter, delayQueue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemTimer</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TimerTask timerTask)</span> &#123;</span><br><span class="line">        <span class="comment">//读锁允许多个线程同时访问共享资源，但不允许写操作。</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            addTimerTaskEntry(<span class="keyword">new</span> <span class="title class_">TimerTaskList</span>.</span><br><span class="line">                    TimerTaskEntry(timerTask, timerTask.delayMs + System.currentTimeMillis()));</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTimerTaskEntry</span><span class="params">(TimerTaskList.TimerTaskEntry timerTaskEntry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timingWheel.addTask(timerTaskEntry)) &#123;</span><br><span class="line">            <span class="comment">//添加失败，如果任务没取消立即执行</span></span><br><span class="line">            <span class="keyword">if</span>(!timerTaskEntry.cancel())&#123;</span><br><span class="line">                taskExecutor.submit(timerTaskEntry.timerTask);<span class="comment">//任务对象实现了runnable接口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间向前推进，推进过程中处理已经过期的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutMs   大于currentTime的某一时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">advanceClock</span><span class="params">(Long timeoutMs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TimerTaskList</span> <span class="variable">bucket</span> <span class="operator">=</span> delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">if</span>(bucket != <span class="literal">null</span>)&#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (bucket != <span class="literal">null</span>)&#123;</span><br><span class="line">                    timingWheel.advanceClock(bucket.getExpiration());</span><br><span class="line">                    <span class="comment">// 驱动时间后，需要移动TimerTaskList到上一个槽或者从上一层移动到本层</span></span><br><span class="line">                    bucket.flush(reinsert);</span><br><span class="line">                    bucket = delayQueue.poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskCounter.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        taskExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速入门&quot;&gt;快速入门&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;Kafka
是一个分布式流媒体平台,类似于消息队列或企业消息传递系统。kafka官网：http://kafka.apache.org/&lt;/</summary>
      
    
    
    
    <category term="消息队列" scheme="https://vlsmhd.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="Kafka" scheme="https://vlsmhd.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode双指针题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/09/02/leetcode%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/09/02/leetcode%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-09-02T00:23:47.137Z</published>
    <updated>2023-09-06T07:01:06.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双指针解题规律">双指针解题规律</h2><h3 id="对向指针">对向指针</h3><p>对向搜索：可用于解决有序数组找和的区间，大了右指针移动，小了左指针移动。</p><h3 id="快慢指针">快慢指针</h3><h2 id="题目">题目</h2><h3 id="反转字符串中的元音字母"><ahref="https://leetcode.cn/problems/reverse-vowels-of-a-string/">345.反转字符串中的元音字母</a></h3><p>给你一个字符串 <code>s</code>，仅反转字符串中的所有元音字母，并返回结果字符串。</p><p>元音字母包括<code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code>，且可能以大小写两种形式出现不止一次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;hello&quot;</span><br><span class="line">输出：&quot;holle&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;leotcede&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由 <strong>可打印的 ASCII</strong> 字符组成</li></ul><h4 id="对向指针-1">对向指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseVowels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; n &amp;&amp; !isVowel(arr[left])) left++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right &gt; <span class="number">0</span> &amp;&amp; !isVowel(arr[right])) right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = tmp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span></span><br><span class="line">        || c == <span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转字符串中的单词"><ahref="https://leetcode.cn/problems/reverse-words-in-a-string/">151.反转字符串中的单词</a></h3><p>给你一个字符串 <code>s</code> ，请你反转字符串中<strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code>中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong>之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串<code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><h4 id="快慢指针-1">快慢指针</h4><p>快慢指针指向单词的区间，进行拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(s.substring(left + <span class="number">1</span>, right + <span class="number">1</span>));</span><br><span class="line">            res.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文串"><ahref="https://leetcode.cn/problems/valid-palindrome/">125.验证回文串</a></h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个<strong>回文串</strong> 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong>，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;amanaplanacanalpanama&quot; 是回文串。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;race a car&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;raceacar&quot; 不是回文串。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot; &quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在移除非字母数字字符之后，s 是一个空字符串 &quot;&quot; 。</span><br><span class="line">由于空字符串正着反着读都一样，所以是回文串。</span><br></pre></td></tr></table></figure><h4 id="对向指针-2">对向指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除除字母以外的其它字符，添加到新字符串中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                str.append(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                str.append((<span class="type">char</span>)(c + <span class="number">32</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                str.append(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = str.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和-ii---输入有序数组"><ahref="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167.两数之和 II - 输入有序数组</a></h3><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code>，该数组已按 <strong>非递减顺序排列</strong>，请你从数组中找出满足相加之和等于目标数 <code>target</code>的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和<code>numbers[index2]</code> ，则<code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code>的形式返回这两个整数的下标 <code>index1</code> 和<code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你<strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [2,7,11,15], target = 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [2,3,4], target = 6</span><br><span class="line">输出：[1,3]</span><br><span class="line">解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [-1,0], target = -1</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li><li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li><li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li><li><code>-1000 &lt;= target &lt;= 1000</code></li><li><strong>仅存在一个有效答案</strong></li></ul><h4 id="对向指针-3">对向指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动零"><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong>，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h4 id="二次遍历">二次遍历</h4><p>第一次遍历，把全部不为0的数都弄到前面（保持相对顺序），然后指针停的位置left，用<code>n - left</code>得出0的个数，也就是把后面都赋值为0即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span>  right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断子序列"><ahref="https://leetcode.cn/problems/is-subsequence/">392.判断子序列</a></h3><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断<strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>"ace"</code>是<code>"abcde"</code>的一个子序列，而<code>"aec"</code>不是）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h4 id="贪心思想">贪心思想</h4><p>优先遍历左边的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == n;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="盛最多水的容器"><ahref="https://leetcode.cn/problems/container-with-most-water/">11.盛最多水的容器</a></h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是<code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code>轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><h4 id="贪心思路">贪心思路</h4><p>双指针一左一右。</p><p>如果左指针指的高度高，那就让右指针移动，反之，让左指针移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            max = Math.max(max, (right - left) * Math.min(height[right], height[left]));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt;= height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="k-和数对的最大数目"><ahref="https://leetcode.cn/problems/max-number-of-k-sum-pairs/">1679. K和数对的最大数目</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>每一步操作中，你需要从数组中选出和为 <code>k</code>的两个整数，并将它们移出数组。</p><p>返回你可以对数组执行的最大操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：开始时 nums = [1,2,3,4]：</span><br><span class="line">- 移出 1 和 4 ，之后 nums = [2,3]</span><br><span class="line">- 移出 2 和 3 ，之后 nums = []</span><br><span class="line">不再有和为 5 的数对，因此最多执行 2 次操作。</span><br></pre></td></tr></table></figure><h4 id="排序贪心对向指针">排序+贪心+对向指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] + nums[right] &gt; k)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; k)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩字符串"><ahref="https://leetcode.cn/problems/string-compression/">443.压缩字符串</a></h3><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p><p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组<strong>连续重复字符</strong> ：</p><ul><li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code>中。</li><li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li></ul><p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong>，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为<code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code>数组中会被拆分为多个字符。</p><p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line">输出：返回 6 ，输入数组的前 6 个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br><span class="line">解释：&quot;aa&quot; 被 &quot;a2&quot; 替代。&quot;bb&quot; 被 &quot;b2&quot; 替代。&quot;ccc&quot; 被 &quot;c3&quot; 替代。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：chars = [&quot;a&quot;]</span><br><span class="line">输出：返回 1 ，输入数组的前 1 个字符应该是：[&quot;a&quot;]</span><br><span class="line">解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]</span><br><span class="line">输出：返回 4 ，输入数组的前 4 个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。</span><br><span class="line">解释：由于字符 &quot;a&quot; 不重复，所以不会被压缩。&quot;bbbbbbbbbbbb&quot; 被 “b12” 替代。</span><br></pre></td></tr></table></figure><h4 id="快慢指针读写指针">快慢指针（读写指针）</h4><p>写指针在前，写指针要在一个字符出现的最后一个位置处，然后再用一个left记录这个字符开始的位置，这样就能计算字符出现的长度，然后通过辗转相除，取余数转成字符放进去然后反转（因为辗转相除是逆序数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>; read &lt; chars.length; read++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(read == n-<span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>])&#123;</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">numStartIdx</span> <span class="operator">=</span> write;</span><br><span class="line">                    <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        chars[write++] = (<span class="type">char</span>)(num%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(chars, numStartIdx, write - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                left = read + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="https://leetcode.cn/problems/3sum/">15.三数之和</a></h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code> 满足<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><h4 id="对向指针-4">对向指针</h4><p>这题注意去重，排序过后，对于相同的相邻元素的处理：直接跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span>nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;双指针解题规律&quot;&gt;双指针解题规律&lt;/h2&gt;
&lt;h3 id=&quot;对向指针&quot;&gt;对向指针&lt;/h3&gt;
&lt;p&gt;对向搜索：可用于解决有序数组找和的区间，大了右指针移动，小了左指针移动。&lt;/p&gt;
&lt;h3 id=&quot;快慢指针&quot;&gt;快慢指针&lt;/h3&gt;
&lt;h2 id=&quot;题目&quot;&gt;题目</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="双指针" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
  </entry>
  
  <entry>
    <title>2023秋招投递记录</title>
    <link href="https://vlsmhd.github.io/2023/09/01/2023%E7%A7%8B%E6%8B%9B%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/"/>
    <id>https://vlsmhd.github.io/2023/09/01/2023%E7%A7%8B%E6%8B%9B%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/</id>
    <published>2023-09-01T07:53:58.583Z</published>
    <updated>2023-10-11T12:16:55.039Z</updated>
    
    <content type="html"><![CDATA[<p>标题上的V？表示用的第几版本简历投递。</p><h1 id="中小厂试炼v1">中小厂试炼——V1</h1><h2 id="boss投递">boss投递</h2><h3 id="保融科技">保融科技</h3><p>投递日期9.14</p><p>投递地址：<ahref="https://campus.fingard.com/campus_apply/baorong/25901/#/candidateHome/applications">浙江保融科技股份有限公司- 校园招聘 (fingard.com)</a></p><h3 id="去哪儿网">去哪儿网</h3><p>投递日期9.1</p><p>注意：旧版简历</p><h4 id="测评">9.12测评</h4><h3 id="赛博大象">赛博大象</h3><p>投递日期9.4</p><h3 id="杭州乐刻网络简历挂">杭州乐刻网络（简历挂）</h3><p>投递日期9.4</p><p>简历挂——9.8</p><h3 id="automq简历挂">AutoMQ（简历挂）</h3><p>投递日期9.4</p><h4 id="笔试9.4">笔试——9.4</h4><p>https://eztest.org/exam/session/294548/</p><p>一些基础选择题。</p><h4 id="面试资料提交">面试资料提交</h4><p>通过以下代码，在项目工程目录下执行，可以得到本人对项目的提交次数、代码量等等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;mhd&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;;git shortlog --all --numbered --summary --no-merges</span><br></pre></td></tr></table></figure><h3 id="上海嘉银金融科技简历挂">上海嘉银金融科技（简历挂）</h3><p>投递日期9.4</p><p>简历挂——9.5</p><h3 id="创达猎星">创达猎星</h3><p>投递日期9.4</p><h3 id="衡泰技术">衡泰技术</h3><p>投递日期9.6</p><h4 id="笔试">9.19笔试</h4><p>https://exam.nowcoder.com/cts/17293419/summary?id=73EDF63E67AC41035D2B1AAD67C4DCC3</p><h3 id="九鼎无双">九鼎无双</h3><p>投递日期9.6</p><h3 id="同程数科">同程数科</h3><p>投递日期9.6</p><h3 id="七宝">七宝</h3><p>投递日期9.6</p><h3 id="安徽优质采">安徽优质采</h3><p>投递日期9.6</p><h3 id="科远智慧">科远智慧</h3><p>投递日期9.6</p><h3 id="信也科技">信也科技</h3><p>投递日期9.7</p><h3 id="邦盛科技">邦盛科技</h3><p>投递日期9.7</p><h3 id="同盾科技">同盾科技</h3><p>投递日期9.11</p><p><ahref="https://app.mokahr.com/m/candidate/applications/deliver-query/tongdun">同盾科技- 投递查询 (mokahr.com)</a></p><h4 id="笔试-1">9.22笔试</h4><ol start="2" type="1"><li>体积尽量占满背包</li></ol><h3 id="品茗科技">品茗科技</h3><p>投递日期9.11</p><h3 id="信也科技-1">信也科技</h3><p>投递日期9.11</p><h3 id="掌阅科技">掌阅科技</h3><p>投递日期9.14</p><h4 id="笔试9.18">笔试9.18</h4><p>https://t.zijieimg.com/ie5vWYQD/</p><h5 id="编程题">编程题</h5><p>全AC</p><p>判断回文串新方法：用栈，先添加一半的数据，剩下一半对应出栈。</p><h3 id="人大金仓">人大金仓</h3><p>投递日期9.14</p><h3 id="北京亚控">北京亚控</h3><p>投递日期9.18</p><h3 id="九鼎无双-1">九鼎无双</h3><p>投递日期9.18</p><h3 id="宏杉科技"><strong>宏杉科技</strong></h3><p>投递日期9.27</p><h3 id="传化智联">传化智联</h3><p>投递日期9.28</p><h4 id="笔试-2">9.28笔试</h4><p>https://short-phx-ali.yunxuetang.cn/qbaq8tbp</p><h2 id="官网投递">官网投递</h2><h3 id="广联达简历挂">广联达（简历挂）</h3><p>投递日期9.5</p><p>投递地址：<ahref="https://app.mokahr.com/campus-recruitment/glodon/91966?sourceToken=2b78348d1798c5dd95d999db699457d3#/job/2f4c8a53-9061-4aa5-898c-911c6f3a9254/campus_apply/thanks?jobId=2f4c8a53-9061-4aa5-898c-911c6f3a9254&amp;recommendCode=NTAUtTI&amp;codeType=1&amp;applyInfo%5BaimWorkCity%5D=西安市&amp;applyInfo%5BrecommendCode%5D=NTAUtTI&amp;candidateName=孟海东&amp;candidateId=460102903">广联达科技股份有限公司- 校园招聘 (mokahr.com)</a></p><h3 id="得物">得物</h3><p>投递日期9.7</p><p><ahref="https://app.mokahr.com/campus-recruitment/thedu/37483?recommendCode=DSr7mMWw#/job/4f85f728-9ecb-4411-ab30-ed6affff54a7/campus_apply/thanks?jobId=4f85f728-9ecb-4411-ab30-ed6affff54a7&amp;codeType=2&amp;applyInfo%5BaimWorkCity%5D=上海市&amp;applyInfo%5BrecommendCode%5D=DSr7mMWw&amp;candidateName=孟海东&amp;candidateId=461372337">得物App—校园招聘官网(mokahr.com)</a></p><h3 id="笔试挂">4399（笔试挂）</h3><p>账号：1067853293@qq.com</p><p>密码：LOLVlongshen716</p><p>投递日期9.7</p><p><ahref="https://hr.4399om.com/?r=userCenter/index">个人中心-4399招聘频道(4399om.com)</a></p><h4 id="笔试-3">9.12笔试</h4><p>地址：<ahref="https://hr.4399om.com/main/?r=CandidateTest/candidateIndex">4399笔试平台(4399om.com)</a></p><p>密码：fKHZ5ItI</p><p><strong>问答题</strong></p><p>在 Centos 7 中，假设你有一个名为 "script.sh"的脚本文件，我们查询到其对应的权限为 -rwxrw-rw-</p><ol type="1"><li><p>这个权限值代表了什么（3分）？</p><p>答：分三组：第一组是文件所有者的权限，可读可写可执行;第二组是所属组权限，可读可写; 第三组是其它外人的权限，可读可写</p></li><li><p>对应的权限码是啥（2分）？</p><p>r(4) w(2) x(1)</p><p>答：766</p></li></ol><p>现在有个简易的电商系统需要增加几个新功能</p><ol type="1"><li><p>给商品支持分类，分类层级至少需要3层（3层分类示例：男装-上衣-短袖），现在请帮忙设计一个分类表来实现，写出对应的建表语句并简述是如何实现多级分类的。（4分）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> Shops&#123;</span><br><span class="line"></span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"></span><br><span class="line">    NAME <span class="type">VARCHAR</span>,</span><br><span class="line"></span><br><span class="line">    PARENT_ID <span class="type">INT</span>,</span><br><span class="line"></span><br><span class="line">    LEVEL <span class="type">INT</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">每一行数据包含父节点id和层级属性</span><br></pre></td></tr></table></figure></li><li><p>在商品完成交易后给买卖双方发送短信通知，如果让你设计一个短信发送系统，你会怎么设计？有什么需要注意和拓展的地方？（6分）</p></li></ol><p><strong>算法题</strong></p><ol type="1"><li>4399 出了一款小游戏 《劫富济贫》，游戏中，有多个富商基地，一个侠盗需要夜行从每个富商基地偷到最多的珠宝钻石，并且保证不被安保发现；已知： （1）基地里面的房间是一整排到底的，即仅有一排 n 间房子（2）侠盗已经从 “百晓生” 那里得知了每个房子里面的珠宝数量（3）如果相邻的两间房间同一个晚上被盗窃，侠盗就会被安保发现给定您一个代表每个房屋存放珠宝的非负整数数据，请您编写程序，计算出侠盗一晚能够在不被安保发现的情况下盗取的最大珠宝数量！ 输入示例: 1,2,5,2,1,3,1 输出示例: 9</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxThief</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>有n个硬币，每次最多拿走一个或者两个，你有多少种不同的方法拿完全部的硬币？（要求用动态规范解题）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">method2GetCoins</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">1</span>] + dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">Coin</span> <span class="variable">coin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coin</span>();</span><br><span class="line">            System.out.println(coin.method2GetCoins(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li><p>有一款小游戏，游戏中有N+1座基地——从0到N编号，从左到右排列。每个基地都有不同数量的小兵，编号为i的基地的小兵数量为H(i)个。</p><p>起初，小牙在编号为0的基地处。每一步，它跳到下一个（右边）基地。假设小牙在第k个基地，且它现在的能量值是E,下一步它将跳到第个k+1基地。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果H(k+1) &gt; E 那么小牙就失去 H(k+1) - E 的能量值，否则它将得到 E -H(k+1) 的能量值。</p><p>游戏目标是到达第个N基地，在这个过程中，能量值不能为负数个单位。现在的问题是小牙以多少能量值开始游戏，才可以保证成功完成游戏？</p><p>输入描述： 第一行输入，表示一共有 N 组数据. 第二个是 N个空格分隔的整数，H1, H2, H3, ..., Hn 代表建筑物的高度</p><p>输出描述： 输出一个单独的数表示完成游戏所需的最少单位的初始能量</p><p>输入例子： 5 3 4 3 2 4 输出例子： 4</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="同花顺">同花顺</h3><p>投递时间：9.8</p><p><ahref="http://campus.10jqka.com.cn/userCenter/employRecord">同花顺校园招聘(10jqka.com.cn)</a></p><h4 id="测试">测试</h4><figure><img src="2023秋招投递记录/image-20230908204508384.png"alt="image-20230908204508384" /><figcaption aria-hidden="true">image-20230908204508384</figcaption></figure><h4 id="笔试-4">10.8笔试</h4><p><ahref="http://job.10jqka.com.cn/#/schoolExam?examId=307">同花顺校园招聘(10jqka.com.cn)</a></p><h5 id="编程题-1">编程题</h5><p>1、打印0-999之间不含5的数字。</p><p>思路：暴力，转成字符串操作，调用字符串API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">999</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(String.valueOf(i).contains(<span class="string">&quot;5&quot;</span>))&#123;</span><br><span class="line">        sout(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业帮">作业帮</h3><p>投递时间：9.8</p><p><ahref="https://app.mokahr.com/campus-recruitment/zuoyebang/39595#/candidateHome/applications">作业帮教育科技（北京）有限公司- 校园招聘 (mokahr.com)</a></p><h3 id="诗悦科技">诗悦科技</h3><p>投递时间：9.14</p><h3 id="数字马力">数字马力</h3><p>投递时间：9.17</p><p><ahref="https://app.mokahr.com/campus-recruitment/digital-engine/92713#/candidateHome/applications">数字马力- 校园招聘 (mokahr.com)</a></p><h4 id="笔试-5">10.9笔试</h4><p>https://exam.nowcoder.com/cts/17299211/summary?id=00C12C0314AE14875D2B1AAD67C4DCC3</p><h5 id="算法题">算法题</h5><ol type="1"><li><p>归并排序（手写十遍！！！）、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sortString</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] ans = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">    merge_sort_recursive(chars, ans,<span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge_sort_recursive</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">char</span>[] result, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start1</span> <span class="operator">=</span> start, end1 = mid;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start2</span> <span class="operator">=</span> mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, result, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, result, start2, end2);</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        result[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        result[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = result[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除链表结点</p></li><li><p>给定一个int数组A及其大小n以及需查找的和sum，请返回数组中两数之和为sum的整数对的个数。保证数组大小小于等于10000</p><p>[1,2,2,2,2]假如sum要求 = 3，那就有四种情况，要求下标组成不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">countPairs</span> <span class="params">(ArrayList&lt;Integer&gt; A, <span class="type">int</span> n, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">want</span> <span class="operator">=</span> sum - A.get(i);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(want))&#123;</span><br><span class="line">            count += map.get(want);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(A.get(i), map.getOrDefault(A.get(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="牛客投递">牛客投递</h2><h3 id="格灵深瞳">格灵深瞳</h3><p>投递日期9.5</p><h3 id="友塔游戏">友塔游戏</h3><p>投递日期9.13</p><h3 id="英雄游戏">英雄游戏</h3><p>投递日期9.13</p><h3 id="呦尔哈游戏">呦尔哈游戏</h3><p>投递日期9.13</p><h3 id="勇仕网络">勇仕网络</h3><p>投递日期9.13</p><h1 id="大厂冲刺v1">大厂冲刺——V1</h1><h2 id="官网投递-1">官网投递</h2><h3 id="新奥集团">新奥集团</h3><p>投递地址：<ahref="https://enn.zhiye.com/form?fromPage=job&amp;jobAdId=bdd992bb-0b63-4745-a65e-8409f385e2de&amp;userId=273749158">新奥集团(zhiye.com)</a></p><p>投递日期9.4</p><h3 id="恒生电子">恒生电子</h3><p>投递地址：<a href="https://campus.hundsun.com/campus/jobs">校园招聘(hundsun.com)</a></p><p>投递日期9.4</p><h4 id="笔试-6">10.13笔试</h4><p><ahref="https://exam.nowcoder.com/cts/17290170/summary?id=8EE7978F6977E38B5D2B1AAD67C4DCC3">恒生2024校园招聘-Java卷1013_牛客(nowcoder.com)</a></p><h3 id="美团笔试挂">美团（笔试挂）</h3><p>投递地址：<ahref="https://zhaopin.meituan.com/web/personalCenter/deliveryRecord?staffSsoId=5817141">个人中心| 美团招聘 (meituan.com)</a></p><p>投递日期9.7</p><h4 id="笔试-7">9.9笔试</h4><p><ahref="https://exam.nowcoder.com/cts/17292034/summary?id=59BBA5D0CE44CD4A5D2B1AAD67C4DCC3">美团2024届秋招第五场笔试【技术】_牛客(nowcoder.com)</a></p><h5 id="修改01串后的最小价值">修改01串后的最小价值</h5><h6 id="思路">思路</h6><p>第一趟遍历先消去能消的，然后剩下的串就是010101这样，然后每个k能减去2。</p><p>边界判断：</p><p>k不能过大，这样rest value-2*K会为负数，同时还要考虑，rest的字符串长度是奇数还是偶数。</p><h6 id="代码">代码</h6><h5 id="加减数组">加减数组</h5><p>前缀和，S数组</p><h5 id="异或和">异或和</h5><h3 id="小红书">小红书</h3><p>投递时间：9.8</p><h3 id="腾讯测评挂">腾讯（测评挂）</h3><p>投递地址：<a href="https://join.qq.com/progress.html">应聘进度 |腾讯校招 (qq.com)</a></p><p>投递日期9.8</p><h4 id="测评-1">测评</h4><p><ahref="https://assessment.tencent.com/assessments?p=SywtybA1VMtMsTU0MDBSyywrAfIKbI2MDNRKkm1DLELNTNISU0zTjMwsjC3MAA">测验任务页_腾讯招聘在线测评(tencent.com)</a></p><h3 id="科大讯飞简历挂">科大讯飞（简历挂）</h3><p>投递日期9.8</p><p><a href="https://campus.iflytek.com/official-pc/delivery">投递记录 -科大讯飞校园招聘 (iflytek.com)</a></p><h3 id="快手简历挂">快手（简历挂）</h3><p>投递日期9.8</p><p><a href="https://campus.kuaishou.cn/#/campus/my-apply">快手校招 -快手校招-投递记录 (kuaishou.cn)</a></p><p>9.18重新投</p><h3 id="京东简历挂">京东(简历挂)</h3><p>投递日期9.8</p><p><a href="https://campus.jd.com/#/myDeliver?type=present">京东校招(jd.com)</a></p><h4 id="测评-2">9.9测评</h4><h3 id="虎牙直播">虎牙直播</h3><p>投递日期9.10</p><p><ahref="https://app.mokahr.com/campus_apply/huya/4112#/candidateHome/applications">虎牙直播-校园招聘(mokahr.com)</a></p><h3 id="影石">影石</h3><p>投递日期9.11</p><p><ahref="https://insta360.zhiye.com/campus/jobs">影石创新科技股份有限公司(zhiye.com)</a></p><h3 id="三七互娱">三七互娱</h3><p>投递日期9.11</p><p><ahref="https://app.mokahr.com/campus_apply/37/25238?recommendCode=DSQNKtCs#/candidateHome/applications">三七互娱-校园招聘(mokahr.com)</a></p><h3 id="顺丰">顺丰</h3><p>投递日期9.11</p><p><ahref="https://campus.sf-express.com/m/?channel=29&amp;referCode=4FOLXH#/applyList">投递记录(sf-express.com)</a></p><h4 id="测评-3">9.12测评</h4><h3 id="宇通集团挂">宇通集团（挂）</h3><p>投递日期9.15</p><p><ahref="https://wecruit.hotjob.cn/SU649796b60dcad412ce9c4bbd/pb/account.html#/myDeliver">宇通招聘(hotjob.cn)</a></p><h3 id="滴滴">滴滴</h3><p>投递日期9.11</p><p><ahref="https://campus.didiglobal.com/campus_apply/didiglobal/96064#/candidateHome/applications">滴滴- 校园招聘 (didiglobal.com)</a></p><h4 id="滴滴笔试">9.15滴滴笔试</h4><p><strong>https://didi.acmcoder.com/cand/login?wm9sepgb</strong></p><p>登录帐号：<strong>didi</strong> 登录密码：<strong>d95qyn</strong></p><p>算法题：</p><p>1.你负责在一条笔直的道路上安装一些照明灯。但是道路上并不是任意位置都适合安装照明灯，具体地，假设将道路看作一条起点坐标为0，终点坐标为M的线段，那么只有在x1,x2...xn这n个坐标可以安装照明灯，且每个坐标上最多只能安装一个照明灯。现在你要在道路上安装k个照明灯，为了使照明灯能够尽星覆盖道路，你需要使距离最近的两个照明灯尽量远。请问这个最近距离最大可以是多少?</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行是两个整数n、k，分别表示可以安装照明灯的位置数和需要安装的照明灯数量。</span><br><span class="line">接下来一行n个整数x1,x2..Xn表示可以安装照明灯的坐标。保证x1&lt;x2&lt;....&lt;xn。</span><br><span class="line">1&lt;=k&lt;=n&lt;=100000，1&lt;=xi&lt;=1000000</span><br></pre></td></tr></table></figure><p>代码：</p><p>2.有一个n*m的网格图,起初你在(1，1)处,现在想走到(n,m)处,且经过的黑色网格尽可能少。请输出最少需要经过多少个黑色网格。网格图是四联通的,也就是每次只能向上下左右四个相邻的格子移动,且不能走出边界。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行两个正整数n和m，含义如上文所述。</span><br><span class="line">接下来n行，每行m个数，此数为1时表示为黑色格子,为0时表示为白色格子。1≤n*ms100000</span><br></pre></td></tr></table></figure><p>输出：</p><p>非负整数，表示答案。</p><p>代码：</p><p>通过36%...</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextInt())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span>[][] road = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    road[i][j] = in.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Main</span> <span class="variable">blackWhite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">            System.out.println(blackWhite.minBlack(road, n,m));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minBlack</span><span class="params">(<span class="type">int</span>[][] road, <span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(road[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美世界">完美世界</h3><p>投递日期9.13</p><p><ahref="https://app.mokahr.com/campus-recruitment/pwrd/98446#/candidateHome/applications">完美世界- 校园招聘 (mokahr.com)</a></p><h3 id="深信服">深信服</h3><p>投递日期9.14</p><p><ahref="https://app.mokahr.com/campus_apply/sangfor/27944#/job/17e64524-232e-4a3c-bcce-1024c925c43f/campus_apply/thanks?jobId=17e64524-232e-4a3c-bcce-1024c925c43f&amp;recommendCode=NTAVdXe&amp;codeType=1&amp;applyInfo%5BcampusSiteId%5D=18063&amp;applyInfo%5BaimWorkCity%5D=深圳市&amp;applyInfo%5BrecommendCode%5D=NTAVdXe&amp;candidateName=孟海东&amp;candidateId=464026162&amp;pure=1">深信服集团- 校园招聘 (mokahr.com)</a></p><h4 id="笔试9.16">笔试9.16</h4><p>https://exam.nowcoder.com/cts/17295845/summary?id=649187173D1ED54B5D2B1AAD67C4DCC3</p><h5 id="算法题-1">算法题</h5><p>1、</p><figure><img src="2023秋招投递记录/image-20230916100154268.png"alt="image-20230916100154268" /><figcaption aria-hidden="true">image-20230916100154268</figcaption></figure><p>正确思路：模运算+快速幂</p><p>模运算性质：<span class="math inline">\((a*b)\% n =(a\%n *b\%n)\%n\)</span>，解决数据溢出问题。</p><p>a的b次方的个位数，也就是(<spanclass="math inline">\(a*a*a...*a\)</span>)%10 ==b个（a%10)相乘再%10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    a %= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ans = (ans * a) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a)  % <span class="number">10</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">    <span class="keyword">while</span> (in.hasNextInt()) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.println(getLast(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLast</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        last = (x * last) % <span class="number">10</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (last == x) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> y % count;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        last = (x * last) % <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用例通过25%</li></ul><p>2、</p><figure><img src="2023秋招投递记录/image-20230916102700011.png"alt="image-20230916102700011" /><figcaption aria-hidden="true">image-20230916102700011</figcaption></figure><figure><img src="2023秋招投递记录/image-20230916102708546.png"alt="image-20230916102708546" /><figcaption aria-hidden="true">image-20230916102708546</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> in.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> in.next();</span><br><span class="line">            System.out.println(match(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">match</span><span class="params">(String s, String patten)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> patten.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> patten.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == patten.charAt(i)) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty() ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过80%</li></ul><p>3、</p><figure><img src="2023秋招投递记录/image-20230916104727692.png"alt="image-20230916104727692" /><figcaption aria-hidden="true">image-20230916104727692</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            String[] c = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++)&#123;</span><br><span class="line">                list.add(Integer.parseInt(c[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(maxDeSerial(list));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDeSerial</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; right &lt; list.size())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="keyword">while</span>(++right &lt; list.size() &amp;&amp; list.get(right) &lt; list.get(c))&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line"></span><br><span class="line">            left = right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>滑动窗口：通过100%</li></ul><p>4、</p><figure><img src="2023秋招投递记录/image-20230916111356223.png"alt="image-20230916111356223" /><figcaption aria-hidden="true">image-20230916111356223</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">substr</span> <span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">needCnt</span> <span class="operator">=</span> b.length();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : b.toCharArray()) &#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> a.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.getOrDefault(c, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                needCnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (needCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; i &amp;&amp; map.get(a.charAt(left)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(a.charAt(left), map.getOrDefault(a.charAt(left), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = Math.min(len, i - left + <span class="number">1</span>);</span><br><span class="line">                    ans = a.substring(left, left + len);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                map.put(a.charAt(left), map.get(a.charAt(left)) + <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">                needCnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>滑动窗口：完成83.3%</li></ul><h3 id="小米科技">小米科技</h3><p>投递日期9.14</p><p><ahref="https://xiaomi.jobs.f.mioffice.cn/campus/position/application?spread=J7NS6YR">应聘记录- 小米校园招聘 (mioffice.cn)</a></p><h4 id="笔试-8">10.14笔试</h4><p>https://mi.acmcoder.com/cand/login?key=3rc6ju</p><h3 id="好未来简历挂">好未来（简历挂）</h3><p>投递日期9.14</p><p><ahref="https://neitui-upload.info.100tal.com/upload_resume?type=out&amp;code=30156d1b863bb8f3f90867391ac50d4f">内部推荐(100tal.com)</a></p><h3 id="比亚迪">比亚迪</h3><p>投递日期9.14</p><p><ahref="https://job.byd.com/portal/pc/#/personalCenter/myApply">比亚迪招聘(byd.com)</a></p><h3 id="海康威视简历挂">海康威视（简历挂）</h3><p>投递日期9.15</p><p><a href="https://campushr.hikvision.com/myDelivery">校园招聘(hikvision.com)</a></p><h3 id="联想人才池">联想（人才池）</h3><p>投递日期9.15</p><p><a href="https://talent.lenovo.com.cn/account/apply">我的申请(lenovo.com.cn)</a></p><h3 id="携程人才池">携程（人才池）</h3><p>投递日期9.18</p><p><ahref="https://app.mokahr.com/campus-recruitment/trip/37757?sourceToken=c2fb946302192b49b05185eec45fcdc0#/candidateHome/applications">携程集团- 校园招聘 (mokahr.com)</a></p><h4 id="测评-4">9.20测评</h4><h3 id="shein测评挂">SHEIN（测评挂）</h3><p>投递日期9.18</p><h4 id="测评-5">9.20测评</h4><h3 id="腾讯云智">腾讯云智</h3><p>投递日期9.18</p><p><ahref="https://app-tc.mokahr.com/campus-recruitment/csig/20001#/job/98974e48-81fd-4192-81d0-c1dcfdf25d62/campus_apply/thanks?jobId=98974e48-81fd-4192-81d0-c1dcfdf25d62&amp;recommendCode=NTAAeBu&amp;codeType=1&amp;applyInfo%5BaimWorkCity%5D=厦门市&amp;applyInfo%5BrecommendCode%5D=NTAAeBu&amp;candidateName=孟海东&amp;candidateId=5280385">云智研发公司- 校园招聘 (mokahr.com)</a></p><h3 id="海尔集团">海尔集团</h3><p>投递日期9.21</p><p><ahref="https://maker.haier.net/client/campus/mydelivery.html">海尔招聘-海尔官方招聘网站(haier.net)</a></p><h2 id="boss投递-1">boss投递</h2><h3 id="高途简历挂">高途（简历挂）</h3><p>投递日期9.4</p><h3 id="途虎养车简历挂">途虎养车（简历挂）</h3><p>投递日期9.4</p><h4 id="测评-6">测评</h4><p>https://pt.normstar.net/ns-napmtest-web/login/joinlogin/789CCB2BCE2B2E29CD28353237343235B02C4E3635353336340000606F06FD.do</p><h3 id="奇安信">奇安信</h3><p>投递日期9.5</p><h3 id="boss直聘简历挂">boss直聘（简历挂）</h3><p>投递日期9.13</p><h3 id="万兴科技">万兴科技</h3><p>投递日期9.18</p><h2 id="牛客投递-1">牛客投递</h2><h3 id="garena">Garena</h3><p>投递日期9.13</p><h3 id="点点科技">点点科技</h3><p>投递日期9.13</p><h4 id="笔试-9">笔试</h4><p><ahref="https://exam.nowcoder.com/cts/17286274/summary?id=E07EC06D4D7EEC835D2B1AAD67C4DCC3#0/%7B%22uid%22%3A%22E07EC06D4D7EEC835D2B1AAD67C4DCC3%22%7D">点点互动2024校招【游戏服务器开发工程师】笔试A_牛客(nowcoder.com)</a></p><h5 id="算法题-2"><strong>算法题</strong></h5><p>给定两个app版本号version1和version2，请比较它们并返回结果。说明:版本号由一个或多个修订号(revision)组成，修订号之间使用∵'连接。每个修订号由多位数字组成，可能包含前导零。每个版本号至少包含一个字符。例如，2.5.33和0.1都是有效的版本号。比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，忽略任何前导零。也就是说，修订号1和修订号001相等。如果版本号中修订号个数不同，认为缺少的修订号等于0。例如，1.001== 1.1;1.0.1 &gt;1.0 ==1.0.0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VersionNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String version1, String version2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(version1 == <span class="literal">null</span> || version1.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(version2 == <span class="literal">null</span> || version2.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right1 &lt; version1.length() &amp;&amp; right2 &lt; version2.length())&#123;</span><br><span class="line">            <span class="keyword">while</span>(right1 &lt; version1.length() &amp;&amp;version1.charAt(right1) != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                right1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(version1.charAt(left1) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(version2.charAt(right2) != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                right2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right2 &lt; version2.length() &amp;&amp; version2.charAt(left2) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Integer.parseInt(version1.substring(left1, right1)) &gt; Integer.parseInt(version2.substring(left2, right2)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Integer.parseInt(version1.substring(left1, right1)) &lt; Integer.parseInt(version2.substring(left2, right2)))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right1++;</span><br><span class="line">                left1 = right1;</span><br><span class="line"></span><br><span class="line">                right2++;</span><br><span class="line">                left2 = right2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right1 &lt; version1.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right2 &lt; version2.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(compare(<span class="string">&quot;05.6&quot;</span>, <span class="string">&quot;5.6.4&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="盛趣游戏">盛趣游戏</h3><p>投递日期9.13</p><h1 id="中小厂试炼v2">中小厂试炼——V2</h1><h2 id="boss投递-2">boss投递</h2><h3 id="海德斯通">海德斯通</h3><p>投递日期：10.9</p><p><ahref="https://app.mokahr.com/m/candidate/applications/deliver-query/tanhai">海德斯通信有限公司- 投递查询 (mokahr.com)</a></p><h1 id="大厂冲刺v2">大厂冲刺——V2</h1><figure><img src="2023秋招投递记录/image-20231009234656537.png"alt="image-20231009234656537" /><figcaption aria-hidden="true">image-20231009234656537</figcaption></figure><h2 id="百度">百度</h2><h3 id="秋招">秋招</h3><p>岗位：java开发</p><p>投递日期：10.7，<ahref="https://talent.baidu.com/jobs/center">百度校园招聘(baidu.com)</a></p><h3 id="日常实习">日常实习</h3><p>投递日期：10.7，<ahref="https://talent.baidu.com/jobs/center">百度校园招聘(baidu.com)</a></p><h2 id="喜马拉雅">喜马拉雅</h2><h3 id="秋招-1">秋招</h3><p>岗位：java后端开发</p><p>投递日期：10.7</p><p><ahref="https://app.mokahr.com/campus-recruitment/himalaya/92431#/candidateHome/applications">喜马拉雅校园招聘(mokahr.com)</a></p><h3 id="实习">实习</h3><p>AIGC java</p><p>投递日期：10.7</p><h2 id="字节跳动">字节跳动</h2><h3 id="秋招简历挂">秋招（简历挂）</h3><p>岗位：后端开发</p><p>投递日期：10.7</p><p><ahref="https://jobs.bytedance.com/campus/position/application?spread=W5JT3VQ">应聘记录- 加入字节跳动 (bytedance.com)</a></p><h3 id="实习-1">实习</h3><p>岗位：后端开发</p><p>投递日期：10.7</p><p><ahref="https://jobs.bytedance.com/campus/position/application?spread=W5JT3VQ">应聘记录- 加入字节跳动 (bytedance.com)</a></p><h2 id="米哈游">米哈游</h2><h3 id="秋招-2">秋招</h3><p>岗位：云计算后端开发</p><p>投递日期：10.7</p><p><ahref="https://campus.mihoyo.com/#/campus/applyRecord">miHoYo校园招聘</a></p><h2 id="中新赛克">中新赛克</h2><h3 id="秋招-3">秋招</h3><p>岗位：Java后台工程师</p><p>投递日期：10.7</p><p><a href="https://recruit.sinovatio.com/resume/mine">中新赛克招聘官网(sinovatio.com)</a></p><h2 id="大华">大华</h2><h3 id="秋招-4">秋招</h3><p>岗位：Java开发工程师</p><p>投递日期：10.7</p><p><ahref="https://dahua.zhiye.com/personal/deliveryRecord">浙江大华技术股份有限公司(zhiye.com)</a></p><h2 id="万兴喵影">万兴喵影</h2><h3 id="秋招-5">秋招</h3><p>岗位：后端开发工程师</p><p>投递日期：10.9</p><p><ahref="https://app.mokahr.com/campus-recruitment/wanxingkeji/41591#/candidateHome/applications">万兴科技集团股份有限公司- 校园招聘 (mokahr.com)</a></p><h2 id="bilibili">Bilibili</h2><h3 id="秋招-6">秋招</h3><p>岗位：C端开发工程师、B端开发工程师</p><p>投递日期：10.9</p><p><ahref="https://jobs.bilibili.com/campus/records?token=9342a260-8d43-4281-81e7-5dc310f99b87&amp;channel=nowcoder">哔哩哔哩-招聘(bilibili.com)</a></p><h2 id="bigo">BIGO</h2><h3 id="秋招-7">秋招</h3><p>岗位：Java开发工程师</p><p>投递日期：10.9</p><p><ahref="https://recommendation.bigo.sg/recommendation-apply/bigo/1020?recommendCode=NTAY75x&amp;hash=#/job/bb5b0e0b-6101-4423-950c-4ec9a9cc1b66/apply/thanks?jobId=bb5b0e0b-6101-4423-950c-4ec9a9cc1b66&amp;recommendCode=NTAY75x&amp;codeType=1&amp;isRecommendation=false&amp;applyInfo%5BaimWorkCity%5D=广州市&amp;candidateName=孟海东&amp;candidateId=469506945">BIGO- 内部推荐</a></p><h2 id="海信集团">海信集团</h2><h3 id="秋招-8">秋招</h3><p>岗位：Java开发工程师</p><p>投递日期：10.9</p><p><ahref="https://jobs.hisense.com/form/friendly?fromPage=job&amp;CategoryId=2&amp;submissionId=360875497">海信集团招聘(hisense.com)</a></p><h2 id="奇安信-1">奇安信</h2><h3 id="秋招-9">秋招</h3><p>岗位：Java开发工程师</p><p>投递日期：10.11</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;标题上的V？表示用的第几版本简历投递。&lt;/p&gt;
&lt;h1 id=&quot;中小厂试炼v1&quot;&gt;中小厂试炼——V1&lt;/h1&gt;
&lt;h2 id=&quot;boss投递&quot;&gt;boss投递&lt;/h2&gt;
&lt;h3 id=&quot;保融科技&quot;&gt;保融科技&lt;/h3&gt;
&lt;p&gt;投递日期9.14&lt;/p&gt;
&lt;p&gt;投递地址：</summary>
      
    
    
    
    <category term="求职" scheme="https://vlsmhd.github.io/categories/%E6%B1%82%E8%81%8C/"/>
    
    
    <category term="求职" scheme="https://vlsmhd.github.io/tags/%E6%B1%82%E8%81%8C/"/>
    
    <category term="2023秋招" scheme="https://vlsmhd.github.io/tags/2023%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode单调栈题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/09/01/leetcode%E5%8D%95%E8%B0%83%E6%A0%88%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/09/01/leetcode%E5%8D%95%E8%B0%83%E6%A0%88%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-09-01T07:28:37.928Z</published>
    <updated>2023-09-01T13:08:16.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈">单调栈</h1><p>单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p><ul><li>单调递增栈：单调递增栈就是从<strong>栈底到栈顶</strong>数据是从大到小<ul><li>解释：其实就是出栈的顺序单调递增</li><li>操作：如果<strong>栈为空</strong>或<strong>入栈元素值小于栈顶元素值</strong>，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。</li></ul></li><li>单调递减栈：单调递减栈就是从<strong>栈底到栈顶</strong>数据是从小到大<ul><li>解释：其实就是出栈的顺序单调递减</li><li>操作：如果<strong>栈为空</strong>或<strong>入栈元素值大于栈顶元素值</strong>，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素大的元素全部出栈。</li></ul></li></ul><h2 id="模板">模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解</span></span><br><span class="line"><span class="keyword">for</span> (遍历外来数组)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (栈空 || 栈顶元素大于等于（小于等于）当前比较元素)</span><br><span class="line">&#123;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//核心代码，往往在这边统计单调区间长度</span></span><br><span class="line"><span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于（大于）当前元素)</span><br><span class="line">&#123;</span><br><span class="line">栈顶元素出栈;</span><br><span class="line">更新结果;</span><br><span class="line">&#125;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用">应用</h2><p>适合解决一些单调区间的问题。</p><p>比如一段无序数组，从里面找出几个单调区间这样。</p><h1 id="题目">题目</h1><h3 id="每日温度"><ahref="https://leetcode.cn/problems/daily-temperatures/">739.每日温度</a></h3><p>给定一个整数数组 <code>temperatures</code>，表示每天的温度，返回一个数组 <code>answer</code> ，其中<code>answer[i]</code> 是指对于第 <code>i</code>天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用<code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><h4 id="单调递增栈">单调递增栈</h4><p>栈保证：栈底到栈顶的大小顺序是：从大到小。</p><p>这样遇到比栈顶大的元素，循环出栈的时候能通过下标计算结果，因此栈内存结果也是不错的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单调栈存下标</span></span><br><span class="line">        <span class="comment">//单调递增栈</span></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || temperatures[i] &lt; temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    ans[idx] = i - idx;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="股票价格跨度"><ahref="https://leetcode.cn/problems/online-stock-span/">901.股票价格跨度</a></h3><p>设计一个算法收集某些股票的每日报价，并返回该股票当日价格的<strong>跨度</strong> 。</p><p>当日股票价格的 <strong>跨度</strong>被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><ul><li>例如，如果未来 7 天股票的价格是<code>[100,80,60,70,60,75,85]</code>，那么股票跨度将是<code>[1,1,1,2,1,4,6]</code> 。</li></ul><p>实现 <code>StockSpanner</code> 类：</p><ul><li><code>StockSpanner()</code> 初始化类对象。</li><li><code>int next(int price)</code> 给出今天的股价 <code>price</code>，返回该股票当日价格的 <strong>跨度</strong> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]</span><br><span class="line">[[], [100], [80], [60], [70], [60], [75], [85]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 1, 1, 2, 1, 4, 6]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockSpanner stockSpanner = new StockSpanner();</span><br><span class="line">stockSpanner.next(100); // 返回 1</span><br><span class="line">stockSpanner.next(80);  // 返回 1</span><br><span class="line">stockSpanner.next(60);  // 返回 1</span><br><span class="line">stockSpanner.next(70);  // 返回 2</span><br><span class="line">stockSpanner.next(60);  // 返回 1</span><br><span class="line">stockSpanner.next(75);  // 返回 4 ，因为截至今天的最后 4 个股价 (包括今天的股价 75) 都小于或等于今天的股价。</span><br><span class="line">stockSpanner.next(85);  // 返回 6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= price &lt;= 105</code></li><li>最多调用 <code>next</code> 方法 <code>104</code> 次</li></ul><h4 id="单调递增栈-1">单调递增栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line">    <span class="comment">//单调递减   栈存下标和值</span></span><br><span class="line">    LinkedList&lt;<span class="type">int</span>[]&gt; stack ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加哨兵</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, Integer.MAX_VALUE&#125;);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(stack.peek()[<span class="number">1</span>] &lt;= price)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时候栈首必 &gt; price,直接取下标计算</span></span><br><span class="line">        ans = idx - stack.peek()[<span class="number">0</span>];</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;idx, price&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调栈&quot;&gt;单调栈&lt;/h1&gt;
&lt;p&gt;单调栈中存放的数据应该是有序的，所以单调栈也分为&lt;strong&gt;单调递增栈&lt;/strong&gt;和&lt;strong&gt;单调递减栈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单调递增栈：单调递增栈就是从&lt;strong&gt;栈底到栈顶&lt;/</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="单调栈" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode区间集合题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/31/leetcode%E5%8C%BA%E9%97%B4%E9%9B%86%E5%90%88%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/31/leetcode%E5%8C%BA%E9%97%B4%E9%9B%86%E5%90%88%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-31T08:12:39.540Z</published>
    <updated>2023-09-13T03:17:06.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解题思路">解题思路</h1><p>一般是找不相交的集合，得出答案。基本上都是配合贪心。</p><h1 id="题目">题目</h1><h2 id="简单">简单</h2><h3 id="汇总区间"><ahref="https://leetcode.cn/problems/summary-ranges/">228.汇总区间</a></h3><p>给定一个 <strong>无重复元素</strong> 的 <strong>有序</strong>整数数组 <code>nums</code> 。</p><p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的<strong>最小有序</strong> 区间范围列表</em>。也就是说，<code>nums</code>的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于<code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>"a-&gt;b"</code> ，如果 <code>a != b</code></li><li><code>"a"</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure><h4 id="双指针">双指针</h4><p>双指针规划每个区间的起始末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; right &lt; n) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span>(right + <span class="number">1</span> &lt; n &amp;&amp; nums[right + <span class="number">1</span>] - nums[right] == <span class="number">1</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                sb.append(nums[left] + <span class="string">&quot;-&gt;&quot;</span> + nums[right]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(nums[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            right++;</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中等">中等</h2><h3 id="无重叠区间"><ahref="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区间</a></h3><p>给定一个区间的集合 <code>intervals</code> ，其中<code>intervals[i] = [starti, endi]</code> 。返回<em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [ [1,2], [1,2], [1,2] ]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><h4 id="排序贪心">排序+贪心</h4><p>不能一口吃成胖子，说的就是这题，我们一开始找一个右边界很小的区间开始，为什么这样干，因为这样干就能保证要移除的区间最少。为什么？</p><p>因为一开始的区间范围很小，然后接下来走贪心思路，右区间慢慢扩大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//选取初始区间</span></span><br><span class="line">        Arrays.sort(intervals, (a,b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] interval = intervals[i];</span><br><span class="line">            <span class="keyword">if</span>(!(interval[<span class="number">1</span>] &lt;= left || interval[<span class="number">0</span>] &gt;= right) )&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = Math.min(interval[<span class="number">0</span>], left);</span><br><span class="line">                right = Math.max(interval[<span class="number">1</span>], right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用最少数量的箭引爆气球"><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a></h3><p>有一些球形气球贴在一堵用 XY平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code>，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在<code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong>地射出。在坐标 <code>x</code>处射出一支箭，若有一个气球的直径的开始和结束坐标为<code>x``start</code>，<code>x``end</code>， 且满足<code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong>。可以射出的弓箭的数量 <strong>没有限制</strong> 。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的<strong>最小</strong> 弓箭数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处发射箭，击破气球[10,16]和[7,12]。</span><br></pre></td></tr></table></figure><p>​ <strong>提示:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 105</code></li><li><code>points[i].length == 2</code></li><li><code>-2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</code></li></ul><h4 id="排序贪心-1">排序+贪心</h4><p>像上一题一样，先选个区间作为第一个区间，这题类似，先射一箭，保证这一箭射到最多的气球，然后再慢慢加。这就是贪心的思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//选取初始区间</span></span><br><span class="line">        Arrays.sort(points, (p1, p2) -&gt; p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>] ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//射的第一箭</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//排序后，后面的每个区间的左坐标 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] point : points)&#123;</span><br><span class="line">            <span class="keyword">if</span>(point[<span class="number">0</span>] &gt; right)&#123;</span><br><span class="line">                right = point[<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并区间"><ahref="https://leetcode.cn/problems/merge-intervals/">56.合并区间</a></h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><h4 id="排序贪心-2">排序+贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ans.size();<span class="comment">//用作ans集合的下标，i很大的时候，可能ans集合中的元素个数&lt;&lt;i</span></span><br><span class="line"><span class="comment">//也是贪心的一个小思路：每次比较集合最后一个元素，希望能合并。</span></span><br><span class="line">            <span class="keyword">if</span>(ans.size() == <span class="number">0</span> || ans.get(size-<span class="number">1</span>)[<span class="number">1</span>] &lt; l )&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.get(size - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(r, ans.get(size-<span class="number">1</span>)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入区间"><ahref="https://leetcode.cn/problems/insert-interval/">57.插入区间</a></h3><p>给你一个 <strong>无重叠的</strong><em>，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [], newInterval = [5,7]</span><br><span class="line">输出：[[5,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,5]], newInterval = [2,3]</span><br><span class="line">输出：[[1,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,5]], newInterval = [2,7]</span><br><span class="line">输出：[[1,7]]</span><br></pre></td></tr></table></figure><h4 id="模拟">模拟</h4><p>画出这个图即可模拟：摘自<ahref="https://leetcode.cn/u/xiao_ben_zhu/">笨猪爆破组 -力扣（LeetCode）</a></p><figure><img src="leetcode区间集合题目专项训练/1604465027-kDWfBc-image.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newl</span> <span class="operator">=</span> newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">newr</span> <span class="operator">=</span> newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//左边不重合的区间</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newl)&#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重合区间判断</span></span><br><span class="line">        <span class="comment">//有可能intervals[i][0]和intervals[i][1]也比newR大，就在右边了</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newr )&#123;</span><br><span class="line">            <span class="comment">//不断合并，以更新new r,l为准</span></span><br><span class="line">            newl = Math.min(intervals[i][<span class="number">0</span>], newl);</span><br><span class="line">            newr = Math.max(intervals[i][<span class="number">1</span>], newr);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newl, newr&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边不重合的区间</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; intervals[i][<span class="number">0</span>] &gt; newr)&#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解题思路&quot;&gt;解题思路&lt;/h1&gt;
&lt;p&gt;一般是找不相交的集合，得出答案。基本上都是配合贪心。&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;题目&lt;/h1&gt;
&lt;h2 id=&quot;简单&quot;&gt;简单&lt;/h2&gt;
&lt;h3 id=&quot;汇总区间&quot;&gt;&lt;a
href=&quot;https://leetco</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="区间集合" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%8C%BA%E9%97%B4%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode前缀树题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/29/leetcode%E5%89%8D%E7%BC%80%E6%A0%91%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/29/leetcode%E5%89%8D%E7%BC%80%E6%A0%91%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-29T05:48:14.839Z</published>
    <updated>2023-10-05T04:56:28.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀树概念">前缀树概念</h1><p>假设有b，abc，abd，bcd，abcd，efg，hii这6个单词,那我们创建trie树就得到</p><figure><imgsrc="leetcode前缀树题目专项训练/v2-9d07fbd164fc0d737aabe428b4484bd1_720w.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="题目">题目</h1><h2 id="中等">中等</h2><h3 id="实现-trie-前缀树"><ahref="https://leetcode.cn/problems/implement-trie-prefix-tree/">208.实现 Trie (前缀树)</a></h3><p><strong><ahref="https://baike.baidu.com/item/字典树/9825209?fr=aladdin">Trie</a></strong>（发音类似"try"）或者说 <strong>前缀树</strong>是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串<code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串<code>word</code> 在前缀树中，返回<code>true</code>（即，在检索之前已经插入）；否则，返回<code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code>如果之前已经插入的字符串 <code>word</code> 的前缀之一为<code>prefix</code> ，返回 <code>true</code> ；否则，返回<code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure><h4 id="n叉树">n叉树</h4><p>本题只涉及26个字母，所以我们的字典树（前缀树），只搞长度26即可。</p><p>有点类似DFA的思路，每个字符算一个状态，然后后面有26钟状态可选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    Trie[] children;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//下面这个错误：child是引用的引用，不能代替数组内部元素的引用</span></span><br><span class="line">            <span class="comment">// Trie child = cur.children[word.charAt(i) - &#x27;a&#x27;];</span></span><br><span class="line">            <span class="keyword">if</span>(cur.children[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                cur.children[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(cur.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cur.isEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prefix.length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(cur.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="搜索推荐系统"><ahref="https://leetcode.cn/problems/search-suggestions-system/">1268.搜索推荐系统</a></h3><p>给你一个产品数组 <code>products</code> 和一个字符串<code>searchWord</code> ，<code>products</code>数组中每个产品都是一个字符串。</p><p>请你设计一个推荐系统，在依次输入单词 <code>searchWord</code>的每一个字母后，推荐 <code>products</code> 数组中前缀与<code>searchWord</code>相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。</p><p>请你以二维列表的形式，返回在输入 <code>searchWord</code>每个字母后相应的推荐产品的列表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;</span><br><span class="line">输出：[</span><br><span class="line">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class="line">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class="line">]</span><br><span class="line">解释：按字典序排序后的产品列表是 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class="line">输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]</span><br><span class="line">输入 mou， mous 和 mouse 后系统都返回 [&quot;mouse&quot;,&quot;mousepad&quot;]</span><br></pre></td></tr></table></figure><h4 id="字典树排序">字典树+排序</h4><p>排序是因为需要取字典序最小的前三条，可以事先对products数组进行排序，这样添加到字典树之后，也是有序的。</p><p>本题只需字典树，不需要借助前缀树的isEnd字段了，没啥用。</p><p>但是每个字典树需要维护一个集合，这个集合存的元素都是包含当前前缀的产品集合。方便取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">suggestedProducts</span><span class="params">(String[] products, String searchWord)</span> &#123;</span><br><span class="line">        Arrays.sort(products);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : products) insert(s);</span><br><span class="line">        <span class="comment">//初始化结果集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; searchWord.length(); i++)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        search(searchWord, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                cur.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            cur.list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String word, List&lt;List&lt;String&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(cur.children[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            cur = cur.children[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="comment">//把ans填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; Math.min(<span class="number">3</span>, cur.list.size()); j++)&#123;</span><br><span class="line">                ans.get(i).add(cur.list.get(j));</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字典树结点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">        TrieNode()&#123;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加与搜索单词---数据结构设计"><ahref="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211.添加与搜索单词 - 数据结构设计</a></h3><p>请你设计一个数据结构，支持 添加新单词 和查找字符串是否与任何先前添加的字符串匹配 。</p><p>实现词典类 <code>WordDictionary</code> ：</p><ul><li><code>WordDictionary()</code> 初始化词典对象</li><li><code>void addWord(word)</code> 将 <code>word</code>添加到数据结构中，之后可以对它进行匹配</li><li><code>bool search(word)</code> 如果数据结构中存在字符串与<code>word</code> 匹配，则返回 <code>true</code> ；否则，返回<code>false</code> 。<code>word</code> 中可能包含一些 <code>'.'</code>，每个 <code>.</code> 都可以表示任何一个字母。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span><br><span class="line">[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,false,true,true,true]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">WordDictionary wordDictionary = new WordDictionary();</span><br><span class="line">wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">wordDictionary.search(&quot;pad&quot;); // 返回 False</span><br><span class="line">wordDictionary.search(&quot;bad&quot;); // 返回 True</span><br><span class="line">wordDictionary.search(&quot;.ad&quot;); // 返回 True</span><br><span class="line">wordDictionary.search(&quot;b..&quot;); // 返回 True</span><br></pre></td></tr></table></figure><h4 id="构建前缀树-dfs">构建前缀树 + DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"></span><br><span class="line">    Trie root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        root.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(String word, <span class="type">int</span> idx, Trie root)</span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(word.length() == idx)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trie[] children = root.getChildren();</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(idx);</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(children[c - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(word, idx + <span class="number">1</span>, children[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//为.号，遍历26个字母，看children数组哪个不为空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(children[i] != <span class="literal">null</span>)&#123;</span><br><span class="line">                     <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dfs(word, idx + <span class="number">1</span>, children[i]);<span class="comment">//从前往后遍历，不能直接返回，因为遇到不满足情况的直接返回了，后面的情况就忽略了</span></span><br><span class="line">                     <span class="keyword">if</span>(b)&#123;<span class="comment">//但是搜到了，那就要直接返回，不然后面有搜不到的</span></span><br><span class="line">                         <span class="keyword">return</span> b;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.children[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                cur.children[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Trie[] getChildren() &#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="困难">困难</h2><h3 id="单词搜索-ii">*<ahref="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索II</a></h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code>和一个单词（字符串）列表 <code>words</code>，<em>返回所有二维网格上的单词</em> 。</p><p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong>内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode前缀树题目专项训练/search1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">输出：[&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><img src="leetcode前缀树题目专项训练/search2.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h4 id="字典树-dfs-回溯">字典树 + DFS + 回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;<span class="comment">//减少冗余代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(ans, trie, i, j, board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Set&lt;String&gt; ans, Trie trie, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!trie.children.containsKey(board[i][j]))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        trie = trie.children.get(c);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(trie.word)) &#123;</span><br><span class="line">            ans.add(trie.word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//访问标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> j + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i1 &gt;= <span class="number">0</span> &amp;&amp; i1 &lt; board.length &amp;&amp; j1 &gt;= <span class="number">0</span> &amp;&amp; j1 &lt; board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                dfs(ans, trie, i1, j1, board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        board[i][j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    String word;</span><br><span class="line">    Map&lt;Character, Trie&gt; children;<span class="comment">//改用map，构建简化的字典树，存在的字符不会重复创建</span></span><br><span class="line">    <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Trie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line">                cur.children.put(c, <span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀树概念&quot;&gt;前缀树概念&lt;/h1&gt;
&lt;p&gt;假设有b，abc，abd，bcd，abcd，efg，hii
这6个单词,那我们创建trie树就得到&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;leetcode前缀树题目专项训练/v2-9d07fbd164fc</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="前缀树" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode位运算题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/28/leetcode%E4%BD%8D%E8%BF%90%E7%AE%97%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/28/leetcode%E4%BD%8D%E8%BF%90%E7%AE%97%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-28T02:23:24.268Z</published>
    <updated>2023-08-28T03:22:43.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算知识">位运算知识</h1><p>位运算的知识：</p><p>对于十进制整数 x，我们可以用 <code>x &amp; 1</code> 得到 x的二进制表示的最低位，它等价于 x % 2：</p><ul><li><p>例如当 x = 3 时，x 的二进制表示为 11，x &amp; 1 的值为1；</p></li><li><p>例如当 x = 6 时，x 的二进制表示为 110，x &amp; 1 的值为0。</p></li></ul><p>对于十进制整数 x，我们可以用 <code>x &amp; (1 &lt;&lt; k)</code>来判断 x 二进制表示的第 k 位（最低位为第 0 位）是否为1。如果该表达式的值大于零，那么第 k 位为 1：</p><ul><li><p>例如当 x = 3 时，x 的二进制表示为 11，x &amp; (1 &lt;&lt; 1) = 11&amp; 10 = 10 &gt; 0，说明第 1 位为 1；</p></li><li><p>例如当 x = 5 时，x 的二进制表示为 101，x &amp; (1 &lt;&lt; 1) =101 &amp; 10 = 0，说明第 1 位不为 1。</p></li></ul><p>对于十进制整数 x，我们可以用 <code>(x &gt;&gt; k) &amp; 1</code> 得到x 二进制表示的第 k 位（最低位为第 0 位）。如果 x 二进制表示的位数小于k，那么该表达式的值为零：</p><ul><li><p>例如当 x = 3 时，x 的二进制表示为 11，(x &gt;&gt; 1) &amp; 1 = 1&amp; 1 = 1，说明第 1 位为 1；</p></li><li><p>例如当 x = 5 时，x 的二进制表示为 101，(x &gt;&gt; 1) &amp; 1 =10 &amp; 1 = 0，说明第 1 位为 0。</p></li><li><p>例如当 x = 6 时，x 的二进制表示为 110，(x &gt;&gt; 3) &amp; 1 = 0&amp; 1 = 0，说明第 3 位为 0。</p></li></ul><h3 id="比特位计数"><ahref="https://leetcode.cn/problems/counting-bits/">338.比特位计数</a></h3><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code>中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code>的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组<code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,1]</span><br><span class="line">解释：</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure><h4 id="简单循环与运算">简单循环与运算</h4><p>传统的处理数的方式：拿当前的数和1进行&amp;判断最后一位是不是1，然后二进制右移一下，判断下一位...</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span>(cur &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((cur &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                    ans[i]++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                cur &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能">性能</h5><figure><imgsrc="C:\Users\LEGION\AppData\Roaming\Typora\typora-user-images\image-20230828100829993.png"alt="image-20230828100829993" /><figcaption aria-hidden="true">image-20230828100829993</figcaption></figure><h4 id="section"></h4><h3 id="只出现一次的数字"><ahref="https://leetcode.cn/problems/single-number/">136.只出现一次的数字</a></h3><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code>，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h4 id="异或判重">异或判重</h4><p>异或运算：相同为0，不同为1。</p><p>假如两个数^后的结果为0，说明这两个数完全一样，利用这个性质，把数组中全部的元素异或一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="或运算的最小翻转次数"><ahref="https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/">1318.或运算的最小翻转次数</a></h3><p>给你三个正整数 <code>a</code>、<code>b</code> 和 <code>c</code>。</p><p>你可以对 <code>a</code> 和 <code>b</code>的二进制表示进行位翻转操作，返回能够使按位或运算 <code>a</code> OR<code>b</code> == <code>c</code> 成立的最小翻转次数。</p><p>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0变成 1 。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode位运算题目专项训练/sample_3_1676.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = 6, c = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a &lt;= 10^9</code></li><li><code>1 &lt;= b &lt;= 10^9</code></li><li><code>1 &lt;= c &lt;= 10^9</code></li></ul><h4 id="枚举位运算">枚举+位运算</h4><p>因为a、b、c的位数最多是30位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFlips</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">31</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit_a</span> <span class="operator">=</span> (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit_b</span> <span class="operator">=</span> (b &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit_c</span> <span class="operator">=</span> (c &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bit_c == <span class="number">0</span>)&#123;</span><br><span class="line">                res += bit_a + bit_b;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//c的某一位是1，要求a或b至少有一位是1</span></span><br><span class="line">                res += (bit_a + bit_b == <span class="number">0</span>? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算知识&quot;&gt;位运算知识&lt;/h1&gt;
&lt;p&gt;位运算的知识：&lt;/p&gt;
&lt;p&gt;对于十进制整数 x，我们可以用 &lt;code&gt;x &amp;amp; 1&lt;/code&gt; 得到 x
的二进制表示的最低位，它等价于 x % 2：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;例如当 x = </summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="位运算" scheme="https://vlsmhd.github.io/categories/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode二分查找题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/24/leetcode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/24/leetcode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-24T01:28:40.154Z</published>
    <updated>2023-10-11T04:45:42.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解题思路">解题思路</h1><ol type="1"><li>二分的题就是利用二分的特性，找到一个<strong>关键点</strong>，由这个关键点计算出答案。</li><li>二分必须在有序的条件基础上查找，所以我们需要分析有效条件，找到一个有序的区域供我们查找。</li></ol><h1 id="题目">题目</h1><h2 id="简单">简单</h2><h3 id="猜数字大小"><ahref="https://leetcode.cn/problems/guess-number-higher-or-lower/">374.猜数字大小</a></h3><p>猜数字游戏的规则如下：</p><ul><li>每轮游戏，我都会从 <strong>1</strong> 到 <strong><em>n</em></strong>随机选择一个数字。 请你猜选出的是哪个数字。</li><li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li></ul><p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code>来获取猜测结果，返回值一共有 3种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p><ul><li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li><li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li><li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li></ul><p>返回我选出的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10, pick = 6</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h4 id="平衡版二分">平衡版二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//数字不重复，先不考虑优化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left)&gt;&gt;<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(guess(mid) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                right = mid;<span class="comment">//答案在[left,mid]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//平衡版本</span></span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//答案在[mid + 1, right]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索插入位置"><ahref="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h4 id="二分">二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left= <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;  target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;  target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中等">中等</h2><h3 id="咒语和药水的成功对数"><ahref="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300.咒语和药水的成功对数</a></h3><p>给你两个正整数数组 <code>spells</code> 和 <code>potions</code>，长度分别为 <code>n</code> 和 <code>m</code> ，其中<code>spells[i]</code> 表示第 <code>i</code>个咒语的能量强度，<code>potions[j]</code> 表示第 <code>j</code>瓶药水的能量强度。</p><p>同时给你一个整数 <code>success</code> 。一个咒语和药水的能量强度<strong>相乘</strong> 如果 <strong>大于等于</strong><code>success</code> ，那么它们视为一对 <strong>成功</strong>的组合。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>pairs</code>，其中<code>pairs[i]</code> 是能跟第 <code>i</code> 个咒语成功组合的<strong>药水</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7</span><br><span class="line">输出：[4,0,3]</span><br><span class="line">解释：</span><br><span class="line">- 第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。</span><br><span class="line">- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。</span><br><span class="line">- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。</span><br><span class="line">所以返回 [4,0,3] 。</span><br></pre></td></tr></table></figure><h4 id="平衡二分">平衡二分</h4><p>本题目的就是找到比success大的数<code>potions[mid] * spells[i]</code>中最小的那个数的下标，然后拿数组长度一减就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] successfulPairs(<span class="type">int</span>[] spells, <span class="type">int</span>[] potions, <span class="type">long</span> success) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> spells.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> potions.length;</span><br><span class="line">        <span class="type">int</span>[] pairs = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.sort(potions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rightmost版本</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m - <span class="number">1</span>;<span class="comment">//[left, right]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿success当目标</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(success &lt;= (<span class="type">long</span>)potions[mid] * spells[i] )&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pairs[i] = m - left;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找峰值"><ahref="https://leetcode.cn/problems/find-peak-element/">162.寻找峰值</a></h3><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回<strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><h4 id="二分-1">二分</h4><p>根据峰值的特点，峰值左边的元素大于左右两侧的元素，我们每次找到mid就和mid+1处的高度相比，如果小，那说明mid+1有可能是峰值，left要更新到mid+1位置处去，如果比mid+1大，说明当前的mid可能是峰值（当然也可能在左边），right往左边来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= right &amp;&amp; nums[mid] &lt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爱吃香蕉的珂珂"><ahref="https://leetcode.cn/problems/koko-eating-bananas/">875.爱吃香蕉的珂珂</a></h3><p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code>堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code>小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>k</code>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code>根。如果这堆香蕉少于 <code>k</code>根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度<code>k</code>（<code>k</code> 为整数）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [3,6,7,11], h = 8</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h4 id="二分-2">二分</h4><p>这里我们二分查找piles是没有任何意义的，我们本题的目标是k，k所在的区域为<code>[1, Max(piles)]</code>，很明显是一个递增序列, 因此我们把目光转移到k上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二分找k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, piles[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//每一轮计算k = mid的时候吃完香蕉需要的时间</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(piles[i] &lt;= mid)&#123;</span><br><span class="line">                    hour ++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hour += piles[i]/mid + ((piles[i] % mid) &gt; <span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果超时，k不够</span></span><br><span class="line">            <span class="keyword">if</span>(hour &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果满足，尽可能往左找</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索二维矩阵"><ahref="https://leetcode.cn/problems/search-a-2d-matrix/">74.搜索二维矩阵</a></h3><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非递减顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code>在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode二分查找题目专项训练/mat.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><img src="leetcode二分查找题目专项训练/mat2.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h4 id="每行二分">每行二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] m : matrix) &#123;</span><br><span class="line">            <span class="comment">//如果当前值比本行最后一个值大，那它就可能出现在下一行</span></span><br><span class="line">            <span class="keyword">if</span>(target &gt; m[m.length - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(m[mid] &lt; target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m[mid] &gt; target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><ahref="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33.搜索旋转排序数组</a></h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值<strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了<strong>旋转</strong>，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标<strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code>在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数<code>target</code> ，如果 <code>nums</code> 中存在这个目标值<code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code>的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h4 id="分区二分">分区二分</h4><p>先遍历一趟找到旋转点，旋转点左右两部分都是递增，都可以进行二分，然后判断target是否小于第一个元素来判断查询区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, k+<span class="number">1</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, k, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解题思路&quot;&gt;解题思路&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;二分的题就是利用二分的特性，找到一个&lt;strong&gt;关键点&lt;/strong&gt;，由这个关键点计算出答案。&lt;/li&gt;
&lt;li&gt;二分必须在有序的条件基础上查找，所以我们需要分析有效条件，找到一个有</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="二分查找" scheme="https://vlsmhd.github.io/categories/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode前缀和题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/23/leetcode%E5%89%8D%E7%BC%80%E5%92%8C%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/23/leetcode%E5%89%8D%E7%BC%80%E5%92%8C%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-23T02:00:59.732Z</published>
    <updated>2023-08-24T01:33:44.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和算法">前缀和算法</h1><h2 id="前缀和一维">前缀和（一维）：</h2><p>对于一个给定的数列 A ，它的前缀和数列 S 中 S[i] 表示从第 1 个元素到第i 个元素的总和。用公式表示为：<span class="math inline">\(S[i] =\displaystyle \sum^i_{j=1}A[j]\)</span></p><p><strong>计算方法：</strong>通过递推的方式。</p><p><span class="math inline">\(S[i] = S[i-1] + A[i]\)</span></p><p>S[i-1]表示前i-1个元素之和。</p><p><strong>应用：</strong></p><p>计算任意区间和：</p><blockquote><p><strong>假设</strong>：有 m 个查询，每个查询给出index： l,r。<strong>需求</strong>：计算从数组（数组长度假设为 n ）第 l 个元素到第 r个元素的和。</p></blockquote><p>前缀和计算区间：<span class="math inline">\([l,r]区间总和为：S[r] -S[l-1]\)</span></p><h1 id="题目">题目</h1><h3 id="找到最高海拔"><ahref="https://leetcode.cn/problems/find-the-highest-altitude/">1732.找到最高海拔</a></h3><p>有一个自行车手打算进行一场公路骑行，这条路线总共由 <code>n + 1</code>个不同海拔的点组成。自行车手从海拔为 <code>0</code> 的点 <code>0</code>开始骑行。</p><p>给你一个长度为 <code>n</code> 的整数数组 <code>gain</code> ，其中<code>gain[i]</code> 是点 <code>i</code> 和点 <code>i + 1</code> 的<strong>净海拔高度差</strong>（<code>0 &lt;= i &lt; n</code>）。请你返回<strong>最高点的海拔</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：gain = [-5,1,5,0,-7]</span><br><span class="line">输出：1</span><br><span class="line">解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。</span><br></pre></td></tr></table></figure><h4 id="简单一维前缀和">简单一维前缀和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestAltitude</span><span class="params">(<span class="type">int</span>[] gain)</span> &#123;</span><br><span class="line">        <span class="comment">//h[i+1] - h[i] = gain[i];</span></span><br><span class="line">        <span class="comment">//h[0] = 0</span></span><br><span class="line">        <span class="comment">//h[1] = h[0] + gain[0]</span></span><br><span class="line">        <span class="comment">//h[2] = h[1] + gain[1] = 0 + gain[0] + gain[1]</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也就是说：gain的前n项和，就是第n个点的高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gain.length; i++)&#123;</span><br><span class="line">            sum += gain[i];</span><br><span class="line">            res = Math.max(sum, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能">性能</h5><figure><img src="leetcode前缀和题目专项训练/image-20230823103444849.png"alt="image-20230823103444849" /><figcaption aria-hidden="true">image-20230823103444849</figcaption></figure><h3 id="寻找数组的中心下标"><ahref="https://leetcode.cn/problems/find-pivot-index/">724.寻找数组的中心下标</a></h3><p>给你一个整数数组 <code>nums</code> ，请计算数组的<strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong>是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code>，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong>的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><h4 id="一维前缀和">一维前缀和</h4><p>先通过nums数组，计算出前缀和数组。</p><p>这里前缀和数组预留一个s[0]代表左边界左边的元素和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            s[i+<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[n]-s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀和算法&quot;&gt;前缀和算法&lt;/h1&gt;
&lt;h2 id=&quot;前缀和一维&quot;&gt;前缀和（一维）：&lt;/h2&gt;
&lt;p&gt;对于一个给定的数列 A ，它的前缀和数列 S 中 S[i] 表示从第 1 个元素到第
i 个元素的总和。用公式表示为：&lt;span class=&quot;math in</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="前缀和" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode滑动窗口题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/20/leetcode%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/20/leetcode%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-20T05:10:30.242Z</published>
    <updated>2023-09-16T03:37:06.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口算法">滑动窗口算法</h2><p>基本概念：</p><p>滑动窗口基于双指针的思想，两个指针指向的元素区间，构成一个窗口。</p><p>种类：</p><ul><li>固定大小，如本题</li><li>可变大小</li></ul><p>应用：</p><p>解题是什么时候会用到滑动窗口？</p><ol type="1"><li>一般数据结构是数组字符串这样的。</li><li>求取某个<strong>子串</strong>或者<strong>子序列最长最短</strong>等最值问题或者求某个目标值时</li><li>该问题本身可以暴力求解</li></ol><p>移动规律：</p><ol type="1"><li>初始化：left和right都指向0位置，区间为[0,0)左闭右开。</li><li>遍历：<ol type="1"><li>右指针开始动，循环遍历整个数组，跳出循环的条件是right指针超过数组长度。</li><li>根据实际情况，看左指针是否需要移动，缩小窗口。</li><li>循环执行第2步</li></ol></li></ol><p>模板伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Get nums|string s</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> nums[right]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(left need move)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="comment">//缩小窗口</span></span><br><span class="line">        left++;</span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增大窗口</span></span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode题目">leetcode题目</h2><h3 id="子数组最大平均数-i"><ahref="https://leetcode.cn/problems/maximum-average-subarray-i/">643.子数组最大平均数 I</a></h3><p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code>和一个整数 <code>k</code> 。</p><p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong>的连续子数组，并输出该最大平均数。</p><p>任何误差小于 <code>10-5</code> 的答案都将被视为正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure><h4 id="滑动窗口超时版本">滑动窗口超时版本</h4><p>这个写法突出不了滑动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + k &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + k  -<span class="number">1</span>; j &gt;= i &amp;&amp; j &lt; n; j--)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(<span class="number">1.0</span> * sum / k, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化版本">优化版本</h4><p>就是滑动的时候，滑动一个添加末尾删除头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        System.out.println(n);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + k &lt; n; i++)&#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            sum += nums[i + k]; </span><br><span class="line">            ans = Math.max(sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * <span class="number">1.0</span> / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定长子串中元音的最大数目"><ahref="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">1456.定长子串中元音的最大数目</a></h3><p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p><p>请返回字符串 <code>s</code> 中长度为 <code>k</code>的单个子字符串中可能包含的最大元音字母数。</p><p>英文中的 <strong>元音字母</strong> 为（<code>a</code>,<code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abciiidef&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aeiou&quot;, k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：任意长度为 2 的子字符串都包含 2 个元音字母。</span><br></pre></td></tr></table></figure><h4 id="哈希set滑动窗口">哈希set+滑动窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        set.add(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">        set.add(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">        set.add(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        set.add(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(i)))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + k &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(i)))&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(i+k)))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件语句滑动窗口">条件语句+滑动窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// set.add(&#x27;a&#x27;);</span></span><br><span class="line">        <span class="comment">// set.add(&#x27;e&#x27;);</span></span><br><span class="line">        <span class="comment">// set.add(&#x27;i&#x27;);</span></span><br><span class="line">        <span class="comment">// set.add(&#x27;o&#x27;);</span></span><br><span class="line">        <span class="comment">// set.add(&#x27;u&#x27;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVowel(s.charAt(i)))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + k &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVowel(s.charAt(i)))&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isVowel(s.charAt(i+k)))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27;a&#x27;</span> || ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;i&#x27;</span> || ch == <span class="string">&#x27;o&#x27;</span> || ch == <span class="string">&#x27;u&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相比set，速度快了将近一倍。</li></ul><h3 id="最大连续1的个数-iii"><ahref="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004.最大连续1的个数 III</a></h3><p><a id="1004"></a></p><p>给定一个二进制数组 <code>nums</code> 和一个整数<code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code>，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure><h4 id="滑动窗口脑筋急转弯">滑动窗口+脑筋急转弯</h4><p>我们统计0的个数，如果0的个数超过了k，就说明连续1已经中断（不能再翻转0了），然后左指针慢慢走过来（不能直接越到right这边）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zeroNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录0的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="comment">//窗口缩小</span></span><br><span class="line">            <span class="keyword">while</span>(zeroNum &gt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] == <span class="number">0</span>)&#123;</span><br><span class="line">                    zeroNum--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删掉一个元素以后全为-1-的最长子数组"><ahref="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/">1493.删掉一个元素以后全为 1 的最长子数组</a></h3><p>给你一个二进制数组 <code>nums</code> ，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 1的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><p><strong>提示 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,0,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1,1,0,1,1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</span><br></pre></td></tr></table></figure><h4 id="滑动窗口">滑动窗口</h4><p>和<a href="#1004">1004</a>题目类似，这题不同的是，我们容许里面有一个0存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">zeroNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroNum++;<span class="comment">//0个数的计算一定要在窗口滑动前处理。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(zeroNum &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left] == <span class="number">0</span>)&#123;</span><br><span class="line">                    zeroNum--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长度最小的子数组"><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a></h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数<code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的<strong>连续子数组</strong><code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回<code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h4 id="滑动窗口-1">滑动窗口</h4><p>如果当前窗口内的值小于target，那就right指针右移。</p><p>如果当前窗口内的值大于等于target，更新一下结果集，left指针左移去寻找长度更小的连续数组的可能性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; right &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; n &amp;&amp; sum &lt; target)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(right &lt; n)&#123;</span><br><span class="line">                    sum += nums[right];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= right &amp;&amp; sum &gt;= target)&#123;</span><br><span class="line">                ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><ahref="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3.无重复字符的最长子串</a></h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h4 id="滑动窗口哈希表">滑动窗口+哈希表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                map.put(s.charAt(right), right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//left不能回退</span></span><br><span class="line">                left = Math.max(map.get(s.charAt(right)) + <span class="number">1</span>, left);</span><br><span class="line">                map.put(s.charAt(right), right);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串联所有单词的子串"><ahref="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30.串联所有单词的子串</a></h3><p>给定一个字符串 <code>s</code> 和一个字符串数组<code>words</code><strong>。</strong> <code>words</code> 中所有字符串<strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含<code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么<code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>，<code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code>都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何<code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以<strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。</span><br><span class="line">子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class="line">子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br><span class="line">输出顺序无关紧要。返回 [9,0] 也是可以的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">输出：[]</span><br><span class="line">解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。</span><br><span class="line">s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。</span><br><span class="line">所以我们返回一个空数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span><br><span class="line">输出：[6,9,12]</span><br><span class="line">解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。</span><br><span class="line">子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。</span><br><span class="line">子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class="line">子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br></pre></td></tr></table></figure><h4 id="滑动窗口哈希表-1">滑动窗口+哈希表</h4><p>这题关键在于，滑动窗口的起点不固定，这里起点的情况跟单词长度有关。</p><p>为什么要定这样的起点？</p><p>因为我想在窗口滑动的过程中，滑动幅度为单词长度，那这样的话，下面这种情况：</p><figure><img src="leetcode滑动窗口题目专项训练/image-20230908102648532.png"alt="image-20230908102648532" /><figcaption aria-hidden="true">image-20230908102648532</figcaption></figure><p>如果从头滑动，势必会落下结果。</p><p>所以需要多位置启动，滑动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">//单词划分s，因为这题滑动窗口的起点不固定，起点有wordLen种情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordLen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + num * wordLen &gt; slen)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="comment">//初始化窗口长度为num * wordlen,哈希表统计窗口的单词</span></span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num; j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(i + j * wordLen, i + (j + <span class="number">1</span>) * wordLen);</span><br><span class="line">                <span class="comment">//统计单词出现次数</span></span><br><span class="line">                map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//与words这个哈希表对比，看s中截取的单词是否和words对应</span></span><br><span class="line">            <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">                map.put(word, map.getOrDefault(word, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果窗口内单词和words里单词匹对了，从哈希表删除</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(word) == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口开始滑动,滑动速度为一个单词的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i; start &lt;= slen - num*wordLen; start += wordLen)&#123;</span><br><span class="line">                <span class="comment">//剪枝操作</span></span><br><span class="line">                <span class="keyword">if</span>(start != i)&#123;<span class="comment">//跨过第一个单词后就开始滑</span></span><br><span class="line">                    <span class="comment">//右边单词滑进来</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(start + (num - <span class="number">1</span>)*wordLen, start + num* wordLen);</span><br><span class="line">                    map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(map.get(word) == <span class="number">0</span>)&#123;</span><br><span class="line">                        map.remove(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//左边单词滑走,因为跨了一个单词，减去一个wordlen即可</span></span><br><span class="line">                    word = s.substring(start - wordLen, start);</span><br><span class="line">                    map.put(word, map.getOrDefault(word, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(map.get(word) == <span class="number">0</span>)&#123;</span><br><span class="line">                        map.remove(word);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(map.isEmpty())&#123;</span><br><span class="line">                    res.add(start);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小覆盖子串"><ahref="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回<code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果<code>s</code> 中不存在涵盖 <code>t</code>所有字符的子串，则返回空字符串 <code>""</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code>中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code>中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><h4 id="滑动窗口哈希表-2">滑动窗口+哈希表</h4><p>字典表</p><p>还有字典字段标识needCnt：t的字符已经在滑动窗口内出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sl</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tl</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="comment">//哈希表</span></span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">needCnt</span> <span class="operator">=</span> tl;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//记录结果字符的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; sl)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(need[c] &gt; <span class="number">0</span>)&#123;<span class="comment">//说明这个字符还需要，总需要字符数--</span></span><br><span class="line">                needCnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//全局哈希表更新</span></span><br><span class="line">            need[c]--;</span><br><span class="line">            <span class="keyword">if</span>(needCnt == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; (need[s.charAt(left)] &lt; <span class="number">0</span>))&#123;</span><br><span class="line">                    need[s.charAt(left++)] ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//条件得加上，后面的字符串可能还会有满足条件的，会改变start</span></span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">                    size = Math.min(size, right - left + <span class="number">1</span>);</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//左指针扰动，触发右指针的移动</span></span><br><span class="line">                need[s.charAt(left)]++;</span><br><span class="line">                left++;</span><br><span class="line">                needCnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//未满足条件的时候右指针一直走</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size == Integer.MAX_VALUE? <span class="string">&quot;&quot;</span> : s.substring(start, start + size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;滑动窗口算法&quot;&gt;滑动窗口算法&lt;/h2&gt;
&lt;p&gt;基本概念：&lt;/p&gt;
&lt;p&gt;滑动窗口基于双指针的思想，两个指针指向的元素区间，构成一个窗口。&lt;/p&gt;
&lt;p&gt;种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定大小，如本题&lt;/li&gt;
&lt;li&gt;可变大小&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="滑动窗口" scheme="https://vlsmhd.github.io/categories/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode图题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/14/leetcode%E5%9B%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/14/leetcode%E5%9B%BE%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-14T04:38:02.219Z</published>
    <updated>2023-10-04T01:32:23.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其它类型">其它类型</h1><h2 id="中等">中等</h2><h3 id="钥匙和房间"><ahref="https://leetcode.cn/problems/keys-and-rooms/">841.钥匙和房间</a></h3><p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到<code>n - 1</code> 编号。最初，除 <code>0</code>号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p><p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p><p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入<code>i</code> 号房间可以获得的钥匙集合。如果能进入<strong>所有</strong> 房间返回 <code>true</code>，否则返回<code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：rooms = [[1],[2],[3],[]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure><h4 id="算法分析">算法分析</h4><h5 id="dfs-递归">DFS + 递归</h5><p>我们从第0号房间开始递归，每拿到一把钥匙，就去这个钥匙对应的房间，这就是D的精髓。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rooms.size();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第0号房间开始遍历</span></span><br><span class="line">        dfs(rooms, visited, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">boolean</span> visit: visited)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="type">boolean</span>[] visited, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[key])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; keys = rooms.get(key);</span><br><span class="line">        visited[key] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k : keys)&#123;</span><br><span class="line">            dfs(rooms, visited, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="被围绕的区域"><ahref="https://leetcode.cn/problems/surrounded-regions/">130.被围绕的区域</a></h3><h4 id="dfs">DFS</h4><p>从边缘开始遍历，与边缘相连接的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//与边缘O连接的区域更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="comment">//第一列</span></span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//最后一列</span></span><br><span class="line">            dfs(board,  i, c-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">//最后一行</span></span><br><span class="line">            dfs(board, r-<span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c) || grid[r][c] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把遍历过的O变成A</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新规划路线"><ahref="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">1466.重新规划路线</a></h3><p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code>编号，其间共有 <code>n-1</code>条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p><p>路线用 <code>connections</code> 表示，其中<code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到<code>b</code> 的一条有向路线。</p><p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0。请你帮助重新规划路线方向，使每个城市都可以访问城市 0。返回需要变更方向的最小路线数。</p><p>题目数据 <strong>保证</strong>每个城市在重新规划路线方向后都能到达城市 0 。</p><h4 id="建图深搜dfs">建图+深搜DFS</h4><p>题目得出的结论：</p><ol type="1"><li>路线网形成一颗树：图是有路线连通的。</li><li>要求最少规划方案，运用贪心策略，把部分有向边反向一下，就能实现目的。</li><li>采用DFS或者BFS必须的元素：visited</li></ol><p>小技巧：</p><p>反向路径在邻接表存负边值，这样从0正向推进的时候，只要&gt;0就说明路径是从0正向推进的，需要反转这条路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minReorder</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = buildGraph(n, connections);</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dfs(visited, graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> idx)</span>&#123;</span><br><span class="line">        visited[idx] = <span class="literal">true</span>;</span><br><span class="line">        List&lt;Integer&gt; list = graph.get(idx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> neighbor : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[Math.abs(neighbor)])&#123;</span><br><span class="line">                <span class="keyword">if</span>(neighbor &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(visited, graph, Math.abs(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建正向图——邻接表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">buildGraph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span>&#123;</span><br><span class="line">        <span class="comment">// 用邻接表表示有向图</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化每个节点的邻居列表</span></span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] connection : connections)&#123;</span><br><span class="line">            <span class="comment">//正向路径</span></span><br><span class="line">            graph.get(connection[<span class="number">0</span>]).add(connection[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//反向路径</span></span><br><span class="line">            graph.get(connection[<span class="number">1</span>]).add(-connection[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除法求值">**<ahref="https://leetcode.cn/problems/evaluate-division/">399.除法求值</a></h3><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组<code>values</code> 作为已知条件，其中<code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code>共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或<code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中<code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code>个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code>的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong>。如果存在某个无法确定的答案，则用 <code>-1.0</code>替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用<code>-1.0</code> 替代这个答案。</p><p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为0 的情况，且不存在任何矛盾的结果。</p><p><strong>注意：</strong>未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = 2.0, b / c = 3.0</span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br><span class="line">注意：x 是未定义的 =&gt; -1.0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= equations.length &lt;= 20</code></li><li><code>equations[i].length == 2</code></li><li><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></li><li><code>values.length == equations.length</code></li><li><code>0.0 &lt; values[i] &lt;= 20.0</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></li><li><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</li></ul><h4 id="建图-dfs">建图 + DFS</h4><p>如何建图：</p><figure><img src="leetcode图题目专项训练/image-20230903084528732.png"alt="image-20230903084528732" /><figcaption aria-hidden="true">image-20230903084528732</figcaption></figure><p>边的权值 = 起始边/终止边的值。</p><p>如图：边是可以出现反向的情况。</p><p>有向边虽然是a -&gt; b，但是b -&gt; a也成立，结果就是0.5</p><p>用Java的Map建图：</p><p>Map&lt; 分子顶点，&lt;分母顶点， 计算结果&gt;&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashmap建图</span></span><br><span class="line"><span class="comment">//初始化Graph(以HashMap形式),一个顶点可能有多个边，所以用list</span></span><br><span class="line">Map&lt;String, List&lt;Cell&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>), s2 = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//正向边 a-&gt;b</span></span><br><span class="line">    graph.computeIfAbsent(s1, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Cell</span>(s2, values[i]));</span><br><span class="line">    <span class="comment">//反向边 b -&gt; a</span></span><br><span class="line">    graph.computeIfAbsent(s2, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Cell</span>(s1, <span class="number">1.0</span> / values[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="comment">//存分母</span></span><br><span class="line">    String str;</span><br><span class="line">    <span class="comment">//存边权值（计算结果）</span></span><br><span class="line">    <span class="type">double</span> div;</span><br><span class="line"></span><br><span class="line">    Cell(String str, <span class="type">double</span> div) &#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">        <span class="built_in">this</span>.div = div;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果集构建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建答案result数组以及访问过的HashSet: visited</span></span><br><span class="line"><span class="type">double</span>[] res = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line"><span class="comment">//首先将答案中所有答案值置为-1.0，出现(x / x)情况可以直接不用修改</span></span><br><span class="line">Arrays.fill(res, -<span class="number">1.0</span>);</span><br><span class="line"> <span class="comment">//对于每个query中的值调用dfs函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">    dfs(queries.get(i).get(<span class="number">0</span>), queries.get(i).get(<span class="number">1</span>), <span class="number">1.0</span>, graph, res, i, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>DFS函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//src: 当前位置; dst: 答案节点; </span></span><br><span class="line"><span class="comment">//cur: 当前计算值; </span></span><br><span class="line"><span class="comment">//graph: 之前建的图; </span></span><br><span class="line"><span class="comment">//res: 答案array; </span></span><br><span class="line"><span class="comment">//index: 当前遍历到第几个query; </span></span><br><span class="line"><span class="comment">//visited: 查重Set ———————————防止出现环</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String src, String dst, <span class="type">double</span> cur, Map&lt;String, List&lt;Cell&gt;&gt; graph, <span class="type">double</span>[] res, <span class="type">int</span> index, Set&lt;String&gt; visited)</span> &#123;</span><br><span class="line">      <span class="comment">//base case: 在visited中加入当前位置信息；如果加不了代表已经访问过，直接返回</span></span><br><span class="line">      <span class="keyword">if</span>(!visited.add(src)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果当前位置src = 答案节点dst，并且此节点在graph中(避免x/x的情况)，用当前计算值cur来填充答案res[index] </span></span><br><span class="line">      <span class="keyword">if</span>(src.equals(dst) &amp;&amp; graph.containsKey(src)) &#123;</span><br><span class="line">          res[index] = cur;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对于邻居节点，调用dfs函数</span></span><br><span class="line">      <span class="keyword">for</span>(Cell nei : graph.getOrDefault(src, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">          dfs(nei.str, dst, cur * nei.div, graph, res, index, visited);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="克隆图"><a href="https://leetcode.cn/problems/clone-graph/">133.克隆图</a></h3><p>给你无向 <strong><ahref="https://baike.baidu.com/item/连通图/6460995?fr=aladdin">连通</a></strong>图中一个节点的引用，请你返回该图的 <ahref="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>）和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（<code>val = 1</code>），第二个节点值为2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong>是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将<strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode图题目专项训练/133_clone_graph_question.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><img src="leetcode图题目专项训练/graph.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure><img src="leetcode图题目专项训练/graph-1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><h4 id="dfs-递归-1">DFS +递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//哈希表记录已经遍历过的结点</span></span><br><span class="line">    <span class="comment">//key:旧结点  value: 新结点</span></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        map.put(node, clone);</span><br><span class="line">        <span class="keyword">for</span>(Node neighbor : node.neighbors)&#123;</span><br><span class="line">            clone.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截取评论的一句话：</p><blockquote><p>课本上总说deep copy和shallowcopy，似懂非懂的，不觉得这东西有什么用。慢慢地，发现deepcopy背后隐藏的逻辑其实是一种对象图（ObjectGraph）的遍历行为——这东西广泛出现在各语言的垃圾回收、序列化机制里。内存里各个对象存储空间中放置的引用域/指针就好像有向图里一条边，你沿着它去到达内存中的每个角落、去到当前对象所有的关联对象。题设里的<code>neibours</code>就像一道开胃菜，它可以是其他collection、甚至object，学会这个deepcopy，你也就学会了GC里的可达性分析、你也就学会了如何把RAM中的数据固化到硬盘里。</p></blockquote><h1 id="深度优先搜索">深度优先搜索</h1><h2 id="岛屿问题">岛屿问题</h2><p>岛屿问题也是经典的<strong>网格问题</strong>，网格遍历相当于<strong>四叉树遍历</strong></p><p>DFS模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r row 行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c col 列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(&lt;T&gt;[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//防止重复遍历</span></span><br><span class="line">    <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(&lt;T&gt;[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿数量"><ahref="https://leetcode.cn/problems/number-of-islands/">200.岛屿数量</a></h3><p>给你一个由 <code>'1'</code>（陆地）和<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h4 id="dfs-循环遍历">DFS + 循环遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找岛屿入口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历过的岛屿，设置为2</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先搜索">广度优先搜索</h1><p>优先宽度遍历。</p><p>代码实现必备要素：</p><ul><li>迭代模式</li><li>辅助队列</li><li>visited表（可以以另一种形式，只要保证知道某个元素被访问过即可）</li></ul><h2 id="网格模型题目">网格模型题目</h2><h3 id="网格模型总结">网格模型总结</h3><p>基本上都是上下左右四个方向遍历，重点在于对队列的使用，队列可存二元组、三元组这样，灵活取舍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">BFS</span><span class="params">(<span class="type">char</span>[][] graph, ...)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果题目给了初始地点，就加入队列</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line"><span class="comment">//offer后的一些处理</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="comment">//对于二维网格，x、y坐标必不可少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> poll[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> poll[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//其它参数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来往四个方向遍历</span></span><br><span class="line">            <span class="comment">//上</span></span><br><span class="line">            <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ...)&#123;<span class="comment">//在某个格子内，向上走只是x坐标-1，判断一下x坐标是否出界即可，下面同理</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">        ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下</span></span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">1</span> &lt; m &amp;&amp; ...)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">        ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ...)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; n &amp;&amp; ...)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;  n元组  &#125;);</span><br><span class="line">                <span class="comment">//offer后的一些处理</span></span><br><span class="line">        ...</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//满足结果集的条件</span></span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                res.add();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="腐烂的橘子"><ahref="https://leetcode.cn/problems/rotting-oranges/">994.腐烂的橘子</a></h3><p>在给定的 <code>m x n</code> 网格 <code>grid</code>中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong>的新鲜橘子都会腐烂。</p><p>返回<em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回<code>-1</code></em> 。</p><p><strong>示例 1：</strong></p><figure><img src="oranges.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h4 id="广搜方格遍历">广搜——方格遍历</h4><p>注意：</p><ol type="1"><li>广搜的队列初始化。</li><li>广搜队列存的值要有意义，比如本题中存下标，可以方便后续进行上下左右的遍历。</li><li>网格搜索会有上下左右四个方向。</li><li>注意本题，每一轮循环是每一分钟，每一分钟腐烂的橘子可以同时感染，所以需要嵌套循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//队列记录腐烂橘子下标</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化新鲜橘子数量，并初始化队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果有多个腐烂的橘子，是可以同时感染的，而不是一个一个感染，所以应该嵌套循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">int</span>[] xy = queue.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> xy[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> xy[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//上</span></span><br><span class="line">                <span class="keyword">if</span>(x-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x-<span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//别忘记感染</span></span><br><span class="line">                    grid[x-<span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x-<span class="number">1</span>,y&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//下</span></span><br><span class="line">                <span class="keyword">if</span>(x+<span class="number">1</span> &lt; m &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[x+<span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x+<span class="number">1</span>,y&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(y-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y-<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[x][y-<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y-<span class="number">1</span>&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(y+<span class="number">1</span> &lt; n &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[x][y+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y+<span class="number">1</span>&#125;);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷宫中离入口最近的出口"><ahref="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/">1926.迷宫中离入口最近的出口</a></h3><p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code>（<strong>下标从 0 开始</strong>），矩阵中有空格子（用 <code>'.'</code>表示）和墙（用 <code>'+'</code> 表示）。同时给你迷宫的入口<code>entrance</code> ，用<code>entrance = [entrancerow, entrancecol]</code>表示你一开始所在格子的行和列。</p><p>每一步操作，你可以往<strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者<strong>右</strong>移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离<code>entrance</code> <strong>最近</strong>的出口。<strong>出口</strong> 的含义是 <code>maze</code><strong>边界</strong> 上的<strong>空格子</strong>。<code>entrance</code> 格子<strong>不算</strong> 出口。</p><p>请你返回从 <code>entrance</code> 到最近出口的最短路径的<strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure><img src="nearest1-grid.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[&quot;+&quot;,&quot;+&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;,&quot;.&quot;]], entrance = [1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。</span><br><span class="line">一开始，你在入口格子 (1,2) 处。</span><br><span class="line">- 你可以往左移动 2 步到达 (1,0) 。</span><br><span class="line">- 你可以往上移动 1 步到达 (0,2) 。</span><br><span class="line">从入口处没法到达 (2,3) 。</span><br><span class="line">所以，最近的出口是 (0,2) ，距离为 1 步。</span><br></pre></td></tr></table></figure><h4 id="广搜-距离判断最短">广搜 + 距离判断最短</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nearestExit</span><span class="params">(<span class="type">char</span>[][] maze, <span class="type">int</span>[] entrance)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> maze.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> maze[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//第三个参数为到当前结点移动的距离</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entrance[<span class="number">0</span>], entrance[<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">//走过的格子变成墙</span></span><br><span class="line">        maze[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> poll[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> poll[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> poll[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上</span></span><br><span class="line">            <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; maze[x-<span class="number">1</span>][y] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x-<span class="number">1</span>, y, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x-<span class="number">1</span>][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下</span></span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">1</span> &lt; m &amp;&amp; maze[x+<span class="number">1</span>][y] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x+<span class="number">1</span>, y, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x+<span class="number">1</span>][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; maze[x][y-<span class="number">1</span>] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y-<span class="number">1</span>, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x][y-<span class="number">1</span>] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; n &amp;&amp; maze[x][y+<span class="number">1</span>] != <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y+<span class="number">1</span>, d + <span class="number">1</span>&#125;);</span><br><span class="line">                maze[x][y+<span class="number">1</span>] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((x == <span class="number">0</span> || x == m-<span class="number">1</span> || y == <span class="number">0</span> || y == n-<span class="number">1</span>) &amp;&amp; !(x == entrance[<span class="number">0</span>] &amp;&amp; y == entrance[<span class="number">1</span>]))&#123;</span><br><span class="line">                min = Math.min(min, d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE? -<span class="number">1</span>:min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊">特殊</h2><h3 id="蛇梯棋"><ahref="https://leetcode.cn/problems/snakes-and-ladders/">909.蛇梯棋</a></h3><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code>，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <ahref="https://baike.baidu.com/item/牛耕式转行书写法/17195786">转行交替方式</a>，<strong>从左下角开始</strong> （即，从 <code>board[n - 1][0]</code>开始）每一行交替方向。</p><p>玩家从棋盘上的方格 <code>1</code>（总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 <code>curr</code>开始出发，按下述要求前进：</p><ul><li><p>选定目标方格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure><p>，目标方格的编号符合范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[curr + 1, min(curr + 6, n2)]</span><br></pre></td></tr></table></figure><p>。</p><ul><li>该选择模拟了掷 <strong>六面体骰子</strong>的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li></ul></li><li><p>传送玩家：如果目标方格 <code>next</code>处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格<code>next</code> 。</p></li><li><p>当玩家到达编号 <code>n2</code> 的方格时，游戏结束。</p></li></ul><p><code>r</code> 行 <code>c</code>列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果<code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是<code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n2</code>的方格上没有蛇或梯子。</p><p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也<strong>不能</strong> 继续移动。</p><ul><li>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code>，第一次移动，玩家的目标方格是 <code>2</code>。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但<strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格<code>4</code> 。</li></ul><p>返回达到编号为 <code>n2</code>的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode图题目专项训练/snakes.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class="line">先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span><br><span class="line">然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span><br><span class="line">接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 </span><br><span class="line">最后决定移动到方格 36 , 游戏结束。 </span><br><span class="line">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[-1,-1],[-1,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h4 id="bfs寻路">BFS寻路</h4><p>核心寻路逻辑在于第二层for循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> poll[<span class="number">0</span>] + i;</span><br><span class="line">                <span class="comment">//边界判断</span></span><br><span class="line">                <span class="keyword">if</span>(next &gt; n * n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//蛇或梯子</span></span><br><span class="line">                <span class="type">int</span>[] rc = id2rc(next, n);</span><br><span class="line">                <span class="keyword">if</span>(board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    next = board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//到达终点</span></span><br><span class="line">                <span class="keyword">if</span>(next == n * n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> poll[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//蛇会回退，判断是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[next])&#123;</span><br><span class="line">                    vis[next] = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;next, poll[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据当前格子序号计算出所在的行列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> id, <span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (id - <span class="number">1</span>) / n;<span class="comment">//减一的目的：防止id是n的倍数的时候，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - t - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (id - <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">if</span>(t % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            c = n - c - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;r, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串转化类型">字符串转化类型</h2><p>题目描述：给定start和end字符串，要求从start -&gt;end，且必须经过中间数组<code>wordList</code>。</p><h3 id="最小基因变化"><ahref="https://leetcode.cn/problems/minimum-genetic-mutation/">433.最小基因变化</a></h3><p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是<code>'A'</code>、<code>'C'</code>、<code>'G'</code> 和 <code>'T'</code>之一。</p><p>假设我们需要调查从基因序列 <code>start</code> 变为 <code>end</code>所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p><ul><li>例如，<code>"AACCGGTT" --&gt; "AACCGGTA"</code>就是一次基因变化。</li></ul><p>另有一个基因库 <code>bank</code>记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库<code>bank</code> 中）</p><p>给你两个基因序列 <code>start</code> 和 <code>end</code>，以及一个基因库 <code>bank</code> ，请你找出并返回能够使<code>start</code> 变化为 <code>end</code>所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p><p>注意：起始基因序列 <code>start</code>默认是有效的，但是它并不一定会出现在基因库中。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h4 id="bfs-哈希表">BFS + 哈希表</h4><p>哈希表作用：对bank元素去重，顺带判断后续新加的结点是否在bank中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> &#123;</span><br><span class="line">        <span class="comment">//哈希表去重bank</span></span><br><span class="line">        HashSet&lt;String&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//visited表</span></span><br><span class="line">        HashSet&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : bank) &#123;</span><br><span class="line">            cnt.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cnt.contains(endGene))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(startGene.equals(endGene))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] keys = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(startGene);</span><br><span class="line">        vis.add(startGene);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//广搜BFS数组</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//遍历修改的每一种情况</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(keys[k] != poll.charAt(j))&#123;</span><br><span class="line">                            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(poll);</span><br><span class="line">                            sb.setCharAt(j,keys[k]);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                            <span class="comment">//下一个要遍历的字符</span></span><br><span class="line">                            <span class="keyword">if</span>(!vis.contains(next) &amp;&amp; cnt.contains(next))&#123;</span><br><span class="line">                                <span class="keyword">if</span>(next.equals(endGene))&#123;</span><br><span class="line">                                    <span class="keyword">return</span> ans;</span><br><span class="line">                                &#125;</span><br><span class="line">                                queue.offer(next);</span><br><span class="line">                                vis.add(next);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;<span class="comment">//这里queue即使有多个选项，for循环结束还是会选择一个存在cnt里的元素，因此只是经过了一轮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词接龙">*<ahref="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和<code>endWord</code> 的 <strong>转换序列</strong>是一个按下述规格形成的序列<code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p><ul><li>每一对相邻的单词只差一个字母。</li><li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在<code>wordList</code> 中。注意， <code>beginWord</code> 不需要在<code>wordList</code> 中。</li><li><code>sk == endWord</code></li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code>和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到<code>endWord</code> 的 <strong>最短转换序列</strong> 中的<strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回<code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><h4 id="优化建图bfs">优化建图+BFS</h4><h5 id="建图过程"><strong>建图过程</strong></h5><p><strong>状态推进思想：</strong>创建虚拟节点。对于单词hit，我们创建三个虚拟节点 *it、h*t、hi*，并让 hit向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的id 与这些虚拟节点对应的 id 相连即可。</p><p>示例一：</p><p><img src="leetcode图题目专项训练/2DCBB225E30E69B483ACE39B538FDC93.jpg" alt="2DCBB225E30E69B483ACE39B538FDC93" style="zoom:67%;" /></p><p>中间过程走了8步，根据建图规律，符合题意的话，就是 8 /2走了四步，算上开头的一步，正好五步</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(String word)</span>&#123;</span><br><span class="line">    addWord(word);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> wordId.get(word);</span><br><span class="line">    <span class="comment">//给当前单词每个可能的单词变换建立结点</span></span><br><span class="line">    <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> word.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//添加新字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> chars[i];</span><br><span class="line">        chars[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        addWord(newWord);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id1</span> <span class="operator">=</span> wordId.get(newWord);</span><br><span class="line">        edges.get(id).add(id1);</span><br><span class="line">        edges.get(id1).add(id);</span><br><span class="line">        chars[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!wordId.containsKey(word))&#123;</span><br><span class="line">        wordId.put(word, nodeNum++);</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    addEdge(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (String s : wordList) &#123;</span><br><span class="line">        addEdge(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!wordId.containsKey(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="bfs">BFS</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个顶点编号</span></span><br><span class="line">Map&lt;String, Integer&gt; wordId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//每个顶点包含的边</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    addEdge(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (String s : wordList) &#123;</span><br><span class="line">        addEdge(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!wordId.containsKey(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录到达每个结点的路径长度,同样也可作为vis</span></span><br><span class="line">    <span class="type">int</span>[] dit = <span class="keyword">new</span> <span class="title class_">int</span>[nodeNum];</span><br><span class="line">    Arrays.fill(dit, -<span class="number">1</span>);</span><br><span class="line">    dit[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">beginId</span> <span class="operator">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(beginId);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(x == endId)&#123;</span><br><span class="line">            <span class="keyword">return</span> dit[x] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer id : edges.get(x)) &#123;</span><br><span class="line">            <span class="comment">//去重，防止循环搜索</span></span><br><span class="line">            <span class="keyword">if</span>(dit[id] == -<span class="number">1</span>)&#123;</span><br><span class="line">                dit[id] = dit[x] + <span class="number">1</span>;</span><br><span class="line">                queue.offer(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集">并查集</h1><h3 id="省份数量"><ahref="https://leetcode.cn/problems/number-of-provinces/">547.省份数量</a></h3><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市<code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code>与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市<code>c</code> 间接相连。</p><p><strong>省份</strong>是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中<code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第<code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code>表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><p><strong>示例 1：</strong></p><figure><img src="graph1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h4 id="等级制-路径压缩优化并查集">等级制 + 路径压缩优化并查集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">DisjointSet</span> <span class="variable">disjointSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSet</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    disjointSet.union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> disjointSet.unionNums();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] s;</span><br><span class="line">    <span class="comment">//这里size采用等级制度，侵略完同级的其它结点，自身等级+1</span></span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">//领导数量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSet</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            s[i] = i;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s[x])&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[x] = find(s[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//找到各自的领导</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ldx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ldy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span>(ldx != ldy)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.size[ldx] &lt; <span class="built_in">this</span>.size[ldy])&#123;</span><br><span class="line">                s[ldx] = ldy;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.size[ldx] &gt; <span class="built_in">this</span>.size[ldy])&#123;</span><br><span class="line">                s[ldy] = ldx;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[ldy] = ldx;</span><br><span class="line">                <span class="built_in">this</span>.size[ldx]++;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unionNums</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序">拓扑排序</h1><h2 id="课程表问题">课程表问题</h2><h3 id="课程表"><ahref="https://leetcode.cn/problems/course-schedule/">207.课程表</a></h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为<code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组<code>prerequisites</code> 给出，其中<code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程<code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code>。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程<code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对<strong>互不相同</strong></li></ul><h4 id="拓扑排序邻接表-入度表-bfs">拓扑排序（邻接表 + 入度表 +BFS）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="comment">//构建入度表</span></span><br><span class="line">        <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//BFS的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建邻接表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表 and  邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            indegrees[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">            adjacency.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacency.get(poll)) &#123;</span><br><span class="line">                indegrees[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程表-ii"><ahref="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表II</a></h3><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code>到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code>，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程<code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><ul><li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code>，我们用一个匹配来表示：<code>[0,1]</code> 。</li></ul><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回<strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回<strong>一个空数组</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li></ul><h4 id="拓扑排序邻接表-入度表-bfs-1">拓扑排序（邻接表 + 入度表 +BFS）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//构建入度表</span></span><br><span class="line">        <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//BFS的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建邻接表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表 and  邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            indegrees[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">            adjacency.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始BFS</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            res[j] = poll;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacency.get(poll)) &#123;</span><br><span class="line">                indegrees[i]--;</span><br><span class="line">                <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>?res : <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;其它类型&quot;&gt;其它类型&lt;/h1&gt;
&lt;h2 id=&quot;中等&quot;&gt;中等&lt;/h2&gt;
&lt;h3 id=&quot;钥匙和房间&quot;&gt;&lt;a
href=&quot;https://leetcode.cn/problems/keys-and-rooms/&quot;&gt;841.
钥匙和房间&lt;/a&gt;&lt;/h3&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="图" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode回溯题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/11/leetcode%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/11/leetcode%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-11T01:54:50.848Z</published>
    <updated>2023-10-09T03:38:49.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法">回溯算法</h1><p>一种穷举算法，递归的副产物。。</p><p>递归往深了去，回来的途中进行的操作称为回溯。</p><p>一般解决穷举类问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>思路：</p><p>把组合问题抽象为一棵树，根节点就是当前要处理的某个问题.</p><ul><li>树的深度：代表着递归的深度</li><li>树的分支宽度：代表着要进行几轮递归<ul><li>一般横向的分支，在递归函数里用循环代替。</li></ul></li></ul><p>回溯模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(...)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(...)&#123;</span><br><span class="line">res...</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递进操作</span></span><br><span class="line">backTrack();</span><br><span class="line"><span class="comment">//回溯操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分类">分类</h1><h2 id="组合问题">组合问题</h2><p>去重逻辑：按照<strong>顺序遍历</strong>，可达到去重效果</p><h3 id="电话号码的字母组合"><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17.电话号码的字母组合</a></h3><h4 id="简单回溯">简单回溯</h4><p>关于全局变量的设置：</p><p>回溯的关键就在于回，对于全局变量而言有着更好操作的优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> digits.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String digits, <span class="type">int</span> idx)</span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(idx == digits.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">String</span>(path.toString()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> map.get(digits.charAt(idx));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//横向遍历，总共进行几轮递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            </span><br><span class="line">            path.append(c);</span><br><span class="line">            <span class="comment">//递归进入下一层</span></span><br><span class="line">            backTrack(digits, idx + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和-iii"><ahref="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和III</a></h3><p>找出所有相加之和为 <code>n</code> 的 <code>k</code>个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em>。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><h4 id="剪枝回溯">剪枝回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        backTrack(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        k:一个组合中需要的数字个数</span></span><br><span class="line"><span class="comment">        sum: n - 当前组合中的和    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> idx)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k &amp;&amp; sum == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里i = 1就会重复，path会重复，res里也会重复  i设置成idx，就集合中的元素顺序一直是从小到大，不会回退，就不会存在相同的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum -= i;</span><br><span class="line">            backTrack(sum, i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和"><ahref="https://leetcode.cn/problems/combination-sum/">39.组合总和</a></h3><p>给你一个 <strong>无重复元素</strong> 的整数数组<code>candidates</code> 和一个目标整数 <code>target</code> ，找出<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h4 id="回溯">回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backTrack(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> curSum, <span class="type">int</span> startIdx)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curSum == target)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止爆栈</span></span><br><span class="line">        <span class="keyword">if</span>(curSum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有序遍历达到去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            curSum += candidates[i];</span><br><span class="line">            backTrack(candidates, target, curSum, i);</span><br><span class="line">            curSum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="https://leetcode.cn/problems/combinations/">77.组合</a></h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围<code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h4 id="简单回溯-1">简单回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存每一个结果</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTrack(n, k, <span class="number">0</span>,<span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> idx, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == k)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTrack(n, k, idx + <span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            path.remove(i);<span class="comment">//回溯关键</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><figure><img src="leetcode回溯题目专项训练/image-20231007205700250.png"alt="image-20231007205700250" /><figcaption aria-hidden="true">image-20231007205700250</figcaption></figure><ul><li>linkedlist的尾部删比arrayList快。</li></ul><h4 id="剪枝回溯-1">剪枝回溯</h4><figure><imgsrc="leetcode回溯题目专项训练/3ddd55697423b5831cbbd42f4b901ebbade0daa456c651a70c758fe359d8a0d1-image.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>绿色部分：剪枝部分。</li></ul><p>搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与<code>path</code> 的长度相关。我们举几个例子分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索起点的上界 + 接下来要选择的元素个数 - 1 = n</span><br></pre></td></tr></table></figure><p>其中，接下来要选择的元素个数<code>= k - path.size()</code>，整理得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索起点的上界 = n - (k - path.size()) + 1</span><br></pre></td></tr></table></figure><p>复制评论的理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要组成大小为k的path，此时还需要k - path.size()个数，如果[i, n]这个区间内(有n - i + 1个数)不足这么多，则肯定没有结果，直接剪枝。因此剪枝条件为：n - i + 1 &lt; k - path.size()，推出来上界为i = n - k + path.size() + 1</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存每一个结果</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTrack(n, k, <span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> idx, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == k)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n-(k-path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTrack(n, k, idx + <span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><figure><img src="leetcode回溯题目专项训练/image-20231007212220207.png"alt="image-20231007212220207" /><figcaption aria-hidden="true">image-20231007212220207</figcaption></figure><h2 id="排列问题">排列问题</h2><p>关键在于去重，对于组合问题可以按照顺序遍历达到去重效果，但是排列问题数字之间顺序改变也是一种情况，导致如果不对单一数字去重就会出现一个数字在一个结果集内多次出现这种情况。</p><h3 id="全排列"><a href="https://leetcode.cn/problems/permutations/">46.全排列</a></h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h4 id="回溯-去重">回溯 + 去重</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//去重数组</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backTrack(nums,  used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                backTrack(nums, used);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n皇后问题">N皇后问题</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><h3 id="n-皇后"><a href="https://leetcode.cn/problems/n-queens/">51. N皇后</a></h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode回溯题目专项训练/queens.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure><h4 id="section"></h4><h3 id="n-皇后-ii"><ahref="https://leetcode.cn/problems/n-queens-ii/">52. N 皇后 II</a></h3><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n × n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong><strong>不同的解决方案的数量</strong>。</p><h4 id="哈希表-回溯">哈希表 + 回溯</h4><p>思路：枚举全部情况，利用回溯搜寻每一种情况。</p><p>关键：</p><ul><li>以行为单位，仅需判断列、斜对角线是否存在皇后。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//以行为单位放置皇后，只考虑列和对角线</span></span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> backtrack(n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//i代表列</span></span><br><span class="line">            <span class="keyword">if</span>(columns.contains(i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右下方向、左上方向规律</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">diagonal1</span> <span class="operator">=</span> row - i;</span><br><span class="line">            <span class="keyword">if</span>(diagonals1.contains(diagonal1))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右上方向、左下方向规律</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">diagonal2</span> <span class="operator">=</span> row + i;</span><br><span class="line">            <span class="keyword">if</span> (diagonals2.contains(diagonal2))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            columns.add(i);</span><br><span class="line">            diagonals1.add(diagonal1);</span><br><span class="line">            diagonals2.add(diagonal2);</span><br><span class="line">            count += backtrack(n,row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">            columns.remove(i);</span><br><span class="line">            diagonals1.remove(diagonal1);</span><br><span class="line">            diagonals2.remove(diagonal2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它问题">其它问题</h1><p>注意：一定要进行<strong>题意的条件判断</strong></p><h2 id="中等">中等</h2><h3 id="括号生成"><ahref="https://leetcode.cn/problems/generate-parentheses/">22.括号生成</a></h3><p>数字 <code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h4 id="回溯-1">回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(n,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), n,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left:左括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right:右括号数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, StringBuilder cur, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length() == n * <span class="number">2</span>)&#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            dfs(n,cur,left - <span class="number">1</span>, right);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            dfs(n,cur,left, right-<span class="number">1</span>);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词搜索"><ahref="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code>和一个字符串单词 <code>word</code> 。如果 <code>word</code>存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure><img src="leetcode回溯题目专项训练/word2.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><img src="leetcode回溯题目专项训练/word-1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure><img src="leetcode回溯题目专项训练/word3.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h4 id="dfs-回溯">dfs + 回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//防止代码冗余的关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] DIRECTIONS = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="type">char</span>[] wordChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        rows = board.length;</span><br><span class="line">        cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.board = board;</span><br><span class="line">        wordChar = word.toCharArray();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="comment">//题目中的条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != wordChar[idx])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果判断</span></span><br><span class="line">        <span class="keyword">if</span>(idx == wordChar.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : DIRECTIONS) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newI</span> <span class="operator">=</span> i + direction[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newJ</span> <span class="operator">=</span> j + direction[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(inArea(newI, newJ) &amp;&amp; !visited[newI][newJ])&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> dfs(newI, newJ, idx + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前路径不满足，回溯</span></span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span> newI, <span class="type">int</span> newJ)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newI &gt;= <span class="number">0</span> &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;=<span class="number">0</span> &amp;&amp; newJ &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯算法&quot;&gt;回溯算法&lt;/h1&gt;
&lt;p&gt;一种穷举算法，递归的副产物。。&lt;/p&gt;
&lt;p&gt;递归往深了去，回来的途中进行的操作称为回溯。&lt;/p&gt;
&lt;p&gt;一般解决穷举类问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合问题：N个数里面按一定规则找出k个数的集合&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="回溯" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode动态规划题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/07/leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/07/leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-07T03:51:57.210Z</published>
    <updated>2023-08-11T01:54:25.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动归规律总结">动归规律总结</h1><p>关键步骤：</p><ol type="1"><li>思考子问题的构造。</li><li>定义dp数组</li><li>初始化dp数组、处理边界问题</li><li>分析子问题状态转移，推导递推方程。（推导子问题有几种状态）</li></ol><h1 id="动归题目">动归题目</h1><h2 id="一维动归">一维动归</h2><h3 id="第-n-个泰波那契数"><ahref="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N个泰波那契数</a></h3><p>泰波那契序列 Tn 定义如下：</p><p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 +Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">T_3 = 0 + 1 + 1 = 2</span><br><span class="line">T_4 = 1 + 1 + 2 = 4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态规划">动态规划</h4><h5 id="on空间复杂度">O(n)空间复杂度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>] + dp[i-<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化内存o1">优化内存O(1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            d = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用最小花费爬楼梯"><ahref="https://leetcode.cn/problems/min-cost-climbing-stairs/">746.使用最小花费爬楼梯</a></h3><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code>是从楼梯第 <code>i</code>个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code>的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure><h4 id="动态规划-1">动态规划</h4><h5 id="普通版">普通版</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="comment">//dp[i]含义：到达第i个台阶要花费的最低花费</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//这里到达最终台阶要比cost的长度大1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递推公式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">1</span>] + cost[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + cost[i-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍"><ahref="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。<strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><h4 id="动态规划-2">动态规划</h4><h5 id="普通版-1">普通版</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i] 在当前屋子里能偷到的最大金额</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子问题k间屋子：  最后一间偷不偷</span></span><br><span class="line">            <span class="comment">//如果最后一间偷了，前一间不能头，dp[i-2]</span></span><br><span class="line">            <span class="comment">//如果最后一间不偷，偷前一间之前的，dp[i-1]</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="性能分析">性能分析：</h6><figure><img src="leetcode动态规划题目专项训练/image-20230808095152608.png"alt="image-20230808095152608" /><figcaption aria-hidden="true">image-20230808095152608</figcaption></figure><h3 id="多米诺和托米诺平铺"><ahref="https://leetcode.cn/problems/domino-and-tromino-tiling/">790.多米诺和托米诺平铺</a></h3><p>有两种形状的瓷砖：一种是 <code>2 x 1</code> 的多米诺形，另一种是形如"L" 的托米诺形。两种形状都可以旋转。</p><figure><img src="leetcode动态规划题目专项训练/lc-domino.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>给定整数 n ，返回可以平铺 <code>2 x n</code>的面板的方法的数量。<strong>返回对</strong> <code>109 + 7</code><strong>取模</strong> 的值。</p><p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p><p><strong>示例 1:</strong></p><figure><img src="leetcode动态规划题目专项训练/lc-domino1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: 五种不同的方法如上所示。</span><br></pre></td></tr></table></figure><h4 id="动态规划-3">动态规划</h4><h5 id="一维找规律">一维+找规律</h5><p>这里找规律的图借鉴：灵茶山大佬...</p><p>大佬不仅脑子好，画图水平也是一流。</p><figure><img src="leetcode动态规划题目专项训练/1668157188-nBzesC-790-5.png"alt="790-5.png" /><figcaption aria-hidden="true">790-5.png</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTilings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] * <span class="number">2</span> + dp[i-<span class="number">3</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维动归">二维动归</h2><h3 id="不同路径"><ahref="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><figure><img src="leetcode动态规划题目专项训练/robot_maze.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><h4 id="二维动归-1">二维动归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示到达(i,j)位置处有多少种路径</span></span><br><span class="line">        <span class="type">int</span>[][] dp  = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] =  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><ahref="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></h3><p>给定两个字符串 <code>text1</code> 和<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>。</p><p>一个字符串的 <strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但<code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong>是这两个字符串所共同拥有的子序列。</p><h4 id="二维动归-2">二维动归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="comment">//dp数组含义：两个字符串的子串长度各达到a、b的时候，最长公共子序列</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[a+<span class="number">1</span>][b+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= a; i++)&#123;</span><br><span class="line">            <span class="comment">//把字符在这边提前创建好，能优化效率两倍。</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">a1</span> <span class="operator">=</span> text1.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= b; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a1 == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//字符串相同，之前的状态+1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//延续之前的状态（最大）</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[a][b];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机含手续费"><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a></h3><p>给定一个整数数组 <code>prices</code>，其中<code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数<code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure><h4 id="二维动归-3">二维动归</h4><p>这里的第二维度只是为了方便状态判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0]表示：第i天，持有股票，能获得的最大利润</span><br><span class="line">dp[i][1]表示：第i天，不持有股票，能获得的最大利润</span><br></pre></td></tr></table></figure><p>还有注意手续费：一次交易只需付一次手续费，只要在买入或者卖出的时候交一次fee就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//第i天如果持有股票，能到达的最大利润     +   不持有，能到达的最大利润</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//今天持有，之前状态：之前一直持有、 昨天不持有，今天买入</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由于手续费只要交一次，可以选择买入时交，也可以卖出时交，如果两个式子都带-fee，最终结果会差个手续费</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//今天不持有，之前状态：  昨天不持有，  昨天持有，今天卖了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>], dp[n-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><ahref="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure><h4 id="二维动归-4">二维动归</h4><p>这里二维就像最长公共子序列那样。</p><p>来注意状态的转移：</p><p>遍历两边字符串的时候，当两个字符相同的时候，不做任何操作，由<code>dp[i-1][j-1]</code>推进</p><p>字符串不相同：</p><ul><li><code>dp[i][j-1]</code>：在表示word1前i个字符转换到word2前j-1个字符的距离，在此基础上，word2增加一个字符与word1的第i个字符相同，等价于word1删。</li><li><code>dp[i][j-1]</code>：...</li><li><code>dp[i-1][j-1]</code>：把两个字符修改成一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="comment">//空值判断</span></span><br><span class="line">        <span class="keyword">if</span>(a * b == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个字符的子串,下标分别到达a,b的时候，最小编辑距离</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[a+<span class="number">1</span>][b+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= a; i++)&#123;</span><br><span class="line">            <span class="comment">//当word2子串为空，编辑距离就是把word1的每个子串变成空串所经历的步骤数</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= b; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= a; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> word1.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= b; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c1 == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//当前字符相同，则都由前一个字符处转移过来</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]), dp[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[a][b];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动归规律总结&quot;&gt;动归规律总结&lt;/h1&gt;
&lt;p&gt;关键步骤：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;思考子问题的构造。&lt;/li&gt;
&lt;li&gt;定义dp数组&lt;/li&gt;
&lt;li&gt;初始化dp数组、处理边界问题&lt;/li&gt;
&lt;li&gt;分析子问题状态转移，推导递推方程</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="动态规划" scheme="https://vlsmhd.github.io/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode脑筋急转弯题目专项训练</title>
    <link href="https://vlsmhd.github.io/2023/08/07/leetcode%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/"/>
    <id>https://vlsmhd.github.io/2023/08/07/leetcode%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF%E9%A2%98%E7%9B%AE%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</id>
    <published>2023-08-07T03:44:18.504Z</published>
    <updated>2023-08-07T03:51:14.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断是否能拆分数组"><ahref="https://leetcode.cn/problems/check-if-it-is-possible-to-split-array/">2811.判断是否能拆分数组</a></h3><p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> 和一个整数<code>m</code> 。请你判断能否执行一系列操作，将数组拆分成 <code>n</code>个 <strong>非空</strong> 数组。</p><p>在每一步操作中，你可以选择一个 <strong>长度至少为 2</strong>的现有数组（之前步骤的结果） 并将其拆分成 <strong>2</strong>个子数组，而得到的 <strong>每个</strong> 子数组，<strong>至少</strong>需要满足以下条件之一：</p><ul><li><p>子数组的长度为 1 ，或者</p></li><li><p>子数组元素之和 <strong>大于或等于</strong> <code>m</code>。</p></li></ul><p>如果你可以将给定数组拆分成 <code>n</code> 个满足要求的数组，返回<code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>注意：</strong>子数组是数组中的一个连续非空元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2, 2, 1], m = 4</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">第 1 步，将数组 nums 拆分成 [2, 2] 和 [1] 。</span><br><span class="line">第 2 步，将数组 [2, 2] 拆分成 [2] 和 [2] 。</span><br><span class="line">因此，答案为 true 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2, 1, 3], m = 5 </span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">存在两种不同的拆分方法：</span><br><span class="line">第 1 种，将数组 nums 拆分成 [2, 1] 和 [3] 。</span><br><span class="line">第 2 种，将数组 nums 拆分成 [2] 和 [1, 3] 。</span><br><span class="line">然而，这两种方法都不满足题意。因此，答案为 false 。</span><br></pre></td></tr></table></figure><h4 id="算法分析">算法分析</h4><h5 id="剥洋葱">剥洋葱</h5><p>根据题意的理解，可以很容易知道</p><ul><li>对于长度低于3的数组，那就是满足，早晚能拆分成两个子数组长度为1</li><li>对于长度&gt;=3的数组，一层一层剥洋葱，每次删除首尾元素的其中一个，变成一个元素+一个子数组。最终我们一定能剥到只剩下两个元素的数组，只要这两个元素&gt;=m那么其它全部包含这两个元素的子数组都符合条件。</li></ul><p>于是问题转化为，找是否存在相邻两个元素之和&gt;=m</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canSplitArray</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有连续两个数字&gt;m就成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.get(i-<span class="number">1</span>) + nums.get(i) &gt;= m)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;判断是否能拆分数组&quot;&gt;&lt;a
href=&quot;https://leetcode.cn/problems/check-if-it-is-possible-to-split-array/&quot;&gt;2811.
判断是否能拆分数组&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个长度为 &lt;co</summary>
      
    
    
    
    <category term="leetcode" scheme="https://vlsmhd.github.io/categories/leetcode/"/>
    
    <category term="脑筋急转弯" scheme="https://vlsmhd.github.io/categories/leetcode/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>java面试整理</title>
    <link href="https://vlsmhd.github.io/2023/07/31/java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    <id>https://vlsmhd.github.io/2023/07/31/java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</id>
    <published>2023-07-31T09:19:49.814Z</published>
    <updated>2023-10-11T12:28:38.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法">基础语法</h1><h2 id="基本数据类型">基本数据类型</h2><h3 id="几种基本数据类型">几种基本数据类型</h3><p>8种数据类型：</p><ul><li>6 种数字类型：<ul><li>4种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p>它们所占空间：</p><p><a id="基本类型表"></a></p><table><colgroup><col style="width: 12%" /><col style="width: 5%" /><col style="width: 17%" /><col style="width: 9%" /><col style="width: 56%" /></colgroup><thead><tr class="header"><th style="text-align: left;">基本类型</th><th style="text-align: left;">位数</th><th style="text-align: left;">字节</th><th style="text-align: left;">默认值</th><th>取值范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>byte</code></td><td style="text-align: left;">8</td><td style="text-align: left;">1</td><td style="text-align: left;">0</td><td>-128 ~ 127</td></tr><tr class="even"><td style="text-align: left;"><code>short</code></td><td style="text-align: left;">16</td><td style="text-align: left;">2</td><td style="text-align: left;">0</td><td>-32768 ~ 32767</td></tr><tr class="odd"><td style="text-align: left;"><code>int</code></td><td style="text-align: left;">32</td><td style="text-align: left;">4</td><td style="text-align: left;">0</td><td>-2147483648 ~ 2147483647</td></tr><tr class="even"><td style="text-align: left;"><code>long</code></td><td style="text-align: left;">64</td><td style="text-align: left;">8</td><td style="text-align: left;">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr class="odd"><td style="text-align: left;"><code>char</code></td><td style="text-align: left;">16</td><td style="text-align: left;">2</td><td style="text-align: left;">'u0000'</td><td>0 ~ 65535</td></tr><tr class="even"><td style="text-align: left;"><code>float</code></td><td style="text-align: left;">32</td><td style="text-align: left;">4</td><td style="text-align: left;">0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr class="odd"><td style="text-align: left;"><code>double</code></td><td style="text-align: left;">64</td><td style="text-align: left;">8</td><td style="text-align: left;">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr class="even"><td style="text-align: left;"><code>boolean</code></td><td style="text-align: left;">1</td><td style="text-align: left;">依赖于JVM厂商</td><td style="text-align: left;">false</td><td>true、false</td></tr></tbody></table><p>跨平台特性也有一部分原因是因为java里基础类型大小不变的这一特性。</p><h3 id="基本类型和包装类型的区别">基本类型和包装类型的区别</h3><p><strong>用途：</strong></p><p>基本类型：常量的设定、局部变量</p><p>包装类型：包装类型可用于泛型、方法参数、对象属性等</p><p><strong>存储类型：</strong></p><p>基本类型：</p><ul><li>局部变量存放在 Java <strong>虚拟机栈</strong>中的局部变量表中。</li><li>成员变量放在堆中</li></ul><p>包装类型：属于对象类型，几乎都在堆里。</p><p><strong>占用空间：</strong></p><p>包装 &gt; 基本</p><p><strong>默认值：</strong></p><p>包装：不赋值就是null 基本：都有基础默认值，具体见<ahref="#基本类型表">上表</a>。</p><p><strong>比较方式：</strong></p><p>基本数据类型：==<code>比较的是值。</code></p><p>包装数据类型：<code>==</code>比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用<code>equals()</code> 方法。</p><h3 id="包装类型的缓存机制">包装类型的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code>这 4 种包装类默认创建了数值 <strong>[-128，127]</strong>的相应类型的缓存数据，<code>Character</code> 创建了数值在<strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回<code>True</code> or <code>False</code>。</p><p><strong><code>Character</code> 缓存源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Integer 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>值比较：对于Integer类型，处在[-128 ,127]之间的值可以用==比较，因为就在缓存中，可以复用。而以外的值会存放在堆中，不会复用已有的对象，推荐用equals比较。</li></ul><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><h3 id="自动装箱与拆箱">自动装箱与拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱   Integer.valueOf </span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱Integer.intValue</span></span><br></pre></td></tr></table></figure><p>解析字节码文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line">   LINENUMBER 8 L1</span><br><span class="line"></span><br><span class="line">   ALOAD 0</span><br><span class="line"></span><br><span class="line">   BIPUSH 10</span><br><span class="line"></span><br><span class="line">   INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">   PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">  L2</span><br><span class="line"></span><br><span class="line">   LINENUMBER 9 L2</span><br><span class="line"></span><br><span class="line">   ALOAD 0</span><br><span class="line"></span><br><span class="line">   ALOAD 0</span><br><span class="line"></span><br><span class="line">   GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">   INVOKEVIRTUAL java/lang/Integer.intValue (I)</span><br><span class="line"></span><br><span class="line">   PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line">   RETURN</span><br></pre></td></tr></table></figure><h3 id="浮点数运算的精度丢失">浮点数运算的精度丢失</h3><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p>解决：</p><p>使用BigDecimal</p><h2 id="变量">变量</h2><h3 id="成员变量与局部变量的区别">成员变量与局部变量的区别</h3><p><strong>语法：</strong></p><ul><li>成员变量：属于类、可被权限修饰符修饰</li><li>局部变量：代码块、方法区、方法参数等</li></ul><p><strong>存储方式：</strong></p><ul><li>成员变量：<ul><li>使用static修饰：属于类</li><li>不使用：属于对象，在堆里存储</li></ul></li><li>局部变量：<strong>存在于栈内存</strong>。</li></ul><p><strong>生命周期：</strong></p><ul><li>成员变量：和对象的生存时间一致</li><li>局部变量：方法调用开始 -&gt; 结束、或者代码块执行结束</li></ul><p><strong>默认值：</strong></p><ul><li>成员变量：按默认值赋值</li><li>局部变量：必须手动赋值</li></ul><h2 id="方法">方法</h2><h3id="静态方法为什么不能调用非静态成员">静态方法为什么不能调用非静态成员</h3><ol type="1"><li>静态方法属于类，在类加载的时候就分配栈内存，可以用类名直接访问，但是非静态成员是对象的信息范畴，必须创建对象实例才能访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h3 id="重载和重写有什么区别">重载和重写有什么区别</h3><p>重载就是同样的一个方法能够根据输入输出数据类型的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要<strong>覆盖</strong>父类方法</p><h4 id="重载">重载</h4><p>发生在同一个类中（或者父类和子类之间），<strong>方法名必须相同</strong>，<strong>参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符</strong>可以不同。</p><table><colgroup><col style="width: 12%" /><col style="width: 10%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th style="text-align: left;">区别点</th><th style="text-align: left;">重载方法</th><th style="text-align: left;">重写方法</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">发生范围</td><td style="text-align: left;">同一个类</td><td style="text-align: left;">子类</td></tr><tr class="even"><td style="text-align: left;">参数列表</td><td style="text-align: left;">必须修改</td><td style="text-align: left;">一定不能修改</td></tr><tr class="odd"><td style="text-align: left;">返回类型</td><td style="text-align: left;">可修改</td><tdstyle="text-align: left;">子类方法返回值类型应比父类方法返回值类型更小或相等（子类）</td></tr><tr class="even"><td style="text-align: left;">异常</td><td style="text-align: left;">可修改</td><tdstyle="text-align: left;">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr class="odd"><td style="text-align: left;">访问修饰符</td><td style="text-align: left;">可修改</td><tdstyle="text-align: left;">一定不能做更严格的限制（可以降低限制）</td></tr><tr class="even"><td style="text-align: left;">发生阶段</td><td style="text-align: left;">编译期</td><td style="text-align: left;">运行期</td></tr></tbody></table><h3id="深拷贝和浅拷贝区别什么是引用拷贝">深拷贝和浅拷贝区别，什么是引用拷贝？</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象<strong>内部的属性是引用类型</strong>的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象<strong>共用</strong>同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><figure><img src="shallow&amp;deep-copy.png"alt="浅拷贝、深拷贝、引用拷贝示意图" /><figcaptionaria-hidden="true">浅拷贝、深拷贝、引用拷贝示意图</figcaption></figure><h2 id="object">Object</h2><h3 id="常见方法">常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="和-equals-的区别">== 和 equals() 的区别</h3><p>==：</p><ul><li>基本类型：比值</li><li>引用类型：<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>对于 ==来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p>equals()：只能用来判断两个对象是否相等。</p><ul><li><strong>类没有重写<code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是<code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写<code>equals()</code>方法来比较两个对象中的<strong>属性</strong>是否相等；若它们的属性相等，则返回true(即，认为这两个对象相等)。</li></ul><h4 id="string的equals方法">String的equals()方法</h4><p>String类的equals()方法被重写过，会判断两个字符串的值是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashcode-方法">hashCode() 方法</h3><p>方法是本地方法，利用C / C++实现。</p><p>作用：为每个对象生成独特的编码，确定对象在哈希表中的索引，方便从哈希表中快速查找。</p><h4 id="hashcode存在的意义">hashCode存在的意义</h4><p>“<code>HashSet</code> 如何检查重复”</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code>会先计算对象的 <code>hashCode</code>值来判断对象加入的位置，同时也会与其他已经加入的对象的<code>hashCode</code> 值作比较，如果没有相符的<code>hashCode</code>，<code>HashSet</code>会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code>值的对象，这时会调用 <code>equals()</code> 方法来检查<code>hashCode</code>相等的对象是否真的相同。如果两者相同，<code>HashSet</code>就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了<code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>hashcode()其实也是用于判断两个对象是否相同，如果两个对象连哈希码都不相同，那就不用进行equals比较了。在一定程度上提高了集合审查元素的效率。</p><p><strong>为什么hashcode()过后还要equals比较？</strong></p><p>hashcode可能会发生哈希冲突，所以保险起见，满足这两个方法这两个对象就是相同的。</p><ul><li>hashcode() &amp;&amp; equals : 相同</li><li>!hashcode() ： 一定不相同。</li></ul><p>所以说，重写equals方法也必须重写hashcode方法，防止出现两个对象equal但是hashcode值不一样。</p><h2 id="string">String</h2><h3id="stringstringbufferstringbuilder-的区别">String、StringBuffer、StringBuilder的区别</h3><p>可变性：</p><ul><li>String不可变</li><li><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自<code>AbstractStringBuilder</code> 类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和<code>private</code> 关键字修饰，最关键的是这个<code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如<code>append</code> 方法。</li></ul><p>线程安全性：</p><ul><li><p><code>String</code>中的对象是不可变的，也就可以理解为常量，线程安全。</p></li><li><p><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p></li><li><p><code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。</p></li></ul><p>性能：</p><p>StringBuilder &gt; StringBuffer</p><ol type="1"><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用<code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用<code>StringBuffer</code></li></ol><h3 id="string-为什么是不可变的">String 为什么是不可变的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>final修饰内部的char数组，即使这个char引用指针能变，但这个成员变量是私有的，不会暴露给外界。</li><li><code>String</code> 类被 <code>final</code>修饰导致其不能被继承，进而避免了子类破坏 <code>String</code>不可变。</li></ol><h3 id="字符串拼接用-还是-stringbuilder">字符串拼接用“+” 还是StringBuilder</h3><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure><figure><img src="image-20220422161637929.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>字符串对象通过“+”的字符串拼接方式，实际上是通过<code>StringBuilder</code> 调用 <code>append()</code>方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个<code>String</code> 对象 。</p><h3 id="字符串常量池的作用">字符串常量池的作用</h3><p><strong>字符串常量池</strong> 是 JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h4 id="string-s1-new-stringabc这句话创建了几个字符串对象">String s1 =new String("abc");这句话创建了几个字符串对象</h4><ol type="1"><li>如果常量池没有"abc"这个字符串，会先创建"abc"实例，然后再创建s1引用对象</li><li>如果有，只创建s1引用对象</li></ol><h3 id="stringintern-方法有什么作用">String#intern 方法有什么作用</h3><p><code>String.intern()</code> 是一个native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池</strong>中</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用，不同于s3，这是往常量池找</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="string-类型的变量和常量做运算时发生了什么">String类型的变量和常量做“+”运算时发生了什么</h3><p>对于<strong>编译期可以确定值的字符串</strong>，也就是常量字符串（被写死的值），jvm 会将其存入字符串常量池。</p><p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化——常量折叠。</p><p><strong>常量折叠：</strong></p><p>对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成<code>String str3 = "string";</code> 。</p><p>引用类型的值无法在编译器确定，无法优化。</p><p>对象引用和“+”的字符串拼接方式，实际上是通过<code>StringBuilder</code> 调用 <code>append()</code>方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个<code>String</code> 对象 。</p><p>但是String引用类型被final修饰后，可以让编译器当成常量处理。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果，编译器在运行时才能知道其确切值的话，就无法对其优化。下面就不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常">异常</h2><p><strong>Java 异常类层次结构图</strong></p><figure><img src="image-20230802210612642.png" alt="image-20230802210612642" /><figcaption aria-hidden="true">image-20230802210612642</figcaption></figure><h3 id="exception-和-error-有什么区别">Exception 和 Error有什么区别</h3><ul><li><p>Exception：可catch捕获、可处理</p><ul><li><p>Checked Exception (受检查异常，必须处理)：没被catch通不过编译。</p><ul><li>(除了运行时异常以外，都是受查异常)</li></ul></li><li><p>Unchecked Exception (不受检查异常，可以不处理)：</p><ul><li><p>常见的非受查异常：</p><ul><li><p><code>NullPointerException</code>(空指针错误)</p></li><li><p><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</p></li><li><p><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</p></li><li><p><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</p></li><li><p><code>ClassCastException</code>（类型转换错误）</p></li><li><p><code>ArithmeticException</code>（算术错误）</p></li><li><p><code>SecurityException</code> （安全错误比如权限不够）</p></li><li><p><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</p></li></ul></li></ul></li></ul></li><li><p>error：不建议catch捕获，遇到线程终止处理。</p><ul><li>常见：OOM、SOF</li></ul></li></ul><h3 id="throwable-类常用方法有哪些">Throwable 类常用方法有哪些</h3><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>:返回异常对象的本地化信息。使用 <code>Throwable</code>的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与<code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印<code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="try-catch-finally-使用">try-catch-finally 使用</h3><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个<code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个<code>finally</code> 块。</li><li><code>catch</code>块：用于处理 try 捕获到的异常。</li><li><code>finally</code>块：无论是否捕获或处理异常，<code>finally</code>块里的语句<strong>都会被执行</strong>。<ul><li>当在 <code>try</code> 块或 <code>catch</code> 块中遇到<code>return</code> 语句时，<code>finally</code>语句块将在方法返回之前被执行。</li><li><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try语句和 finally 语句中都有 return 语句时，try 语句块中的 return语句会被忽略。这是因为 try 语句中的 return返回值会先被暂存在一个<strong>本地变量</strong>中，当执行到 finally语句中的 return 之后，会覆盖掉try块里的return返回值。</li></ul></li></ul><h3 id="finally-中的代码是否一定会执行">finally中的代码是否一定会执行</h3><p>基本上都是外界环境出问题所导致的：</p><ol type="1"><li>finally 之前虚拟机被终止运行的话，finally中的代码就不会被执行。</li><li>程序所在的线程死亡。</li><li>CPU关闭</li></ol><h3 id="使用-try-with-resources-代替try-catch-finally">使用<code>try-with-resources</code> 代替<code>try-catch-finally</code></h3><ul><li><strong>适用范围（资源的定义）：</strong> 任何实现<code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code>的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在<code>try-with-resources</code> 语句中，任何 catch 或 finally块在声明的资源关闭后运行。</li></ul><p>类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code>语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个资源需要关闭的时候，使用 <code>try-with-resources</code>实现，通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="异常使用有哪些需要注意的地方">异常使用有哪些需要注意的地方？</h3><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li></ul><h2 id="泛型">泛型</h2><h3 id="泛型的使用方式">泛型的使用方式</h3><h4 id="泛型类">泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口">泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法">泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line"> &#123;</span><br><span class="line">       <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">          System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>注意:<code>public static &lt; E &gt; void printArray( E[] inputArray )</code>一般被称为静态泛型方法;在 java中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的<code>&lt;E&gt;</code></p></blockquote><h3 id="项目中哪里用到了泛型">项目中哪里用到了泛型</h3><ul><li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数<code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code>用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的<code>sort</code>, <code>binarySearch</code> 方法）。</li></ul><h2 id="反射">反射</h2><h3 id="获取-class-对象的四种方式">获取 Class 对象的四种方式</h3><p>利用class类对象，将一个类的方法、变量信息提取出来。</p><ol type="1"><li><p>知道具体类情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过<code>Class.forName()</code>传入类的全路径获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>通过对象实例<code>instance.getClass()</code>获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure></li><li><p><strong>通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="反射基本操作">反射基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> &#123;</span><br><span class="line">           value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">   <span class="type">TargetObject</span> <span class="variable">targetObject</span> <span class="operator">=</span> (TargetObject) targetClass.newInstance();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取 TargetObject 类中定义的所有方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">       System.out.println(method.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">           String.class);</span><br><span class="line"></span><br><span class="line">   publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> targetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">   <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">   field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用 private 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">   <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">   privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   privateMethod.invoke(targetObject);</span><br></pre></td></tr></table></figure><p>​</p><h2 id="注解">注解</h2><p><code>Annotation</code> （注解） 是 Java5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的解析方法有哪几种">注解的解析方法有哪几种</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code>注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring框架的<code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h3 id="spi">SPI</h3><p>SPI 即 Service Provider Interface，字面意思就是：“服务提供者的接口”。我的理解是：自己能做的东西，做明白的东西外包</p><p>与API的区别：</p><figure><img src="1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="序列化和反序列化">序列化和反序列化</h2><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>序列化属于OSI七层模型的应用层。</p><p><strong>对某些字段不进行序列化：</strong></p><p>使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code>关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被<code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code>修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰<code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有<code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h2 id="语法糖">语法糖</h2><p>方便程序员开发程序而设计的一种特殊语法——语法糖。</p><p>主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for循环、try-with-resources 语法、lambda 表达式等。</p><p>JVM 其实并不能识别语法糖，Java语法糖要想被正确执行，需要先通过编译器进行<strong>解糖</strong>，编译阶段变成可识别的语法。</p><h1 id="集合">集合</h1><p>集合框架族：</p><figure><img src="java-collection-hierarchy.png" alt="Java 集合框架概览" /><figcaption aria-hidden="true">Java 集合框架概览</figcaption></figure><h2 id="list">List</h2><h3 id="arraylist">ArrayList</h3><h4 id="特性">特性</h4><ul><li>arrayList基于动态数组<ul><li>创建不用指定大小</li><li>动态扩容</li></ul></li><li>arrayList有丰富API</li><li>arrayList只能存储对象类型，不能存储基础类型。</li><li>arrayList可以存储空值。</li></ul><h4 id="各类操作的效率">各类操作的效率</h4><p>插入：</p><ul><li>头插：后面元素需要往后移动，复杂度O(n)</li><li>尾插：O(1)</li><li>中间插：随机位置的话，O(n/2) -&gt; O(n)</li><li>扩容：O(n)</li></ul><p>删除：</p><ul><li>头删：涉及移动元素，后面的元素移动到前面。O(n)</li><li>尾删：O(1)</li><li>中间删：O(n/2) -&gt; O(n)</li></ul><h4 id="源码分析">源码分析</h4><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>List&lt;E&gt;</code>：</li><li><code>RandomAccess</code>：标志接口，支持快速随机访问</li><li><code>Cloneable</code>：可进行深拷贝、浅拷贝</li><li><code>Serializable</code></li></ul><p>类图：</p><figure><img src="arraylist-class-diagram.png" alt="ArrayList 类图" /><figcaption aria-hidden="true">ArrayList 类图</figcaption></figure><h5 id="扩容机制">扩容机制</h5><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果创建的时候未指定大小，默认给一个空数组不占空间，然后真正用到的时候，比如添加第一个元素，会扩容到10</li></ul><p>add方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>ensureCapacityInternal()</code>方法，获取最小需求量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>判断是否需要扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>添加第一个元素，开始创建大小为10的数组</li><li>添加元素到第10个</li><li>add第11个元素，先执行<code>ensureCapacityInternal()</code>方法，，得知最小需求量已经为11，然后调用<code>ensureExplicitCapacity</code>方法判断是否需要扩容，发现11&gt; 原本的数量10，所以需要扩容。</li></ul><p>实际扩容方法<code>grow()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">     <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">     <span class="comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">         newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">     <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if判断成立，newCapacity = minCapacity(为 10)。但是第二个 if判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入<code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 returntrue,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 returntrue,size 增为 11。</li><li>以此类推······</li></ul><p><code>hugeCapacity()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linkedlist">LinkedList</h3><h4 id="特性-1">特性</h4><ul><li>底层双向链表。</li><li>每个元素存储额外的字段占用空间</li><li>头尾插入删除效率很高</li></ul><h4 id="各类操作的效率-1">各类操作的效率</h4><ul><li>头插头删、尾插尾删：O(1)</li><li>指定位置插入：O(n/2) -&gt; O(n)</li></ul><h3 id="linkedlist与arraylist区别">LinkedList与ArrayList区别</h3><p><strong>线程安全</strong></p><p>两者都不安全。</p><p><strong>内存</strong></p><ul><li>ArrayList空间浪费在扩容后预留的空间。</li><li>LinkedList空间浪费在每个结点的额外存储指针所占有的空间</li></ul><p><strong>快速随机访问</strong></p><p>快速随机访问就是通过元素的序号快速获取元素对象，如<code>get(int index)</code>方法</p><ul><li>LinkedList底层不是数组，不支持根据索引快速查找，所以随机访问的性能不高</li><li>ArrayList支持。</li></ul><p><strong>插入删除的位置是否受容器内部元素位置的影响</strong></p><ul><li>ArrayList：尾插无所谓，但是其它情况都是O(N)</li><li>LinkedList：头尾插都无所谓，中间插O(N)</li></ul><p><strong>底层数据结构</strong></p><p><code>ArrayList</code> 底层使用的是 <strong><code>Object</code>数组</strong>；</p><p><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong>数据结构</p><h2 id="queue">Queue</h2><p><code>Queue</code>是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循<strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据<strong>因为容量问题而导致操作失败后处理方式的不同</strong>可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr class="header"><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr class="odd"><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr class="even"><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr class="odd"><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口,增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr class="header"><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr class="odd"><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr class="even"><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr class="odd"><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr class="even"><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr class="odd"><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr class="even"><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p><code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code>等其他方法，可用于模拟栈.</p><h4 id="arraydeque-与-linkedlist-的区别">ArrayDeque 与 LinkedList的区别</h4><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而<code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但<code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程,不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code>不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>arrayDeque性能高一点。</p><h2 id="map">Map</h2><h3 id="hashmap-和-hashtable-的区别">HashMap 和 Hashtable 的区别</h3><p><strong>线程安全：</strong></p><ul><li>hashmap线程不安全</li><li>hashtable整个表加锁</li></ul><p><strong>效率</strong>：</p><ul><li>hashmap正常</li><li>hashtable阳慢，建议不用</li></ul><p><strong>null key的支持：</strong></p><ul><li>hashmap支持单个null key，值的null可以有多个</li><li>hashtable不支持</li></ul><p><strong>默认容量、扩容：</strong></p><ul><li>hashmap默认容量：16 hashtable默认容量：11</li><li>给定容量：hashmap将给定的容量转化为最近的2的n次方幂，hashtable直接用。</li><li>hashmap达到负载因子扩容为原来的二倍，hashtable扩容为2n+1</li></ul><p>底层数据结构：</p><ul><li>hashmap：数组、链表|红黑树</li><li>hashtable：数组</li></ul><h3 id="hashmap-的长度为什么是-2-的幂次方">HashMap 的长度为什么是 2的幂次方</h3><p>假设hashmap的长度是n，假设元素的hash值已经计算就是hash。</p><p>如果要确定数据要存放的具体位置，通过<code>hash % n</code>这个公式计算。但是二进制计算的效率要比%效率高得多，那么把这个公式转换一下，就是<code>hash &amp; (n - 1)</code>。</p><p>但是有个大前提：<strong>数组长度必须是2的n次方。</strong>所以...</p><h3 id="hashmap-和-hashset-区别">HashMap 和 HashSet 区别</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p><table><colgroup><col style="width: 38%" /><col style="width: 61%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><code>HashMap</code></th><th style="text-align: center;"><code>HashSet</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">实现了 <code>Map</code> 接口</td><td style="text-align: center;">实现 <code>Set</code> 接口</td></tr><tr class="even"><td style="text-align: center;">存储键值对</td><td style="text-align: center;">仅存储对象</td></tr><tr class="odd"><td style="text-align: center;">调用 <code>put()</code>向 map中添加元素</td><td style="text-align: center;">调用 <code>add()</code>方法向<code>Set</code> 中添加元素</td></tr><tr class="even"><td style="text-align: center;"><code>HashMap</code> 使用键（Key）计算<code>hashcode</code></td><td style="text-align: center;"><code>HashSet</code> 使用成员对象来计算<code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code>可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h3 id="hashset-如何检查重复">HashSet 如何检查重复</h3><p>添加对象的时候，hashset先计算对象的hashcode，通过hashcode判断对象要添加的位置在哪里，假如这个位置有空，添加进去，否则添加失败。（hashcode+ equals）</p><p>add源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treemap-相比于hashmap特性">TreeMap 相比于HashMap特性</h3><figure><img src="treemap_hierarchy.png" alt="TreeMap 继承关系图" /><figcaption aria-hidden="true">TreeMap 继承关系图</figcaption></figure><p>实现 <code>NavigableMap</code> 接口有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code>有了对集合中的元素<strong>根据键排序</strong>的能力</p><h3 id="hashmap-常见的遍历方式">HashMap 常见的遍历方式</h3><ol type="1"><li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用迭代器（Iterator）KeySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 For Each EntrySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 For Each KeySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Lambda 表达式的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.foreach((key,value) -&gt; &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用 Streams API 单线程的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用 Streams API 多线程的方式进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="hashmap底层源码实现">HashMap底层源码实现</h3><p>数据结构：</p><ul><li>1.8之前是数组+链表</li><li>1.8之后是数组+链表|红黑树<ul><li>树化：</li><li>退化：</li><li>树化阈值：</li><li>扩容</li></ul></li></ul><p>扰动函数：哈希表为了减少冲突所定义的一种函数。</p><p>hashcode()是每个对象都有的获取本身独一无二标识码的一种方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法">构造方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     </span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>putMapEntries方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 未初始化，s为m的实际元素个数，ft=s/loadFactor =&gt; s=ft*loadFactor, 跟我们前面提到的</span></span><br><span class="line"><span class="comment">             * 阈值=容量*负载因子 是不是很像，是的，ft指的是要添加s个元素所需的最小的容量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所</span></span><br><span class="line"><span class="comment">             * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。</span></span><br><span class="line"><span class="comment">             * 注意这里不是初始化阈值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put方法">put方法</h4><p><img src="put.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法">get方法</h4><p>大致流程：</p><ol type="1"><li>根据key，调用hash方法算出hash码，然后通过哈希码hash调用内部方法getNode。</li><li>通过哈希码算出这个元素应在的位置，去这个位置寻找。</li><li>假如这个位置的第一个结点和要找的结点不一致：<ol type="1"><li>可能在链表结点中</li><li>可能在树节点中</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resize扩容">resize扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span></span><br><span class="line">    <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 只有一个节点，直接计算元素新的位置即可</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span></span><br><span class="line">                    <span class="comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并发编程">并发编程</h1><h2 id="基础概念">基础概念</h2><h3 id="进程">进程</h3><p>系统运行程序的基本单位。针对一个个的应用程序。</p><p>java应用程序进程：main()函数为入口，启动main函数就是启动了一个jvm进程。</p><h3 id="线程">线程</h3><p>粒度：比进程小，进程包含多个线程。</p><p>资源共享：共享进程的堆、方法区信息。每个线程有独立的程序计数器、虚拟机栈、本地方法栈。</p><h3 id="程序计数器为什么线程私有">程序计数器为什么线程私有</h3><p>一串代码可能交由多个线程去执行，然后单个CPU在运行多个线程的时候，是以时间片轮转调度来执行的，所以会有不间断的线程上下文的切换，那么每个线程必须要记录自己的代码执行到哪一行了，不然下次上下文切换到自己，自己不知道代码运行到哪就尴尬了。</p><p>主要就是为了：<strong>线程切换后能能恢复到正确的执行位置。</strong></p><h3id="虚拟机栈和本地方法栈为什么是私有的">虚拟机栈和本地方法栈为什么是私有的</h3><p><strong>虚拟机栈：</strong> 每个 Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java 虚拟机栈中入栈和出栈的过程。</p><p><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>保证方法中的局部变量不会被其它执行的线程所影响。</p><h3 id="并发和并行">并发和并行</h3><p>并发：多个作业在同一时间段工作。单CPU运行多线程。</p><p>并行：多个作业在同一时刻工作。例如：多CPU运行多线程</p><h3 id="同步和异步">同步和异步</h3><p><strong>同步</strong>：发出一个调用之后，在没有得到结果之前，该调用就不可以返回，一直等待。</p><p><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</p><ul><li>提高系统响应能力的手段</li></ul><h3 id="线程的生命周期和状态">线程的生命周期和状态</h3><p>在java中，线程有如下6个状态：</p><ul><li>new：初始状态</li><li>runnable：运行态</li><li>waiting：等待状态</li><li>time_waiting：超时等待<ul><li>等待一段时间后，自动唤醒</li></ul></li><li>blocking：阻塞状态<ul><li>线程在没有锁的情况下，争抢被加锁的资源</li></ul></li><li>terminated：终止状态</li></ul><figure><img src="640-1692712751157-1.png" alt="Java 线程状态变迁图" /><figcaption aria-hidden="true">Java 线程状态变迁图</figcaption></figure><h4 id="java中线程状态与操作系统对比">java中线程状态与操作系统对比</h4><p>操作系统包含：</p><ul><li>ready：就绪态</li><li>running：运行态</li></ul><p>java仅有runnable态，原因：</p><p>现如今的时分系统，时间片精确到10~20ms，切换很快，没必要为每个线程再多拓展这两个状态，直接用runnable即可。</p><h3 id="线程的上下文切换">线程的上下文切换</h3><p>保留当前线程的上下文信息，留到下次切换该线程时做准备，并加载下一个要执行的线程的上下文信息。</p><h3 id="死锁">死锁</h3><p>定义：多个线程同时阻塞，都在等待某个资源被释放。线程被无限期终止，程序不可能停止。</p><figure><img src="2019-4死锁1.png" alt="线程死锁示意图" /><figcaption aria-hidden="true">线程死锁示意图</figcaption></figure><p>模拟死锁代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁的四大条件：</p><ol type="1"><li>互斥：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持：线程请求其他资源阻塞的时候，会持有当前的资源不放</li><li>不剥夺：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h4 id="避免死锁预防死锁">避免死锁、预防死锁</h4><p>预防：</p><ol type="1"><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠<strong>按序申请资源</strong>来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>避免死锁：</p><p>资源分配的时候，对资源分配进行计算评估（银行家算法），使其进入安全状态。</p><blockquote><p><strong>安全状态</strong>指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称<code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote><p>修改线程2的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="sleep方法与wait方法">sleep()方法与wait()方法</h3><p>两者都会暂停线程的运行，但是有很大区别：</p><table><colgroup><col style="width: 19%" /><col style="width: 30%" /><col style="width: 49%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">sleep</th><th style="text-align: center;">wait</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">是否会释放锁</td><td style="text-align: center;">否</td><td style="text-align: center;">是</td></tr><tr class="even"><td style="text-align: left;">方法类型</td><td style="text-align: center;"><code>Thread</code>类的静态本地方法</td><td style="text-align: center;"><code>Object</code> 类的本地方法</td></tr><tr class="odd"><td style="text-align: left;">休眠后，如何唤醒</td><td style="text-align: center;">自动唤醒</td><td style="text-align: center;">botify()唤醒，或者使用wart(longtimeout)</td></tr><tr class="even"><td style="text-align: left;">用途</td><td style="text-align: center;">线程休眠</td><td style="text-align: center;">线程间交互通信</td></tr></tbody></table><h4 id="为什么wait是object方法">为什么wait是object方法：</h4><p>wait是想让线程释放某个对象锁，从而进入阻塞等锁状态，那我们操作目标应该是对象，而非线程本身。</p><h2 id="jmmjava-内存模型详解">JMM（Java 内存模型）详解</h2><h3 id="cpu缓存">CPU缓存</h3><p><strong>缓存：</strong>解决某两个或两个以上系统之间速度不匹配的问题。</p><ul><li><strong>CPU 缓存则是为了解决 CPU处理速度和内存处理速度不对等的问题。</strong></li><li><strong>内存就是外存的告诉缓存。</strong></li></ul><p>多核CPU下的缓存图：</p><figure><img src="cpu-cache-protocol.png" alt="缓存一致性协议" /><figcaption aria-hidden="true">缓存一致性协议</figcaption></figure><p>CPU cache的工作方式：先复制一份数据到 CPUcache中，然后需要时去里面取，进行运算，运算结束再写回到 MainMemory中。</p><p>但是会出现缓存不一致的问题。</p><p><strong>缓存不一致</strong>:通过协议规范解决</p><h3 id="指令重排序">指令重排序</h3><p>定义：系统在执行代码的过程中，会更改一些语句间的执行顺序（不会按照你写的顺序来），前提是保证语义正确的情况下。</p><ul><li><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>，所以在多线程下，指令重排序可能会导致一些问题。</li></ul><p>种类：</p><ul><li>编译器优化重排：JVM、JIT等，</li><li>指令并行重排：指令级并行技术(Instruction-LevelParallelism，ILP)来将多条指令重叠执行</li></ul><p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt;内存系统重排</strong>，最后变成操作系统可执行的指令序列。</p><h3 id="jmm">JMM</h3><h4 id="jmm出现的意义">JMM出现的意义</h4><ol type="1"><li>java跨平台，那就要有自己的一套内存模型。因为不同的操作系统之间的内存结构都不一样。</li><li>java定义的一组并发编程的规范，里面有许多规范原则，简化了并发编程的开发。</li></ol><h4 id="jmm-如何抽象线程和主内存之间的关系">JMM如何抽象线程和主内存之间的关系</h4><p>类似CPU缓存。</p><figure><img src="jmm.png" alt="JMM(Java 内存模型)" /><figcaption aria-hidden="true">JMM(Java 内存模型)</figcaption></figure><p>把变量从主存中拷贝到自己的本地内存中，称为共享变量副本。</p><p>并发问题：当一个线程正在修改这个副本，还没有往主存中同步，但是另一个线程要取这个变量，但是它看到的变量还是自己刚刚拷贝的旧副本。</p><p><strong>主内存：</strong>所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</p><p><strong>本地内存：</strong>每个线程都有一个私有的本地内存来存储共享变量的<strong>副本</strong>，</p><ul><li>隔离性：每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。</li></ul><p>线程间的通信步骤：</p><ol type="1"><li>线程 1把本地内存中修改过的共享变量副本的值<strong>同步</strong>到主内存中去。</li><li>线程 2 到主存中读取对应的共享变量的值。</li></ol><p><strong>主内存与工作内存（线程间私有内存）之间的通信协议</strong>：</p><p>同步操作：</p><ul><li><strong>锁定（lock）</strong>:作用于主内存中的变量，将他标记为一个线程独享变量。</li><li><strong>解锁（unlock）</strong>:作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load 动作使用。</li><li><strong>load(载入)</strong>：把 read操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li><strong>use(使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write 操作使用。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把 store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>规则：</p><ul><li>不允许一个线程无原因地（没有发生过任何 assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或assign）的变量，换句话说就是对一个变量实施 use 和 store操作之前，必须先执行过了 assign 和 load 操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的unlock 操作，变量才会被解锁。</li><li>如果对一个变量执行 lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load 或 assign 操作初始化变量的值。</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li></ul><h4 id="设计思想">设计思想</h4><figure><img src="image-20220731155332375.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="happens-before-原则">happens-before 原则</h3><p>第一个逻辑时钟算法。</p><p>作用： happens-before原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p><p>设计思想：</p><ul><li>对于编译器、处理器的约束尽可能少，只要不改变程序执行结果，随便指令怎么排序都行</li><li>拒绝一切影响程序运行结果的指令重排序。</li></ul><p>运用：</p><p>1 happens-before 2</p><ul><li>表层含义：1的操作要在2的操作前执行。</li><li>实际深层含义：1的操作要对2的操作是可见的。</li></ul><h4 id="常见规则">常见规则</h4><ul><li><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作happens-before 于书写在后面的操作；</li><li><strong>解锁规则</strong>：解锁 happens-before 于加锁；</li><li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile变量的写操作的结果对于发生于其后的任何操作都是可见的。</li><li><strong>传递规则</strong>：如果 A happens-before B，且 Bhappens-before C，那么 A happens-before C；</li><li><strong>线程启动规则</strong>：Thread 对象的<code>start()</code>方法 happens-before 于此线程的每一个动作</li></ul><h3 id="并发三特性">并发三特性</h3><h4 id="原子性">原子性</h4><p>n次操作，要么同时执行，执行过程中不受任何干扰导致其终止，不然要么都不执行。</p><p>实现：</p><ul><li>悲观锁</li></ul><h4 id="可见性">可见性</h4><p>当一个线程对共享变量修改，其它线程可见。</p><p>实现：</p><ul><li>volatile：将变量声明为 <code>volatile</code> ，这就指示JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li><li>悲观锁</li><li>乐观锁</li></ul><h4 id="有序性">有序性</h4><p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p><p>volatile禁止指令重排序。</p><h2 id="重要的锁">重要的锁</h2><h3 id="volatile关键字">volatile关键字</h3><h4 id="如何保证可见性">如何保证可见性</h4><p>将变量声明为 <strong><code>volatile</code></strong> ，这就指示JVM，这个变量是共享且不稳定的，每次使用它都<strong>到主存中进行读取</strong>。</p><h4 id="为什么禁止指令重排序">为什么禁止指令重排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance = new Singleton();</code>这段代码其实是分为三步执行：</p><ol type="1"><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>这三个指令如果发生重排，假如变成1 -&gt; 3 -&gt; 2的顺序。</p><p>例如，线程 T1 执行了 1 和 3，此时 T2 调用<code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code>不为空，因此返回 <code>uniqueInstance</code>，但此时<code>uniqueInstance</code> 还未被初始化。</p><h3 id="悲观锁">悲观锁</h3><p>悲观为主，做好最坏的打算，因此共享变量加锁每次只让一个线程操作。</p><p>缺点：高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><p>应用：写多读少</p><h3 id="乐观锁">乐观锁</h3><p>缺陷：冲突频繁发生（写占比非常多的情况），会频繁失败和重试，会非常影响性能，导致CPU 飙升。</p><p>应用：读多写少</p><h4 id="版本号机制实现">版本号机制实现</h4><p>在数据表中加上一个数据版本号 <code>version</code>字段，表示数据被修改的次数。当数据被修改时，<code>version</code>值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取<code>version</code> 值.</p><p>在<strong>提交更新</strong>时，若刚才读取到的 version值为当前数据库中的 <code>version</code>值相等时才更新，否则重试更新操作，直到更新成功。</p><h4 id="cas实现">CAS实现</h4><p>全称Compare and Swap ， 底层是一个原子指令。</p><p>思想：用预期值和要更新的变量值比较，相等才会更新。</p><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>案例：线程 A 要修改变量 i 的值为 6，i 原值为 1（V =1，E=1，N=6，假设不存在 ABA 问题）。</p><ol type="1"><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6。</li><li>i 与 1进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS操作失败。</li></ol><h4 id="乐观锁存在的问题">乐观锁存在的问题</h4><h5 id="aba问题">ABA问题</h5><p>如果一个变量初始是A值，准备修改他的时候还是A值，但是这中间可能发生其它修改，这是未知的。</p><h5 id="循环等待时长久">循环等待时长久</h5><p>CAS经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause指令有两个作用：</p><ol type="1"><li>可以延迟流水线执行指令，使 CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲而引起 CPU流水线被清空，从而提高 CPU 的执行效率。</li></ol><h3 id="公平锁和非公平锁">公平锁和非公平锁</h3><ul><li>公平锁：锁被释放之后，先申请的线程先得到锁。<ul><li>性能不好，但公平</li></ul></li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是<strong>随机</strong>或者按照其他优先级排序的。<ul><li>性能好，但会出现饿死</li></ul></li></ul><h3 id="可中断锁和不可中断锁">可中断锁和不可中断锁</h3><ul><li><strong>可中断锁</strong>：<strong>获取锁的过程</strong>中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。<code>synchronized</code> 就属于是不可中断锁。</li></ul><h3 id="共享锁和独占锁">共享锁和独占锁</h3><ul><li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li><li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li></ul><h3 id="自旋锁">自旋锁</h3><h3 id="synchronized-锁">synchronized 锁</h3><h4 id="使用">使用</h4><p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p><p>给当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例的锁</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、修饰静态方法</strong> （锁当前类）</p><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得<strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code>方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态<code>synchronized</code> 方法，而线程 B需要调用这个实例对象所属类的静态 <code>synchronized</code>方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code>方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code>方法占用的锁是当前实例对象锁。</p><p><strong>3、修饰代码块</strong> （锁指定对象/类）</p><p>对括号里指定的对象/类加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得<strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="底层原理">底层原理</h4><p><code>synchronized</code> 同步语句块的实现使用的是<code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中<code>monitorenter</code>指令指向同步代码块的开始位置，<code>monitorexit</code>指令则指明同步代码块的结束位置。</p><figure><img src="synchronized-get-lock-code-block.png"alt="执行 monitorenter 获取锁" /><figcaption aria-hidden="true">执行 monitorenter 获取锁</figcaption></figure><p>锁计数器。</p><p>解锁：</p><figure><img src="synchronized-release-lock-block.png"alt="执行 monitorexit 释放锁" /><figcaption aria-hidden="true">执行 monitorexit 释放锁</figcaption></figure><h3 id="reentrantlock">ReentrantLock</h3><p>实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁</p><h3 id="reentrantreadwritelock">ReentrantReadWriteLock</h3><p>可重入的读写锁，实现了读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</p><p>两把锁：</p><ul><li>WriteLock：一个线程持有</li><li>ReadLock：多个线程持有</li></ul><p>适合<strong>读多写少</strong>的场景</p><p>能否同时拥有两把锁：</p><ul><li>拥有读锁的情况下，不能获得写锁：读锁不能升级为写锁</li><li>拥有写锁的情况下，不能获得读锁</li></ul><h2 id="threadlocal">ThreadLocal</h2><p>作用：保证每一个线程拥有自己独立的本地变量</p><h3 id="原理">原理</h3><p>俩容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上ThreadLocal就是对hashmap容器的一个封装。</p><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面得出结论，最终要存的变量，放在了<strong><code>ThreadLocalMap</code></strong>中，key就是<code>ThreadLocal</code>对象 ,value就是Object类对象。</p><p>抛开<code>ThreadLocal</code>，每个线程其实是有一个<code>ThreadLocalMap</code>，可以存多个ThreadLocal对象</p><figure><img src="threadlocal-data-structure.png" alt="ThreadLocal 数据结构" /><figcaption aria-hidden="true">ThreadLocal 数据结构</figcaption></figure><h3 id="内存泄露问题">内存泄露问题</h3><p>Entry是一个弱引用，如果 <code>ThreadLocal</code>没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value不会被清理掉。</p><p>这样就会出现许多key为null的Entry，占用空间。</p><p>解决：手动调用remove（）方法。</p><h2 id="线程池">线程池</h2><p>使用好处：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="创建线程池的方式">创建线程池的方式</h3><ol type="1"><li><p><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p></li><li><p><strong>通过 <code>Executor</code> 框架的工具类<code>Executors</code> 来创建。</strong></p></li></ol><h3 id="线程池参数">线程池参数</h3><p><strong><code>ThreadPoolExecutor</code> 3个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code></strong> ：核心线程数</li><li><strong><code>maximumPoolSize</code></strong> ：最大线程数</li><li><strong><code>workQueue</code></strong>：工作队列。新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p>其它参数：</p><p><strong><code>keepAliveTime</code></strong>：存活时间：线程池中的线程数量大于<code>corePoolSize</code>的时候，这部分线程如果没有要执行的任务，会等待这个keepAliveTime时间后销毁。属于救急线程</p><p><strong><code>unit</code></strong>： <code>keepAliveTime</code>参数的时间单位。</p><p><strong><code>threadFactory</code></strong> ：产生线程的工厂</p><p><strong><code>handler</code></strong> ：拒绝策略</p><p>工作原理：</p><figure><img src="image-20210831093204388.png" alt="image-20210831093204388" /><figcaption aria-hidden="true">image-20210831093204388</figcaption></figure><p>流程：</p><figure><img src="图解线程池实现原理.png" alt="图解线程池实现原理" /><figcaption aria-hidden="true">图解线程池实现原理</figcaption></figure><h4 id="四种拒绝策略">四种拒绝策略</h4><ol type="1"><li><strong>抛异常</strong>java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li><strong>由调用者执行任务</strong>java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li><strong>丢弃任务</strong>java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li><strong>丢弃最早排队任务</strong>java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol><h3 id="常用的阻塞队列">常用的阻塞队列</h3><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的<code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code>和 <code>SingleThreadExector</code>。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code>。<code>SynchronousQueue</code>没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code>的最大线程数是 <code>Integer.MAX_VALUE</code>，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code>和 <code>SingleThreadScheduledExecutor</code>。<code>DelayedWorkQueue</code>的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code>添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达<code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h2 id="aqs">AQS</h2><h3 id="aqs底层">AQS底层</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code>，翻译过来的意思就是抽象队列同步器</p><h4 id="思想">思想</h4><p>看共享资源状态：</p><ul><li>共享资源空闲：将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>被请求的共享资源被占用：需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagerstenlocks） 实现的。</li></ul><p>共享资源方式：</p><ul><li><code>Exclusive</code>：独占，如<code>ReentrantLock</code></li><li><code>Share</code>：共享，如<code>Semaphore</code>/<code>CountDownLatch</code></li></ul><h5 id="clh队列">CLH队列</h5><p>数据结构：双向链表</p><figure><img src="CLH.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>对于资源state的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取资源的过程：</p><p>以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为0，表示未锁定状态。</p><p>A线程调用lock()，state+1，获取锁成功。其它线程发现这个state !=0，获取锁失败，A释放锁的时候，state--，变为0。</p><p><strong>可重入：</strong>A在执行业务的时候，想重复获取锁，state会继续++，同样释放的时候也是由内而外释放锁。</p><h5 id="自定义同步器">自定义同步器</h5><p>基于模板方法模式</p><ol type="1"><li>使用者继承 <code>AbstractQueuedSynchronizer</code>并重写指定的方法。</li><li>将 AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h2 id="同步工具类">同步工具类</h2><h3 id="semaphore信号量">Semaphore(信号量)</h3><p>可以控制多个访问同一资源的线程。</p><p><strong>使用：</strong></p><p>假设有 <code>N(N&gt;5)</code> 个线程来获取 <code>Semaphore</code>中的共享资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>只有这五个线程能访问到特定的资源。获取到共享资源的线程才能执行。</p><blockquote><p>如果资源只有一个，那就跟lock这种排它锁没区别。</p></blockquote><p><strong>模式</strong>：</p><ul><li>公平模式：调用 <code>acquire()</code>方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li>非公平模式：抢占式的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">  sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定是否公平</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用：</strong>单机限流。</p><h4 id="原理-1">原理</h4><p>AQS实现，将构造方法传来的permits，当做state的值。</p><figure><img src="image-20230908184053505.png" alt="image-20230908184053505" /><figcaption aria-hidden="true">image-20230908184053505</figcaption></figure><h3 id="countdownlatch-倒计时器">CountDownLatch （倒计时器）</h3><p><code>CountDownLatch</code> 允许 <code>count</code>个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p>一次性使用工具，使用完即销毁。</p><h4 id="原理-2">原理</h4><p>默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程调用 <code>countDown()</code>时，其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少<code>state</code>，state为0时，表示所有的线程都调用了<code>countDown</code> 方法，在 <code>CountDownLatch</code>上等待的线程就会被唤醒并继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放共享锁，AbstractQueuedSynchronizer 默认实现</span></span><br><span class="line"><span class="comment">// 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//释放共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      <span class="comment">//释放当前节点的后置等待节点</span></span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 state 进行递减，直到 state 变成 0；</span></span><br><span class="line"><span class="comment">// 只有 count 递减到 0 时，countDown 才会返回 true</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 自选检查 state 是否为 0</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果 state 已经是 0 了，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对 state 进行递减</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// CAS 操作更新 state 的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待（也可以叫做加锁）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有超时时间的等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取锁，获取成功则返回，失败则加入等待队列，挂起线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 尝试获得锁，获取成功则返回</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 获取失败加入等待队列，挂起线程</span></span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用">应用</h4><ol type="1"><li><p>某一线程在开始运行前等待 n 个线程执行完毕 : 将<code>CountDownLatch</code> 的计数器初始化为 n（<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在<code>CountDownLatch 上 await()</code>的线程就会被唤醒。一个典型应用场景就是<strong>启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</strong>。</p></li><li><p>多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是<strong>多个线程在某一时刻同时开始执行</strong>。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的<code>CountDownLatch</code> 对象，将其<strong>计数器初始化为 1</strong>（<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先<code>coundownlatch.await()</code>，当<strong>主线程调用</strong><code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p></li></ol><h2 id="atomic-原子类">Atomic 原子类</h2><h1 id="io">IO</h1><p>Input/Output，针对内存，数据输入到内存就叫输入，数据输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>:所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>:所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h2 id="基础">基础</h2><h3 id="字节流">字节流</h3><h4 id="字节输入流inputstream">字节输入流InputStream</h4><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）<strong>到内存</strong>中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p><p><code>InputStream</code> 常用方法：</p><ul><li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到255 之间。如果未读取任何字节，则代码返回 <code>-1</code>，表示文件结束。</li><li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组<code>b</code> 中。如果数组 <code>b</code>的长度为零，则不读取。如果没有可用字节读取，返回<code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于<code>b.length</code> ， 返回读取的字节数。这个方法等价于<code>read(b, 0, b.length)</code>。</li><li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code>方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>参数（要读取的最大字节数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字节,返回实际忽略的字节数。</li><li><code>available()</code>：返回输入流中可以读取的字节数。</li><li><code>close()</code>：关闭输入流释放相关的系统资源。</li></ul><p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p><ul><li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li><li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取<code>len</code> 个字节。</li><li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li></ul><p><code>FileInputStream</code>是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><p>配合 <code>BufferedInputStream</code>使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p><code>DataInputStream</code>用于读取指定类型数据，不能单独使用，必须结合其它流，比如<code>FileInputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure><p><code>ObjectInputStream</code> 用于从输入流中读取 Java对象（反序列化），<code>ObjectOutputStream</code>用于将对象写入到输出流(序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><h4 id="字节输出流outputstream">字节输出流OutputStream</h4><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是<strong>所有字节输出流的父类</strong>。</p><p><code>OutputStream</code> 常用方法：</p><ul><li><code>write(int b)</code>：将特定字节写入输出流。</li><li><code>write(byte b[ ])</code> : 将数组<code>b</code>写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li><li><code>write(byte[] b, int off, int len)</code> :在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code>参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>close()</code>：关闭输出流释放相关的系统资源。</li></ul><p><code>FileOutputStream</code>是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p><p>配合 <code>BufferedOutputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream)</span><br></pre></td></tr></table></figure><p><strong><code>DataOutputStream</code></strong>用于写入指定类型数据，不能单独使用，必须结合其它流，比如<code>FileOutputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="comment">// 输出任意数据类型</span></span><br><span class="line">dataOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">dataOutputStream.writeByte(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Guide哥&quot;</span>, <span class="string">&quot;JavaGuide作者&quot;</span>);</span><br><span class="line">output.writeObject(person);</span><br></pre></td></tr></table></figure><h3 id="字符流">字符流</h3><p>为什么会有字符流：</p><ul><li>如果不知道编码类型就很容易出现乱码问题。</li></ul><p>字符流默认采用的是 <code>Unicode</code>编码，我们可以通过构造方法自定义编码。</p><p><code>utf8</code> :英文占 1 字节，中文占 3字节，<code>unicode</code>：任何字符都占 2个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h4 id="reader字符输入流">Reader（字符输入流）</h4><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code>用于读取原始字节。</p><p><code>Reader</code> 常用方法：</p><ul><li><code>read()</code> : 从输入流读取一个字符。</li><li><code>read(char[] cbuf)</code> :从输入流中读取一些字符，并将它们存储到字符数组<code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code>。</li><li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code>方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>参数（要读取的最大字符数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字符,返回实际忽略的字符数。</li><li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li></ul><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类<code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于读取字符文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileReader</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);) &#123;</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fileReader.skip(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="section"></h3><h4 id="writer字符输出流">Writer（字符输出流）</h4><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><p><code>Writer</code> 常用方法：</p><ul><li><code>write(int c)</code> : 写入单个字符。</li><li><code>write(char[] cbuf)</code>：写入字符数组<code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li><li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code>方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>参数（要读取的最大字符数）。</li><li><code>write(String str)</code>：写入字符串，等价于<code>write(str, 0, str.length())</code> 。</li><li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code>方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>参数（要读取的最大字符数）。</li><li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>append(char c)</code>：将指定的字符附加到指定的<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li><li><code>close()</code>:关闭输出流释放相关的系统资源。</li></ul><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类<code>FileWriter</code>是基于该基础上的封装，可以直接将字符写入到文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符流转换为字节流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于写入字符到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileWriter</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    output.write(<span class="string">&quot;你好。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节缓冲流">字节缓冲流</h3><p>IO操作消耗性能的，缓冲流将数据加载至缓冲区，<strong>一次性读取/写入多个字节</strong>，从而避免频繁的IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了<strong>装饰器模式</strong>来增强<code>InputStream</code>和<code>OutputStream</code><strong>子类对象</strong>的功能。</p><p>通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强<code>FileInputStream</code> 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>字节流和字节缓冲流的性能差别： <code>write(int b)</code> 和<code>read()</code>这两个一次只读取一个字节的方法，由于字节缓冲流内部有缓冲区，因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少IO 次数，提高读取效率。</p><p>使用 <code>write(int b)</code> 和 <code>read()</code>方法，复制大文件性能对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用缓冲流复制PDF文件总耗时:15428 毫秒</span><br><span class="line">使用普通字节流复制PDF文件总耗时:2555062 毫秒</span><br></pre></td></tr></table></figure><p>调用 <code>read(byte b[])</code> 和<code>write(byte b[], int off, int len)</code>这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//每次写入4M的量</span></span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4id="bufferedinputstream字节缓冲输入流">BufferedInputStream（字节缓冲输入流）</h4><p><code>BufferedInputStream</code>从源头（通常是文件）读取数据（字节信息）到内存的过程中<strong>不会一个字节一个字节的读取</strong>，而是会先<strong>将读取到的字节存放在缓存区</strong>，并从内部缓冲区中单独读取字节。这样大幅减少了IO 次数，提高了读取效率。</p><p><code>BufferedInputStream</code>内部维护了一个缓冲区，这个<strong>缓冲区实际就是一个字节数组</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 缓冲区的默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 使用默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲区的大小默认为 <strong>8192</strong> 字节，也可以通过<code>BufferedInputStream(InputStream in, int size)</code>这个构造方法来指定缓冲区的大小。</p><h4id="bufferedoutputstream字节缓冲输出流">BufferedOutputStream（字节缓冲输出流）</h4><p><code>BufferedOutputStream</code>将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了IO 次数，提高了读取效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    bos.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于 <code>BufferedInputStream</code>，<code>BufferedOutputStream</code>内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong>字节。</p><h3 id="字符缓冲流">字符缓冲流</h3><p><code>BufferedReader</code> （字符缓冲输入流）和<code>BufferedWriter</code>（字符缓冲输出流）类似于<code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h3 id="打印流输出流的一种">打印流——输出流的一种</h3><p>sout原理：获取一个PrintStream对象，<code>print</code>方法实际调用的是<code>PrintStream</code> 对象的 <code>write</code>方法。<code>PrintStream</code> 属于字节打印流，与之对应的是<code>PrintWriter</code> （字符打印流）。</p><h3 id="随机访问流">随机访问流</h3><p>定义：随意跳转到文件的任意位置进行读写的<code>RandomAccessFile</code> 。</p><p>RandomAccessFile构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file, mode, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode, <span class="type">boolean</span> openAndDelete)</span>  <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">  <span class="comment">// 省略大部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定读写模式：</p><ul><li><code>r</code> : 只读模式。</li><li><code>rw</code>: 读写模式</li><li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code>同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li><li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code>同步更新对“文件的内容”的修改到外部存储设备。</li></ul><blockquote><p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p></blockquote><p><code>RandomAccessFile</code>中有一个<strong>文件指针</strong>用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过<code>RandomAccessFile</code> 的 <code>seek(long pos)</code>方法来设置文件指针的偏移量（距文件开头 <code>pos</code>个字节处）。如果想要获取文件指针当前的位置的话，可以使用<code>getFilePointer()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 指针当前偏移量为 6</span></span><br><span class="line">randomAccessFile.seek(<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 从偏移量 7 的位置开始往后写入字节数据</span></span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 指针当前偏移量为 0，回到起始位置</span></span><br><span class="line">randomAccessFile.seek(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br></pre></td></tr></table></figure><p>假设文件内容为：ABCDEFG，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br><span class="line">读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><br><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br></pre></td></tr></table></figure><p>写覆盖：</p><p><code>RandomAccessFile</code> 的 <code>write</code>方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>假设运行上面这段程序之前 <code>input.txt</code> 文件内容变为<code>ABCD</code> ，运行之后则变为 <code>HIJK</code> 。</p><p>断点续传：</p><p>上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件<strong>分片</strong>即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><h2 id="涉及设计模式">涉及设计模式</h2><h3 id="装饰器模式">装饰器模式</h3><p><strong>装饰器（Decorator）模式</strong>可以在不改变原有对象的情况下拓展其功能。</p><p>组合替代继承来扩展原始类的功能，一些继承关系比较复杂的场景（IO这一场景各种类的继承关系就比较复杂）更加实用。</p><p>装饰器的抽象装饰：<code>FilterInputStream</code>（对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心</p><ul><li>用于增强 <code>InputStream</code>和<code>OutputStream</code>子类对象的功能。</li></ul><p>具体装饰类：<code>BufferedInputStream</code>(字节缓冲输入流)、<code>DataInputStream</code>等等都是<code>FilterInputStream</code>的子类，<code>BufferedOutputStream</code>（字节缓冲输出流）、<code>DataOutputStream</code>等等都是<code>FilterOutputStream</code>的子类。</p><p>案例：通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强<code>FileInputStream</code> 的功</p><h3 id="适配器模式">适配器模式</h3><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>就是两个适配器(Adapter)，同时，它们两个也是<strong>字节流和字符流之间的桥梁</strong>。</p><p><code>InputStreamReader</code> 使用 <code>StreamDecoder</code>（流解码器）对字节进行解码，<strong>实现字节流到字符流的转换，</strong></p><p><code>OutputStreamWriter</code>使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换</p><p><code>InputStream</code> 和 <code>OutputStream</code>的子类是被适配者， <code>InputStreamReader</code> 和<code>OutputStreamWriter</code>是适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br></pre></td></tr></table></figure><p><code>java.io.InputStreamReader</code> 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line"><span class="comment">//用于解码的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 StreamDecoder 对象</span></span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamDecoder 对象做具体的读取工作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.io.OutputStreamWriter</code> 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="comment">// 用于编码的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamEncoder se;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取 StreamEncoder 对象</span></span><br><span class="line">            se = StreamEncoder.forOutputStreamWriter(out, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamEncoder 对象做具体的写入工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        se.write(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者模式">观察者模式</h3><p>NIO 中的文件目录监听服务使用到了观察者模式。</p><p>观察者：WatchService</p><p>被观察者：Watchable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Path</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Watchable</span> &#123;</span><br><span class="line">    WatchKey <span class="title function_">register</span><span class="params">(WatchService watcher,</span></span><br><span class="line"><span class="params">                      WatchEvent.Kind&lt;?&gt;[] events,</span></span><br><span class="line"><span class="params">                      WatchEvent.Modifier... modifiers)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WatchService</code> 用于监听文件目录的变化，同一个<code>WatchService</code> 对象能够监听多个文件目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 WatchService 对象</span></span><br><span class="line"><span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个被监控文件夹的 Path 类:</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;workingDirectory&quot;</span>);</span><br><span class="line"><span class="comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span></span><br><span class="line"><span class="type">WatchKey</span> <span class="variable">watchKey</span> <span class="operator">=</span> path.register(</span><br><span class="line">watchService, StandardWatchEventKinds...);</span><br></pre></td></tr></table></figure><p><code>Path</code> 类 <code>register</code> 方法的第二个参数<code>events</code>（需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。</p><p><code>WatchService</code> 内部是通过一个 daemonthread（守护线程）采用定期轮询的方式来检测文件的变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PollingWatchService</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractWatchService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutor;</span><br><span class="line"></span><br><span class="line">    PollingWatchService() &#123;</span><br><span class="line">        scheduledExecutor = Executors</span><br><span class="line">            .newSingleThreadScheduledExecutor(<span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                     <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                     t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                     <span class="keyword">return</span> t;</span><br><span class="line">                 &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enable</span><span class="params">(Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events, <span class="type">long</span> period)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 更新监听事件</span></span><br><span class="line">      <span class="built_in">this</span>.events = events;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启定期轮询</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; poll(); &#125;&#125;;</span><br><span class="line">      <span class="built_in">this</span>.poller = scheduledExecutor</span><br><span class="line">        .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="io模型">I/O模型</h2><h1 id="常用框架">常用框架</h1><h2 id="spring">Spring</h2><h3 id="spring模块">Spring模块</h3><figure><img src="20200831175708.png" alt="Spring5.x主要模块" /><figcaption aria-hidden="true">Spring5.x主要模块</figcaption></figure><figure><img src="20200902100038.png" alt="Spring 各个模块的依赖关系" /><figcaption aria-hidden="true">Spring 各个模块的依赖关系</figcaption></figure><h4 id="core-container">Core Container</h4><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC依赖注入功能的支持。Spring其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring各个模块的依赖关系图就可以看出来。</p><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（SpringExpression Language） SpEL 的支持，只依赖于 core模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id="aop">AOP</h4><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM添加代理（agent）的功能。 具体来讲，它为 Tomcat提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限.</li></ul><h4 id="data-accessintegration">Data Access/Integration</h4><ul><li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong>：提供对事务的支持。</li><li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM框架的支持。</li><li><strong>spring-oxm</strong>：提供一个抽象层支撑OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="spring-web">Spring Web</h4><ul><li><strong>spring-web</strong>：对 Web功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li><li><strong>spring-websocket</strong>：提供了对 WebSocket的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id="spring-test">Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转(IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito的问题比如无法模拟 final, static， private方法）等等常用的测试框架支持的都比较好。</p><h3 id="ioc">Ioc</h3><p><strong>IoC（Inversion ofControl:控制反转）</strong>：一种设计思想，就是我们把创建对象的控制权交给容器管理。</p><ul><li>控制：对象创建的行为，包括对象间的依赖关系，都交由spring容器来管理。</li><li>反转：交给外部环境</li></ul><p>本质：map集合。</p><h4 id="源码解析">源码解析</h4><p><a href="https://javadoop.com/post/spring-ioc">Spring IOC容器源码分析_Javadoop</a></p><h4 id="spring-bean">Spring Bean</h4><p>IoC 容器所管理的对象。</p><h5 id="类声明为bean的注解">类声明为bean的注解</h5><ul><li><code>@Component</code>：通用的注解，可标注任意类为<code>Spring</code> 组件。如果一个 <strong>Bean不知道属于哪个层</strong>，可以使用<code>@Component</code>注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC控制层，主要用于接受用户请求并调用 <code>Service</code>层返回数据给前端页面。</li></ul><h5 id="component-和-bean-的区别"><span class="citation"data-cites="Component">@Component</span> 和 <span class="citation"data-cites="Bean">@Bean</span> 的区别</h5><table><colgroup><col style="width: 6%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th></th><th><span class="citation" data-cites="Bean">@Bean</span></th><th><span class="citation" data-cites="Component">@Component</span></th></tr></thead><tbody><tr class="odd"><td>作用域</td><td>作用在方法上</td><td>作用在类上</td></tr><tr class="even"><td>含义</td><td>标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring这是某个类的实例，当我需要用它的时候还给我。</td><td><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring 容器中（我们可以使用 <code>@ComponentScan</code>注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean容器中）。</td></tr><tr class="odd"><td>自定义性</td><td>很强，通常外部导入的组件都用这个注解</td><td>一般用于配置类这种。</td></tr></tbody></table><h5 id="注入bean的注解">注入bean的注解</h5><table><thead><tr class="header"><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr class="odd"><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr class="even"><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr class="odd"><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code>和<code>@Resource</code>使用的比较多一些。</p><h5 id="autowired-和的区别"><code>@Autowired</code> 和``的区别</h5><table><colgroup><col style="width: 6%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th></th><th><span class="citation" data-cites="Autowired">@Autowired</span></th><th><span class="citation" data-cites="Resource">@Resource</span></th></tr></thead><tbody><tr class="odd"><td>提供者</td><td>spring</td><td>java</td></tr><tr class="even"><td>注入方式</td><td>默认byType，可以通过 <code>@Qualifier</code>注解来显式指定名称Byname</td><td>默认ByName，当然两个都行，看配置</td></tr><tr class="odd"><td>使用范围</td><td>支持在构造函数、方法、字段和参数上使用</td><td>主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</td></tr></tbody></table><ul><li><code>ByType</code>存在的问题：当一个接口存在多个实现类，如果不指定名称，那编译器就不知道该使用这个接口的哪一个抽象类。于是会根据你定义的<strong>成员变量名</strong>匹配</li></ul><h5 id="bean的作用域">bean的作用域</h5><ul><li>singleton：单例</li><li>prototype：多例</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTPsession 内有效。</li><li><strong>application/global-session</strong> （仅 Web应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket会话产生一个新的 bean</li></ul><h5 id="bean是否线程安全">bean是否线程安全</h5><p>单例bean：如果这个bean存在状态，那么就是可能会出现竞争情况下的并发安全问题。</p><ul><li>状态：就是使用过程中会不会改变它的一些属性等等，一般项目中的bean如Dao、service了，我们只是简单的使用这个接口去调用它的方法并不会改变它的属性值</li></ul><p>多例bean：不会存在线程安全问题，因为每次获取都会创建一个新的 bean实例</p><h5 id="bean的生命周期">bean的生命周期</h5><p>实例化加载</p><ul><li>Bean 容器找到配置文件中 Spring Bean 的<strong>定义</strong>。</li><li>Bean 容器利用 Java Reflection API <strong>创建一个 Bean的实例。</strong></li><li>如果涉及到一些属性值 利用<code>set()</code>方法设置一些属性值。</li></ul><p>Aware，属性赋值</p><ul><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用<code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用<code>setBeanClassLoader()</code>方法，传入<code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用<code>setBeanFactory()</code>方法，传入<code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他<code>*.Aware</code>接口，就调用相应的方法。</li></ul><p><strong>初始化</strong></p><p>​ 前置处理</p><ul><li>如果有和加载这个 Bean 的 Spring 容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessBeforeInitialization()</code> 方法</li></ul><p>​ init</p><ul><li>如果 Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method属性，执行指定的方法。</li></ul><p>​ 后置处理</p><ul><li>如果有和加载这个 Bean 的 Spring 容器相关的<code>BeanPostProcessor</code>对象，执行<code>postProcessAfterInitialization()</code> 方法</li></ul><p>销毁</p><ul><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code>接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含destroy-method 属性，执行指定的方法。</li></ul><figure><img src="24bc2bad3ce28144d60d9e0a2edf6c7f.jpg"alt="Spring Bean 生命周期" /><figcaption aria-hidden="true">Spring Bean 生命周期</figcaption></figure><figure><img src="b5d264565657a5395c2781081a7483e1.jpg"alt="Spring Bean 生命周期" /><figcaption aria-hidden="true">Spring Bean 生命周期</figcaption></figure><h5 id="三级缓存解决循环依赖">三级缓存解决循环依赖</h5><p>bean的初始化完成的三步：</p><ul><li>实例化</li><li>属性赋值</li><li>初始化</li></ul><p>三级缓存：</p><ol type="1"><li>一级缓存 : <code>Map&lt;String,Object&gt;</code><strong>singletonObjects</strong>，单例池，用于保存<strong>实例化、属性赋值（注入）、初始化完成的bean 实例</strong></li><li>二级缓存 : <code>Map&lt;String,Object&gt;</code><strong>earlySingletonObjects</strong>，早期曝光对象，用于<strong>保存实例化完成的bean 实例</strong></li><li>三级缓存 : <code>Map&lt;String,ObjectFactory&lt;?&gt;&gt;</code><strong>singletonFactories</strong>，<strong>早期曝光对象工厂，用于保存bean 创建工厂，以便于后面扩展有机会创建代理对象。</strong></li></ol><p>解决过程：</p><p>假设A、B循环依赖：</p><p>A、B的初始化过程：</p><table><colgroup><col style="width: 38%" /><col style="width: 42%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">缓存空间</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">实例化： A对象⼯⼚放⼊三级缓存，先曝光出来让大家知道</td><td style="text-align: center;"></td><td style="text-align: center;">一级：，二级：，三级：A</td></tr><tr class="even"><td style="text-align: center;">属性赋值：发现依赖B，去实例化B</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">实例化，B对象工厂放⼊三级缓存...</td><td style="text-align: center;">一级：，二级：，三级：A,B</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">属性赋值：发现依赖A，找A</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><tdstyle="text-align: center;">去缓存中找A对象，拿到A的对象工厂,从对象工厂取出A（不完善）</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">将A放入二级缓存，删除三级缓存中的A</td><td style="text-align: center;">一级：，二级：A，三级：B</td></tr><tr class="odd"><td style="text-align: center;"></td><tdstyle="text-align: center;">B属性装配完成（装配的不完备的A），然后初始化完成</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">B放入一级缓存，是一个完备的对象</td><td style="text-align: center;">一级：B，二级：A，三级：</td></tr><tr class="odd"><tdstyle="text-align: center;">A属性装配，去一级缓存找到B，装配完成，然后初始化完成</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">删除二级缓存的A，放入一级缓存</td><td style="text-align: center;"></td><td style="text-align: center;">一级：A,B，二级：，三级：</td></tr></tbody></table><h6id="为什么不能只使用一级三级缓存"><strong>为什么不能只使用一级+三级缓存</strong></h6><ol type="1"><li>动态代理的创建时机就是<strong>存在于初始化后</strong>，为这个bean对象生成代理对象，如果先创建的话，这样不管这个类是否存在循环依赖，都会先生成，违反Bean的初始化设计。</li><li>如果只使用这两层缓存，在使用三级缓存中的工厂对象生成的动态代理对象都是<strong>新创建的</strong>，循环依赖的时候，<strong>注入到别的bean里面去的那个动态代理对象和最终这个bean在初始化后自己创建的bean地址值不一样</strong>，或者说有2个以上的bean循环依赖的时候，他们各自拿到的bean的动态代理对象都是不一样的。所以需要一个二级缓存来存，如果二级里面有就不用查三级了。这也三级缓存和二级缓存的初始容量只有16的原因出现循环依赖本身就是代码设计不合理的，不要为了那少部分的本身不合理情况的循环依赖去改变一个大多数都合理的设计。</li></ol><h3 id="aop-1">Aop</h3><p>AOP(Aspect-OrientedProgramming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>基于动态代理实现：</p><ul><li>如果目标对象实现了某个接口，会用jdk动态代理</li><li>目标对象没有实现接口，会使用 <strong>Cglib</strong>生成一个被代理对象的<strong>子类</strong>来作为代理</li></ul><figure><img src="230ae587a322d6e4d09510161987d346.jpeg"alt="SpringAOPProcess" /><figcaption aria-hidden="true">SpringAOPProcess</figcaption></figure><p>AOP 切面编程设计到的一些专业术语：</p><table><colgroup><col style="width: 22%" /><col style="width: 77%" /></colgroup><thead><tr class="header"><th style="text-align: left;">术语</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">目标(Target)</td><td style="text-align: center;">被通知的对象</td></tr><tr class="even"><td style="text-align: left;">代理(Proxy)</td><tdstyle="text-align: center;">向目标对象应用通知之后创建的代理对象</td></tr><tr class="odd"><td style="text-align: left;">连接点(JoinPoint)</td><tdstyle="text-align: center;">目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr class="even"><td style="text-align: left;">切入点(Pointcut)</td><td style="text-align: center;">被切面拦截 /增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr class="odd"><td style="text-align: left;">通知(Advice)</td><td style="text-align: center;">增强的逻辑 /代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr class="even"><td style="text-align: left;">切面(Aspect)</td><td style="text-align: center;">切入点(Pointcut)+通知(Advice)</td></tr><tr class="odd"><td style="text-align: left;">Weaving(织入)</td><tdstyle="text-align: center;">将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h4 id="aspectj-aop">AspectJ AOP</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(BytecodeManipulation)。</p><h5 id="通知类型">通知类型</h5><p><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</p><p><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</p><p><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p><p><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出/ 触发异常后触发。AfterReturning 和 AfterThrowing两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p><p><strong>Around</strong>（环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</p><h3 id="springmvc">SpringMVC</h3><ul><li>模型Model：</li><li>视图View：</li><li>控制器controller：</li></ul><p>业务逻辑、数据、显示分离来组织代码。</p><p>Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao层（数据库操作）、Entity 层（实体类）、Controller层(控制层，返回数据给前台页面)。</p><h4 id="核心组件">核心组件</h4><ul><li><strong><code>DispatcherServlet</code></strong>：<strong>核心的中央处理器</strong>，负责接收请求、分发，并响应给客户端。</li><li><strong><code>HandlerMapping</code></strong>：<strong>处理器映射器</strong>，根据uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和<code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code></strong>：<strong>处理器适配器</strong>，根据<code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的<code>Handler</code>；</li><li><strong><code>Handler</code></strong>：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code></strong>：<strong>视图解析器</strong>，根据<code>Handler</code> 返回的逻辑视图 /视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code>响应客户端</li></ul><h4 id="工作原理">工作原理</h4><figure><img src="de6d2b213f112297298f3e223bf08f28.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>客户端（浏览器）发送请求，<code>DispatcherServlet</code>拦截请求。</li><li>找hanlder<ol type="1"><li><code>DispatcherServlet</code> 根据请求信息调用<code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据<strong>uri</strong> 去匹配查找能处理的<code>Handler</code>（也就是我们平常说的 <code>Controller</code>控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code>一起封装。</li><li><code>DispatcherServlet</code> 调用<code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li></ol></li><li><code>handler</code>处理后返回的 <code>ModelAndView</code>的处理<ol type="1"><li><code>ModelAndView</code>顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code>是返回的数据对象，<code>View</code> 是个逻辑上的<code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的<code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给<code>View</code>（视图渲染）。</li></ol></li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h4 id="统一异常处理">统一异常处理</h4><p>推荐使用注解的方式统一异常处理，具体会使用到<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>这两个注解 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ResponseEntity：统一返回值定义对象</p></li><li><p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code><strong>织入异常处理的逻辑（AOP）</strong>当 <code>Controller</code>中的方法抛出异常的时候，由被<code>@ExceptionHandler</code>注解修饰的方法进行处理。</p></li></ul><h3 id="spring事务">Spring事务</h3><h4 id="管理事务的方式">管理事务的方式</h4><ul><li>声明式（推荐）：</li><li>编程式：AOP 实现（基于<code>@Transactional</code>的全注解方式使用最多）</li></ul><h5 id="事务管理接口">事务管理接口</h5><ul><li><strong><code>PlatformTransactionManager</code></strong>：（平台）事务管理器，Spring事务策略的核心。</li><li><strong><code>TransactionDefinition</code></strong>：事务定义属性信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li><li><strong><code>TransactionStatus</code></strong>：事务运行状态。</li></ul><h6id="platformtransactionmanager事务管理接口">PlatformTransactionManager:事务管理接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6id="transactiondefinition事务属性">TransactionDefinition:事务属性</h6><ul><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TransactionDefinition <span class="title function_">withDefaults</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="transactionstatus事务状态">TransactionStatus:事务状态</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性">事务属性</h4><p>五方面属性：</p><ul><li>隔离级别</li><li>传播行为：<strong>解决业务层方法之间互相调用的事务问题</strong></li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><h5 id="事务传播行为种类">事务传播行为——种类</h5><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。</p><p>对于事务B，如果当前存在事务A，则B加入A事务；</p><p>如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p><p>也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且<strong>开启的事务相互独立，互不干扰。</strong></p><p>案例：</p><p>A：PROPAGATION_REQUIRED B：PROPAGATION_REQUIRES_NEW</p><ul><li>A回滚，B并不会，因为B隔离于A新开了事务。</li><li>B回滚，A会回滚，因为A检测到B的存在并且回滚。</li></ul><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><h4 id="transactional注解">Transactional注解</h4><p>Transactional(rollbackFor =Exception.class)：表示事务在执行过程中遇到Exception（包括全部子类），事务自动回滚。</p><ul><li><span class="citation"data-cites="Transactional注解作用在类上">@Transactional注解作用在类上</span>：所有的public方法具有该类型的事务属性，</li><li><code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</li></ul><h2 id="springboot">SpringBoot</h2><h3 id="自动装配">自动装配</h3><h4 id="概念">概念</h4><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot在启动时会扫描外部引用 jar包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到Spring 容器（此处涉及到 JVM 类加载机制与 Spring的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p></blockquote><h4 id="原理-3">原理</h4><p><span class="citation"data-cites="*">@*</span>*SpringBootApplication：以下三个注解的集合**</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean或导入其他配置类</li><li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>,<code>@Controller</code>)注解的bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些bean。</li></ul><p><span class="citation"data-cites="EnableAutoConfiguration:实现自动装配的核心注解">@EnableAutoConfiguration:实现自动装配的核心注解</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoConfigurationImportSelector:加载自动装配类</p><p>继承体系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AutoConfigurationImportSelector</code>实现了<code>DeferredImportSelector</code>接口，其顶层接口<code>ImportSelector</code>。</p><p>顶级接口实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAutoConfigurationEntry</code>方法：负责加载自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AutoConfigurationEntry</span> <span class="variable">EMPTY_ENTRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>();</span><br><span class="line"></span><br><span class="line">AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line"><span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="built_in">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在<code>application.properties</code> 或 <code>application.yml</code>中设置</p></li><li><p>用于获取<code>EnableAutoConfiguration</code>注解中的<code>exclude</code> 和 <code>excludeName</code>。</p><figure><img src="3d6ec93bbda1453aa08c52b49516c05atplv-k3u1fbpfcp-zoom-1.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p><p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有Spring Boot Starter下的<code>META-INF/spring.factories</code>都会被读取到。</p></li><li><p>不能一次性加载全部配置类，筛选一部分.</p><p>有的starter如果启用，<code>@ConditionalOnXXX</code>就会满足，就能被自动装配</p><p>例如,rabbitMQ的依赖信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class="line"><span class="meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用到，就会加载。</p></li></ol><h5 id="条件注解">条件注解</h5><ul><li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li><li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean的情况下</li><li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean在容器中只有一个，或者虽然有多个但是指定首选 Bean</li><li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li><li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li><li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li><li><code>@ConditionalOnExpression</code>：基于 SpEL表达式作为判断条件</li><li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li><li><code>@ConditionalOnJndi</code>：在 JNDI存在的条件下差在指定的位置</li><li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web项目的条件下</li><li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项目的条件下</li></ul><h1 id="jvm">JVM</h1><h2 id="java内存区域">java内存区域</h2><h3 id="运行时数据区">运行时数据区</h3><p><img src="java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:67%;" /></p><p>线程私有：</p><ul><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li></ul><p>线程共享：</p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>运行时数据区大小非常弹性，以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h4 id="程序计数器">程序计数器</h4><p>一块较小的内存区间，可以看成线程在字节码文件上运行的<strong>行号指示器</strong>。</p><p>作用：</p><ul><li>字节码解释器通过改变程序计数器，实现代码流程控制:如：顺序执行、选择、循环、异常处理。</li><li>多线程情况下，程序计数器用于记录当前线程执行到哪一位置，方便接下来线程上下文切换的时候能快速定位到代码上次运行到哪。</li></ul><p>注意：</p><p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code>的内存区域，它的<strong>生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h4 id="java虚拟机栈">java虚拟机栈</h4><p>所有的java方法调用都是通过栈来实现的。</p><p>栈内基本元素单位：<strong>栈帧</strong>，方法对应栈帧，每调用一个方法，一个栈帧压栈，调用结束，栈帧弹出。</p><p>栈帧的结构：</p><p><img src="image-20230922152758136.png" alt="image-20230922152758136" style="zoom: 67%;" /></p><ul><li><p>局部变量表：存放了<strong>编译期可知</strong>的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个<strong>指向对象起始地址的引用指针</strong>，也可能是指向一个<strong>代表对象的句柄</strong>或其他与此对象相关的位置）</p></li><li><p>操作数栈：存储方法执行过程中的中间计算结果，计算过程中产生的临时变量。</p></li><li><p>动态链接：应用于方法间互相调用的场景。当一个方法要调用另一个方法时需要将常量池中指向方法区的方法的<strong>符号引用转化为其在内存地址中的直接引用。</strong></p><ul><li>Class文件的常量池里保存有大量的符号引用比如方法引用的符号引用。</li></ul><figure><img src="jvmimage-20220331175738692.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>方法返回地址：jaav两种返回方式：return、异常抛出。这两种方法都会使得栈帧抛出。</p></li></ul><p>栈帧的生命周期 = 调用方法的生命周期</p><p>栈可能会报的错</p><ul><li><strong><code>StackOverFlowError</code>：</strong>若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code>错误。</li><li><strong><code>OutOfMemoryError</code>：</strong>如果栈的内存大小可以动态扩展，如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><h4 id="本地方法栈">本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。</strong></p><p>其它和栈类似。</p><h4 id="堆">堆</h4><p>管理内存最大的一块，主要目的就是存放对象实例以及数组。</p><blockquote><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从JDK 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p></blockquote><p>又称GC堆，分为老年代、新生代再细致一点：Eden、Survivor、Old等空间。</p><p><img src="hotspot-heap-structure.png" alt="堆内存结构" style="zoom: 80%;" /></p><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间)取代，元空间使用的是本地内存。</strong></p><p>对象分配流程：</p><p>eden区出生，每次垃圾回收之后，对象如果还存活，年龄会+1，并且会根据年龄分配到S1、S0区。</p><p>堆可能出现的异常：</p><ul><li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong>：当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong>:假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象,就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值</li></ul><h4 id="方法区">方法区</h4><p>是一种概念，不同的虚拟机其方法区实现不同。</p><p><img src="image-20230922165020342.png" alt="image-20230922165020342" style="zoom:67%;" /></p><p>永久代替换成元空间的原因：</p><ol type="1"><li>永久代是jvm固定设置大小的，无法调整元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。<ul><li>你可以使用 <code>-XX：MaxMetaspaceSize</code>标志设置最大元空间大小，默认值为unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code>调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace将根据运行时的应用程序需求动态地重新调整大小。</li></ul></li><li>可存的类会多</li></ol><p>方法区常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><h4 id="运行时常量区">运行时常量区</h4><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（SymbolicReference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>《深入理解 Java 虚拟机》7.34节第三版对符号引用和直接引用的解释如下：</p><figure><img src="image-20230922172054361.png" alt="image-20230922172054361" /><figcaption aria-hidden="true">image-20230922172054361</figcaption></figure><p>当常量池满了，也会抛出<code>OutOfMemoryError</code> 错误。</p><h4 id="字符串常量池">字符串常量池</h4><p>JVM 为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="直接内存区">直接内存区</h4><p>是一种特殊的内存缓冲区，是通过JNI的方式在<strong>本地内存</strong>分配。</p><h3 id="hotspot虚拟机">HotSpot虚拟机</h3><h4 id="对象的创建">对象的创建</h4><h5 id="类加载检查">类加载检查</h5><p>虚拟机遇到一条 new指令时，去检查这个指令的参数是否能在常量池中定位到这个类的符号引用</p><p>然后判断这个对象所在的类有无加载、解析和初始化过，如果没有，执行类加载过程。</p><h5 id="分配内存">分配内存</h5><p>指针碰撞</p><ul><li>适用场合：堆内存规整、一片连续的内存空间。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个<strong>分界指针</strong>，为对象分配内存只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的GC收集器：Serial, ParNew</li></ul><p>空闲列表</p><ul><li>适用场合：堆内存不规整、碎片化</li><li>原理：将碎片化的空间串成一个链表，又虚拟机来维护，分配内存的时候，为对象选取一块差不多大小的内存块分配。</li><li>使用该分配方式的GC收集器：CMS</li></ul><h6 id="内存分配并发问题">内存分配并发问题</h6><p>虚拟机创建对象保证线程安全的手段：</p><ul><li>CAS + 失败重试：</li><li>TLAB：为每一个线程预先在eden区分配一块内存，然后线程创建对象的时候，jvm首先在TLAB分配，当对象大于TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS进行内存分配</li></ul><h5 id="初始化零值">初始化零值</h5><p>这一步操作保证了对象的实例字段在 Java代码中可以<strong>不赋初始值就直接使用</strong>。</p><h5 id="设置对象头">设置对象头</h5><p>关于对象的一些信息存入对象头，如：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC 分代年龄等信息。</p><h5 id="执行init">执行init</h5><p>从虚拟机的视角来看，一个新的对象已经产生了。</p><p>从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零。</p><p>此时执行init方法，按照程序员意愿初始化。</p><p>这里init方法相当于构造函数。</p><h4 id="对象内存布局">对象内存布局</h4><p><strong>对象头</strong></p><ul><li>存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志等等</li><li>类型指针：指向对象自己类的元数据，用于标识自己是哪个类的产物。</li></ul><p><strong>实例数据</strong></p><p>对象的属性等等。</p><p><strong>对齐补充</strong></p><blockquote><p><strong>填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong>因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8字节的整数倍，换句话说就是对象的大小必须是 8字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p></blockquote><h4 id="对象的访问">对象的访问</h4><p><strong>句柄</strong></p><p><img src="access-location-of-object-handle.png" alt="对象的访问定位-使用句柄" style="zoom:67%;" /></p><p><strong>直接指针</strong></p><p><img src="access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针" style="zoom:67%;" /></p><h3 id="java引用类型">java引用类型</h3><p>强度自上而下递减。</p><p><strong>强引用</strong></p><p><code>String x = new Striong("666");</code>此时x就是强引用。</p><p>不会回收被此引用引用的对象，堆内存满了直接抛出<code>OutOfMemoryError</code></p><p><strong>软引用</strong></p><p>可有可无的引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p><p>配合引用队列使用，队列存的都是被垃圾回收的软引用对象。</p><p>作用：加速jvm的内存回收速度。</p><p><strong>弱引用</strong></p><p>垃圾回收器遇到弱引用就回收，不会管堆内存大小。</p><p>应用：ThreadLocal等</p><p><strong>虚引用</strong></p><p>目的：跟踪对象被垃圾回收的活动。</p><p>注意：必须配合引用队列，当一个对象即将被回收，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p><h2 id="垃圾回收">垃圾回收</h2><h3 id="内存分配和回收原则">内存分配和回收原则</h3><h4 id="对象优先在eden区分配">对象优先在eden区分配</h4><p>大多数情况下，对象在新生代中 Eden区分配。eden区空间不够的时候，虚拟机发起一次 Minor gc。</p><p>案例：</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行时带上虚拟机参数：-XX:+PrintGCDetails</li></ul><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><figure><img src="28954286.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>eden区已经分配完全，</p><p>假如我们再为 <code>allocation2</code>分配内存<code>allocation2 = new byte[900*1024];</code></p><figure><img src="28128785.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>给 <code>allocation2</code> 分配内存的时候 Eden区内存几乎已经被分配完了，当 Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现<code>allocation1</code> 无法存入 Survivor 空间，所以只好通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去，老年代上的空间足够存放<code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden区分配内存。可以执行如下代码验证：</p><h5 id="空间分配担保">空间分配担保</h5><p>目的：确保MinorGC之前老年代本身还有容纳<strong>所有新生代对象</strong>的剩余空间。</p><blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看<code>-XX:HandlePromotionFailure</code>参数的设置值是否允许担保失败(Handle PromotionFailure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者<code>-XX: HandlePromotionFailure</code>设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行 Full GC。</p></blockquote><h4 id="大对象进入老年代">大对象进入老年代</h4><p>目的：减少新生代的gc频率。</p><p>根据不同的虚拟机以及垃圾回收器决定操作：</p><ul><li><p>G1垃圾回收器会根据-XX:G1HeapRegionSize参数设置的堆区域大小和-XX:G1MixedGCLiveThresholdPercent参数设置的阈值，来决定哪些对象会直接进入老年代。</p></li><li><p>ParallelScavenge垃圾回收器中，默认情况下，并没有一个固定的阈值(XX:ThresholdTolerance是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。</p></li></ul><h4 id="长期存活对象进入老年代">长期存活对象进入老年代</h4><p>对象创建在eden区 ——&gt; 第一次Minor GC后仍然存活 ——&gt;分配到survivor(年龄初始设为1岁) ——&gt;在survivor区每熬过一岁，年龄增加一次 ——&gt;年龄增加到老年代年龄阈值（不同的虚拟机垃圾回收器有不同的阈值，默认15）</p><p>动态年龄计算：</p><p>修正（<ahref="https://github.com/Snailclimb/JavaGuide/issues/552">issue552openin new window</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor 区的 50% 时（默认值是 50%，可以通过<code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <ahref="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199openin new window</a> ），取这个年龄和 MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8官方文档引用：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html。</p><figure><img src="image-20210523201742303.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"><span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">total += sizes[age];</span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="gc收集方式区域">gc收集方式区域</h4><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / OldGC）：只对老年代进行垃圾收集。需要注意的是 Major GC在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="死亡对象判断方法">死亡对象判断方法</h3><h4 id="引用计数法">引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><h5 id="循环引用问题">循环引用问题</h5><figure><img src="object-circular-reference.png" alt="对象之间循环引用" /><figcaption aria-hidden="true">对象之间循环引用</figcaption></figure><p>当两个对象都不用的时候，互相都有个引用指针指向彼此，也不会造成gc。</p><h4 id="可达性分析算法">可达性分析算法</h4><p>通过一系列称为 GC Roots的对象结点作为起点，从这些结点开始往下搜索，走的路径就是引用链，这个引用链上的结点都不会被gc，未达到的结点可以被gc清除。</p><h5 id="可作为gc-roots的结点">可作为gc roots的结点</h5><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><h5id="对象可以被回收不一定会被回收"><strong>对象可以被回收，不一定会被回收</strong></h5><p><strong>至少经历两次</strong>标记过程，对象才会彻底死亡。</p><p>可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code>方法，或 <code>finalize</code>方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><h3 id="废弃常量">废弃常量</h3><p>字符串常量：没有String对象引用的字符串称为废弃（字符串）常量。</p><h3 id="无用的类">无用的类</h3><ul><li>所有实例对象都被回收</li><li>加载该类的类加载器已被回收</li><li>该类对应的<code>Class</code>对象，没有被引用</li></ul><h3 id="垃圾回收算法">垃圾回收算法</h3><h4 id="标记清除">标记清除</h4><p>原理：遍历所有对象，标记不需要回收的对象，标记完成后统一回收掉所有没有被标记的对象。</p><p>缺陷：</p><ol type="1"><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会<strong>产生大量</strong>不连续的<strong>内存碎片</strong>。</li></ol><h4 id="标记复制">标记复制</h4><p>原理：内存均分成两块，每次使用其中的一块，当一块内存用完以后，标记所有不需要回收的对象，复制到另一半空闲内存中，然后清理这一半内存。</p><p>缺陷：</p><ol type="1"><li>可用内存变小（仅有50%）</li><li>不适用老年代：因为存活的对象数量太多，复制效率低下。</li></ol><h4 id="标记整理">标记整理</h4><p>原理：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p>缺陷：效率低，仅适用老年代这样低gc频率的场景</p><p><img src="mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;" /></p><h4 id="分代收集">分代收集</h4><p>新生代：标记-复制算法</p><ul><li>每次收集都会有大量对象死去</li></ul><p>老年代：“标记-清除”或“标记-整理”</p><ul><li>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保</li></ul><h3 id="垃圾收集器">垃圾收集器</h3><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h4 id="serial-收集器">Serial 收集器</h4><p>单线程；</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><figure><img src="serial-garbage-collector.png" alt="Serial 收集器" /><figcaption aria-hidden="true">Serial 收集器</figcaption></figure><h4 id="parnew-收集器">ParNew 收集器</h4><p>Serial 多线程版本；</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><figure><img src="parnew-garbage-collector.png" alt="ParNew 收集器" /><figcaption aria-hidden="true">ParNew 收集器</figcaption></figure><h4 id="cms-收集器">CMS 收集器</h4><p>CMS（Concurrent MarkSweep）是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，注重用户体验。</p><p>并发收集器，能和用户线程一起工作。</p><p>采用标记-清除算法。</p><p>gc过程：</p><ol type="1"><li>初始标记：暂停所有的其他线程，并记录下直接与 root相连的对象，速度很快 ；</li><li>并发标记：同时开启用户线程和gc线程，通过闭包结构，记录可达对象。<ul><li>注意：由于用户线程也在运行，无法保证在这期间有新的对象被GCroots直接或者间接引用，因此要有重新标记</li></ul></li><li>重新标记：为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，停顿时间略长。</li><li>并发清除：</li></ol><blockquote><p>闭包：能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取<ahref="https://baike.baidu.com/item/局部变量/9844788?fromModule=lemma_inlink">局部变量</a>，所以闭包可以理解成“定义在一个<ahref="https://baike.baidu.com/item/函数/301912?fromModule=lemma_inlink">函数</a>内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p></blockquote><p>缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h4 id="g1-收集器">G1 收集器</h4><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器.以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>特征：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1可以不需要其他收集器配合就能<strong>独立管理整个 GC堆</strong>，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1从<strong>整体</strong>来看是<strong>基于“标记-整理”算法实现的收集器</strong>；从<strong>局部</strong>上来看是基于“<strong>标记-复制</strong>”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS的另一个大优势，<strong>降低停顿时间</strong>是 G1 和 CMS共同的关注点，但 G1除了追求低停顿外，还能建立可预测的停顿时间模型，<strong>能让使用者明确指定在一个长度为M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N毫秒。</strong></li></ul><p>gc过程：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><figure><img src="g1-garbage-collector.png" alt="G1 收集器" /><figcaption aria-hidden="true">G1 收集器</figcaption></figure><p>后台维护了<strong>优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First 的由来)** 。</p><h2 id="类加载过程">类加载过程</h2><h3 id="类声明周期">类声明周期</h3><p><img src="lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:67%;" /></p><h3 id="类加载过程-1">类加载过程</h3><h4 id="加载">加载</h4><ol type="1"><li>通过全类名获取定义此类的<strong>二进制字节流</strong>：<code>ZIP</code>、<code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如<code>JSP</code>...</li><li>将字节流所代表的<strong>静态存储结构转换为方法区的运行时数据结构</strong>。</li><li>内存中生成一个代表该类的 <code>Class</code> 对象</li></ol><p>交由类加载器完成，具体交由哪个类加载器由<strong>双亲委派模型</strong>决定</p><p><strong>每个 Java 类都有一个引用指向加载它的<code>ClassLoader</code>。</strong></p><ul><li>数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取<code>ClassLoader</code> 的时候和该数组的元素类型的<code>ClassLoader</code> 是一致的。</li></ul><h4 id="链接">链接</h4><h5 id="验证">验证</h5><p>过程：</p><ol type="1"><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><figure><img src="class-loading-process-verification.png"alt="验证阶段示意图" /><figcaption aria-hidden="true">验证阶段示意图</figcaption></figure><p>验证是否是必须经过的流程？</p><p>否，使用 <code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h6 id="符号引用验证">符号引用验证</h6><p>符号引用验证的主要目的是<strong>确保解析阶段能正常执行</strong>。</p><p>如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li></ul><h5 id="准备">准备</h5><p><strong>正式为类变量分配内存并设置类变量初始值的阶段</strong>。</p><p>注意：</p><ol type="1"><li>这时候只对<strong>类变量</strong>进行内存分配（ Class Variables，即静态变量，被 <code>static</code>关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong>中进行分配。JDK 7 之前，HotSpot使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 在 JDK 7及之后，HotSpot已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候<strong>类变量则会随着Class 对象一起存放在 Java 堆</strong>中。</li><li>这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final关键字<code>public static final int value=111</code> ，那么准备阶段value 的值就被赋值为 111。</li></ol><p>零值表：</p><figure><img src="基本数据类型的零值.png" alt="基本数据类型的零值" /><figcaption aria-hidden="true">基本数据类型的零值</figcaption></figure><h5 id="解析">解析</h5><p><strong>将常量池内的符号引用替换为直接引用的过程。</strong></p><p>解析目标：针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符等</p><p>符号引用就是就是得到类或者字段、方法在<strong>内存中的指针或者偏移量</strong>。</p><blockquote><p>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p></blockquote><h4 id="初始化">初始化</h4><p><strong>初始化阶段是执行初始化方法<code>&lt;clinit&gt; ()</code>方法的过程</strong>，这一步之后，jvm真正开始执行类定义中的java程序代码。</p><p>六种情况必须初始化：</p><ol type="1"><li><p>当遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或<code>invokestatic</code> 这 4 条字节码指令时：</p><ul><li><p>当 jvm 执行 <code>new</code>指令时会初始化类。即当程序创建一个类的实例对象。</p></li><li><p>当 jvm 执行 <code>getstatic</code>指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</p></li><li><p>当 jvm 执行 <code>putstatic</code>指令时会初始化类。即程序给类的静态变量赋值。</p></li><li><p>当 jvm 执行 <code>invokestatic</code>指令时会初始化类。即程序调用类的静态方法。</p></li></ul></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如<code>Class.forname("...")</code>, <code>newInstance()</code>等等。如果类没初始化，需要触发其初始化。</p></li><li><p>初始化一个类，如果其父类还未初始化，则<strong>先触发父类</strong>的<strong>初始化</strong>。</p></li><li><p>当虚拟机启动时，用户需要定义一个要执行的主类 (包含<code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</p></li><li><p><code>MethodHandle</code> 和 <code>VarHandle</code>可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用<code>findStaticVarHandle</code> 来初始化要调用的类。</p></li><li><p>当一个接口中定义了 JDK8 新加入的默认方法（被 default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h2 id="类加载器">类加载器</h2><blockquote><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code>是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p><p>每个 Java 类都有一个引用指向加载它的<code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code>创建的，而是 JVM在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取<code>ClassLoader</code> 的时候和该数组的元素类型的<code>ClassLoader</code> 是一致的。</p></blockquote><p>作用：加载java类的字节码到jvm中（在内存生成一个该类的class对象）。</p><h3 id="类加载器加载规则">类加载器加载规则</h3><p><strong>动态加载：</strong>按需加载。</p><ul><li><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。</p></li><li><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。<strong>对于一个类加载器来说，相同二进制名称的类只会被加载一次。</strong></p></li></ul><h3 id="三个重要类加载器">三个重要类加载器</h3><ul><li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等jar 包和类）以及被<code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载<code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被<code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用classpath 下的所有 jar 包和类。</li></ul><blockquote><p><strong><code>rt.jar</code></strong>：rt代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc里面看到的所有的类的类文件。也就是说，我们常用内置库<code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</p><p>Java 9引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platformclass loader）。Java SE 中除了少数几个关键模块，比如说<code>java.base</code>是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p></blockquote><p><img src="class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom:67%;" /></p><p>除了 <code>BootstrapClassLoader</code> 是 JVM自身的一部分之外，<strong>其他所有的类加载器都是在 JVM外部实现的，并且全都继承自<code>ClassLoader</code>抽象类。</strong>这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><h4 id="自定义类加载器">自定义类加载器</h4><p>自定义类加载器需要继承<code>ClassLoader</code>抽象类。其中两个关键方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，<strong>实现了双亲委派机制</strong>。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code>方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><h3 id="双亲委派模型">双亲委派模型</h3><p>具体的类用哪一个类加载器加载，由双亲委派模型决定：</p><ul><li><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p></li><li><p><strong>每个 <code>ClassLoader</code>实例都有一个相关的父类加载器。</strong></p></li><li><p>需要查找类或资源时，<code>ClassLoader</code>实例会在试图亲自查找类或资源之前，<strong>将搜索类或资源的任务委托给其父类加载器。</strong></p><ul><li>虚拟机中被称为 "bootstrap classloader"的内置类加载器本身没有父类加载器，但是可以作为<code>ClassLoader</code> 实例的父类加载器。</li></ul></li></ul><p>父子关系的实现——合成复用原则：</p><p>类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：</p><p>保证了 Java 程序的稳定运行，可以避免类的重复加载。</p><ul><li><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：</p><ul><li><p>类的全名</p></li><li><p>是否由同一个类加载器加载</p></li></ul></li></ul><blockquote><p>比如我们编写一个称为 <code>java.lang.Object</code>类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code>类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code>类，而不是你写的 <code>Object</code> 类。这是因为<code>AppClassLoader</code> 在加载你的 <code>Object</code>类时，会委托给 <code>ExtClassLoader</code> 去加载，而<code>ExtClassLoader</code> 又会委托给<code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>发现自己已经加载过了 <code>Object</code>类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p></blockquote><h4 id="执行流程">执行流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>检查是否加载过：每个父加载器都要走一遍这个流程</li><li>类加载器在进行类加载的时候，它首先<strong>不会自己去尝试加载这个类</strong>，<strong>而是把这个请求委派给父类加载器去完成</strong>（调用父加载器<code>loadClass()</code>方法来加载类）。<ul><li>当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的<code>findClass()</code> 方法来加载类）。</li></ul></li><li>如果子类加载器也无法加载这个类，那么它会抛出一个<code>ClassNotFoundException</code> 异常。</li></ol><h4 id="如何打破">如何打破</h4><p>重写 <code>loadClass()</code>方法：</p><ul><li>原因：类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器<code>loadClass()</code>方法来加载类）。</li></ul><p>案例：</p><p>Tomcat 服务器为了能够优先加载 Web应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器<code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web应用之间的类实现隔离的具体原理。</p><p>Tomcat类加载器层次：</p><p><img src="tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构" style="zoom:67%;" /></p><ul><li>CommonClassLoader<code>对应</code><Tomcat>/common/*</li><li>CatalinaClassLoader<code>对应</code><Tomcat >/server/*</li><li>SharedClassLoader<code>对应</code><Tomcat >/shared/*</li><li>WebAppClassloader<code>对应</code><Tomcat >/webapps/<app>/WEB-INF/*</li></ul><p>自上而下分析：</p><ol type="1"><li><code>CommonClassLoader</code>作为 <code>CatalinaClassLoader</code>和 <code>SharedClassLoader</code>的父加载器。<code>CommonClassLoader</code> 能加载的类都可以被<code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code>使用。因此，<code>CommonClassLoader</code>是为了实现公共类库（可以被所有 Web 应用和 Tomcat内部组件使用的类库）的共享和隔离。</li><li><code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code>能加载的类则与对方相互隔离。<code>CatalinaClassLoader</code> 用于加载Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web应用的类。<code>SharedClassLoader</code> 作为<code>WebAppClassLoader</code> 的父加载器，专门来加载 Web应用之间共享的类比如 Spring、Mybatis。</li><li>每个 Web 应用都会创建一个单独的<code>WebAppClassLoader</code>，并在启动 Web应用的线程里设置线程线程上下文类加载器为<code>WebAppClassLoader</code>。各个 <code>WebAppClassLoader</code>实例之间相互隔离，进而实现 Web 应用之间的类隔。</li></ol><p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。</p><ol type="1"><li><p>SPI 中，SPI 的接口（如 <code>java.sql.Driver</code>）是由 Java核心库提供的，由<code>BootstrapClassLoader</code> 加载。而 SPI的实现（如<code>com.mysql.cj.jdbc.Driver</code>）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载SPI的接口的类加载器（<code>BootstrapClassLoader</code>）也会用来加载SPI的实现。按照双亲委派模型，<code>BootstrapClassLoader</code> 是无法找到SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。</p></li><li><p>假设我们的项目中有 Spring 的 jar 包，由于其是 Web应用之间共享的，因此会由 <code>SharedClassLoader</code> 加载（Web服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring的类加载器（也就是<code>SharedClassLoader</code>）也会用来加载这些业务类。但是业务类在 Web应用目录下，不在 <code>SharedClassLoader</code> 的加载路径下，所以<code>SharedClassLoader</code> 无法找到业务类，也就无法加载它们。</p><ul><li><p><strong>线程上下文类加载器</strong>解决：当 Spring需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。</p><p>每个 Web 应用都会<strong>创建一个单独的<code>WebAppClassLoader</code></strong>，并在启动 Web应用的线程里设置线程线程上下文类加载器为<code>WebAppClassLoader</code>。这样就可以让高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（<code>WebAppClassLoader</code>）来加载业务类，破坏了 Java的类加载委托机制，让应用<strong>逆向使用类加载器</strong>。</p></li></ul></li></ol><h2 id="section-1"></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础语法&quot;&gt;基础语法&lt;/h1&gt;
&lt;h2 id=&quot;基本数据类型&quot;&gt;基本数据类型&lt;/h2&gt;
&lt;h3 id=&quot;几种基本数据类型&quot;&gt;几种基本数据类型&lt;/h3&gt;
&lt;p&gt;8种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6 种数字类型：
&lt;ul&gt;
&lt;li&gt;4
种整数型</summary>
      
    
    
    
    <category term="Java" scheme="https://vlsmhd.github.io/categories/Java/"/>
    
    <category term="面试" scheme="https://vlsmhd.github.io/categories/Java/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2023年7至8月第六届字节青训营学习记录</title>
    <link href="https://vlsmhd.github.io/2023/07/24/2023%E5%B9%B47%E8%87%B38%E6%9C%88%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://vlsmhd.github.io/2023/07/24/2023%E5%B9%B47%E8%87%B38%E6%9C%88%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-07-24T14:06:32.157Z</published>
    <updated>2023-09-01T13:20:17.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程前置信息">课程前置信息</h1><p>文档：</p><p><ahref="https://bytedance.feishu.cn/docx/KwNudUZqQoGL6sxDzFscelaHnGg?contentTheme=DARK&amp;theme=LIGHT">‌⁡‌⁢⁢‌⁤‍‬﻿⁡⁣‍⁢‌⁤﻿‍﻿‍⁤‌‬﻿⁤﻿⁤⁡﻿‌‍⁡⁣⁡‬⁡‍‌‌‬﻿【开营班会】第六届字节跳动青训营-后端方向- 飞书云文档 (feishu.cn)</a></p><h1 id="go课程学习">Go课程学习</h1><h2 id="安装配置">安装配置</h2><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230726093804215.png"alt="image-20230726093804215" /><figcaption aria-hidden="true">image-20230726093804215</figcaption></figure><p>免安装版，安装完自动配置。</p><h2 id="基础语法入门">基础语法入门</h2><h3 id="helloworld程序">helloworld程序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run helloworld.go</span><br></pre></td></tr></table></figure><p>编译程序：生成可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build helloworld.go</span><br></pre></td></tr></table></figure><h3 id="基础语法">基础语法</h3><h4 id="基础数据类型">基础数据类型</h4><h5 id="字符串">字符串</h5><p>常用的解析外部传来的字符串：</p><ul><li>``` strconv <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 复合数据类型</span><br><span class="line"></span><br><span class="line">##### 数组</span><br><span class="line"></span><br><span class="line">定义格式：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">var a [5]int</span><br><span class="line"></span><br><span class="line">b := [5]int&#123;1,2,3,4,5&#125; </span><br><span class="line"></span><br><span class="line">//二维数组</span><br><span class="line">var twoD[2][3]</span><br></pre></td></tr></table></figure></li></ul><h5 id="切片">切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]String, <span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切片不同于数组<strong>可以任意更改长度</strong>。比如说我们可以用make来创建一个切片，可以像数组一样去取值，使用append来追加元素。</p><p>注意append的用法的话，你必须把append 的结果赋值为原数组。</p><p>因为slice的原理实际上是它有一个它存储了一个长度和一个容量，加一个指向一个数组的指升，在你执行append操作的时候，如果容量不够的话，会扩容并且返回新的 slice,slice此初始化的时候也可以指定长度。</p><p>slice拥有像python一样的切片操作，可以取出任意区间位置的元素，不包括第五个元素。不同于python，这里不支持负数索引</p><h5 id="map">map</h5><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map</span></span><br><span class="line">ages := <span class="built_in">make</span>(ages[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">&quot;charlie&quot;</span>] = <span class="number">34</span></span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line">ages := <span class="built_in">make</span>(ages[<span class="type">string</span>]<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span> : <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问map</span></span><br><span class="line">fmt.<span class="built_in">print</span>(ages[<span class="string">&quot;alice&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;alice&quot;</span>) <span class="comment">// remove element ages[&quot;alice&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作value</span></span><br><span class="line">ages[<span class="string">&quot;bob&quot;</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span> name,age := <span class="keyword">range</span> ages&#123;</span><br><span class="line">    fmt.<span class="built_in">print</span>(<span class="string">&quot;%s\t%d&quot;</span>,name,age)</span><br><span class="line">&#125;<span class="comment">//map的迭代顺序随机。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>K的要求：满足可以==比较的条件</li><li>无法取址：元素不是变量，不能取址</li></ul><h4 id="变量">变量</h4><p>go语言是强类型语言。</p><p><strong>正常声明变量的方法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span>                 <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure><p>其中“<em>类型</em>”或“<em>=表达式</em>”两个部分可以省略其中的一个。</p><ul><li>省略类型：根据初始化表达式来推导变量的类型信息。</li><li>省略表达式：用零值初始化该变量。</li></ul><p><strong>简短声明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名字 := 表达式</span><br></pre></td></tr></table></figure><p>单个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">100</span>   </span><br></pre></td></tr></table></figure><p>一组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>“:=”是一个变量声明语句，而“=”是一个变量赋值操作。</p><h5 id="常量">常量</h5><p>由const定义。</p><h4 id="指针">指针</h4><p>go的指针操作有限。</p><p>对传参进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对变量进行 +1操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(n <span class="type">int</span> )</span></span> &#123;</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">&#125;<span class="comment">//不起作用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1ptr</span><span class="params">(n *<span class="type">int</span>)</span></span> &#123;<span class="comment">//指向一个int类型的指针</span></span><br><span class="line">    *n += <span class="number">1</span></span><br><span class="line">&#125;<span class="comment">//操作实际地址的变量，行得通</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    add1(n)</span><br><span class="line">    fmt.<span class="built_in">print</span>(n)<span class="comment">//1</span></span><br><span class="line">   add1ptr(n)</span><br><span class="line">    fmt.<span class="built_in">print</span>(n)<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数">函数</h4><p>类型后置是go语法的一个特征：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go的原生函数支持函数返回2个值，第一个值是真正的结果，第二个值一般是业务逻辑的错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> v <span class="type">string</span>, ok <span class="type">bool</span>&#123;</span><br><span class="line">    v, ok = m[k]</span><br><span class="line">    <span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体">结构体</h4><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span>&#123;</span><br><span class="line">    name<span class="type">string</span></span><br><span class="line">    password<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体的使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    a := user&#123;name : <span class="string">&quot;wang&quot;</span> , password : <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">    b := &#123; <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">    c := &#123;name : <span class="string">&quot;wang&quot;</span>&#125;</span><br><span class="line">    c.password = <span class="string">&quot;1234&quot;</span></span><br><span class="line">    <span class="keyword">var</span> d user</span><br><span class="line">    d.name = <span class="string">&quot;vls&quot;</span></span><br><span class="line">    d.password = <span class="string">&quot;1024&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序控制语句">程序控制语句</h4><h5 id="条件分支">条件分支</h5><p>if else：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 &#123;</span><br><span class="line">执行逻辑</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> 条件&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面括号可省略、但是后面必须跟同行大括号。</p><p>switch：</p><p>go的switch语句case后面可以跟任何条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> [变量or常量]&#123;</span><br><span class="line">    <span class="keyword">case</span> t.hour() &lt; <span class="number">12</span>:</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不需要写break，不同于c/c++，go的switch是指哪打哪，不会继续往下走。</p><h5 id="循环控制">循环控制</h5><p>go语言里仅有for循环，条件不用再加括号，同行 大括号必备。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span> ; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">    fmt.<span class="built_in">print</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例">案例</h3><h4 id="随机数猜数字案例">随机数——猜数字案例</h4><p>之前的代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">maxNUm := <span class="number">100</span></span><br><span class="line">secretNum := rand.Intn(maxNUm)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Please input your guess&quot;</span>)</span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err!!!&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input = strings.TrimSuffix(input, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">guess, err1 := strconv.Atoi(input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;input err!&quot;</span>, err1)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;your guess is &quot;</span>, guess)</span><br><span class="line"><span class="keyword">if</span> guess &gt; secretNum &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;big!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> guess &lt; secretNum &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;little!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：从系统os里获取reader输入读取对象，然后进行一系列字符串的操作，变量接收等等，能不能简化这一过程呢？</p><h5 id="优化">优化：</h5><p>fmt.Scanf的用法：</p><p>使用<code>fmt.Scanf</code>直接读取用户输入，并且解析为整数。这样就避免了使用<code>bufio.NewReader</code>和字符串处理的过程，代码变得更加简洁。同时，也可以处理输入错误并向用户提供相应的提示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">maxNUm := <span class="number">100</span></span><br><span class="line">secretNum := rand.Intn(maxNUm)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Please input your guess&quot;</span>)</span><br><span class="line"><span class="comment">// reader := bufio.NewReader(os.Stdin)</span></span><br><span class="line"><span class="keyword">var</span> guess <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// input, err := reader.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">_, err := fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;guess)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err!!!&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input = strings.TrimSuffix(input, &quot;\r\n&quot;)</span></span><br><span class="line"><span class="comment">// guess, err := strconv.Atoi(input)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;input err!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> guess &gt; secretNum &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;big!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> guess &lt; secretNum &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;little!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里运行时会出现一个bug：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unexpected newline</span><br></pre></td></tr></table></figure><p>原因：</p><p>scanf换行的时候停止扫描，我们每猜一个数字，都会打一个回车键，然后windows的回车键对应的字符其实是：""，而scanf只是会遇到单纯的""停止，那么前面的"就会出错。直接忽略即可。</p><h2 id="进阶语法">进阶语法</h2><h2 id="依赖管理">依赖管理</h2><h2 id="测试">测试</h2><h2 id="高质量编程">高质量编程</h2><p>编程原则：</p><ul><li>简单</li><li>可读</li><li>高效产出</li></ul><h3 id="编码规范">编码规范</h3><h4 id="代码格式">代码格式</h4><p>可以使用gofmt自动格式化代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gofmt  hello.go　　仅打印代码格式化后的结果</span><br><span class="line">gofmt   project　　格式化并重写project目录下所有 Go 源文件</span><br><span class="line"></span><br><span class="line">-w 参数可以将执行的修改应用的源文件中。</span><br><span class="line">gofmt  -w   filename</span><br><span class="line">    gofmt  -w  hello.go　　会格式化该源文件的代码然后将格式化后的代码覆盖原始内容</span><br><span class="line">    gofmt  -w  *.go格式化并重写所有 Go 源文件</span><br><span class="line"></span><br><span class="line">-r  参数可以对文件内容进行一些简单的替换</span><br><span class="line">    go  -r  &lt;原始内容&gt;  -&gt;  &lt;替换内容&gt;</span><br><span class="line">    gofmt   -r   &#x27;(a) -&gt; a&#x27;   –w   *.go会将源文件中没有意义的括号去掉</span><br><span class="line">    gofmt –r &#x27;A.Func1(a,b) -&gt; A.Func2(b,a)&#x27; –w *.go会将源文件中符合条件的函数的参数调换位置</span><br></pre></td></tr></table></figure><p>gofmt是一个独立的cli程序，而go中还有一个go fmt命令，gofmt命令是gofmt的简单封装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">usage: go fmt [-n] [-x] [packages]</span><br><span class="line"></span><br><span class="line">Fmt runs the command &#x27;gofmt -l -w&#x27; on the packages named</span><br><span class="line">by the import paths. It prints the names of the files that are modified.</span><br><span class="line">For more about gofmt, see &#x27;go doc cmd/gofmt&#x27;.</span><br><span class="line">For more about specifying packages, see &#x27;go help packages&#x27;.</span><br><span class="line">The -n flag prints commands that would be executed.</span><br><span class="line">The -x flag prints commands as they are executed.</span><br><span class="line">To run gofmt with specific options, run gofmt itself.</span><br><span class="line"></span><br><span class="line">See also: go fix, go vet.</span><br></pre></td></tr></table></figure><p>go fmt命令本身只有两个可选参数-n和-x，-n仅打印出内部要执行的gofmt的命令，-x命令既打印出gofmt命令又执行它，如果需要更细化的配置，需要直接执行gofmt命令。</p><h4 id="注释">注释</h4><p>注释应该做什么：</p><ul><li>解释代码作用</li><li>解释代码怎么做</li><li>解释代码为什么这样做</li><li>解释代码在什么情况下会出错</li></ul><p><strong>公共符号的注释必加：</strong></p><ul><li>包中声明的每个公共的符号：<strong>变量、常量、函数以及结构</strong>都需要添加注释</li><li>任何既不明显也不简短的公共功能必须予以注释</li><li>无论长度或复杂程度如何,对库中的任何函数都必须进行注释</li></ul><p>其实本质上我们还是要把代码写好，逻辑写通，命名规范，代码是最好的注释。</p><h4 id="命名规范">命名规范</h4><h5 id="变量-1">变量</h5><p>规范要素：</p><ul><li>尽可能简洁</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写，例如：<ul><li>例如使用ServeHTTP而不是ServeHttp</li><li>使用XMLHTTPRequest 或者xmlHTTPRequest</li></ul></li><li>变量距离其被使用的地方越<strong>远</strong>，则需要携带越多的上下文信息，因为全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义</li></ul><p>案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>...</span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环只有个循环体的情况下，index比i冗余，不易理解。</span><br></pre></td></tr></table></figure><h5 id="函数-1">函数</h5><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的函数名尽量简短</li><li>当名为foo的包某个函数返回类型Foo时，可以省略类型信息而不导致歧义</li><li>当名为foo的包某个函数返回类型T时(T并不是Foo)，可以在函数名中加入类型</li></ul><h5 id="包">包</h5><ul><li><p>只由小写字母组成。不包含大写字母和下划线等字符</p></li><li><p>简短并包含一定的上下文信息。例如schema、task 等</p></li><li><p>不要与标准库同名。例如不要使用sync 或者strings</p></li><li><p>不使用常用变量名作为包名。例如使用bufio 而不是 buf</p></li><li><p>使用单数而不是复数。例如使用encoding而不是encodings</p></li><li><p>谨慎地使用缩写。例如使用fmt在不破坏上下文的情况下比 format更加简短</p></li></ul><h4 id="控制流程">控制流程</h4><p>避免嵌套：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ...&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">直接优化为：</span><br><span class="line"><span class="keyword">if</span> ...&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>保持代码路径最小缩进：</p><p>优先处理错误情况/特殊情况，尽早返回或继续循环来减少嵌套</p><p>原则：</p><ul><li>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</li><li>正常流程代码沿着屏幕向下移动</li><li>提升代码可维护性和可读性</li><li>故障问题大多出现在复杂的条件语句和循环语句中</li></ul><h4 id="错误以及异常处理">错误以及异常处理</h4><h5 id="简单错误">简单错误</h5><ul><li>简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误</li><li>优先使用errors.New来创建匿名变量来直接表示简单错误</li><li>如果有格式化的需求，使用fmt.Errorf</li></ul><h5 id="错误的wrapunwrap">错误的wrap、unwrap</h5><ul><li>错误的Wrap 实际上是提供了一个error嵌套另一个error的能力，从而生成一个error的跟踪链</li><li>在fmt.Errorf中使用:%w关键字来将一个错误关联至错误链中</li></ul><h5 id="错误判定">错误判定</h5><ul><li>判定一个错误是否为特定错误，使用errors.Is<ul><li>不同于使用==，使用该方法可以判定错误链上的所有错误是否含有特定的错误</li></ul></li><li>在错误链上获取特定种类的错误，使用errors.As</li></ul><h5 id="defer语句">defer语句</h5><p>多个defer语句执行顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">( )</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Printf( <span class="string">&quot;1&quot;</span>)<span class="comment">//1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Printf( <span class="string">&quot;2&quot;</span>)<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt .Printf( <span class="string">&quot;3&quot;</span>)<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>先进入栈，随后<span class="number">3</span>进入栈，然后按照后进先出的顺序执行：</span><br><span class="line">结果是<span class="number">31</span></span><br></pre></td></tr></table></figure><h3 id="性能优化">性能优化</h3><h4 id="benchmark工具">BenchMark工具</h4><p><strong>写一个benchmark的基准测试</strong></p><ol type="1"><li>基准测试代码文件必须是_test.go结尾，和单元测试一样；</li><li>基准测试的函数以Benchmark开头；</li><li>参数须为 *testing.B；</li><li>基准测试函数不能有返回值；</li><li>b.ResetTimer是重置计时器，这样可以避免<strong>关键代码</strong>之前的初始化代码的干扰；</li><li>b.N是基准测试框架提供的，Go会根据系统情况生成，不用用户设定，<strong>表示循环的次数</strong>，因为需要反复调用测试的代码，才可以评估性能；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSprint</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">  b.ResetTimer()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    fmt.Sprint(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：go test -bench=. -run=none</p><p>结果分析：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230729220455280.png"alt="image-20230729220455280" /><figcaption aria-hidden="true">image-20230729220455280</figcaption></figure><h4 id="合理使用slice">合理使用slice</h4><h5 id="slice预分配内存">slice预分配内存</h5><p>尽可能在使用make（）的时候，提供容量信息。</p><p>原因：数组容量虽然会自行扩容，但是扩容会增加资源开销。</p><p>扩容过程：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230731111325839.png"alt="image-20230731111325839" /><figcaption aria-hidden="true">image-20230731111325839</figcaption></figure><h5 id="大内存未释放">大内存未释放</h5><ul><li>在已有切片基础上创建切片，不会创建新的底层数组</li><li>场景<ul><li>原切片较大，代码在原切片基础上新建小切片</li><li>原底层数组在内存中有引用，得不到释放</li></ul></li><li>可使用copy替代re-slice</li></ul><h4 id="字符串处理">字符串处理</h4><p>使用strings.Builder</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder strings.Builder;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">        builder.WriteString(str)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用buf</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">        buf.WriteString(str)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能对比</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230731114833532.png"alt="image-20230731114833532" /><figcaption aria-hidden="true">image-20230731114833532</figcaption></figure><p>相比传统利用+进行字符串拼接，使用以上两种方法的效率、性能都很高。</p><h4 id="空结构体使用">空结构体使用</h4><p>使用空结构体节省内存</p><ul><li>空结构体struct{}实例不占据任何的内存空间</li><li>可作为各种场景下的占位符使用<ul><li>节省资源</li><li>空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符</li></ul></li></ul><p>案例：</p><p>实现set的map的第二个数据类型就是采用struct{}占位符操作。</p><h4 id="atomic包">atomic包</h4><p>注意：</p><ul><li>锁的实现是通过操作系统来实现，属于系统调用</li><li>atomic操作是通过硬件实现，效率比锁高</li><li>sync.Mutex应该用来保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值操作，可以使用atomic.Value，能承载一个interface{}</li></ul><h3 id="性能调优实战">性能调优实战</h3><h4 id="性能调优工具pprof">性能调优工具pprof</h4><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230731155349216.png"alt="image-20230731155349216" /><figcaption aria-hidden="true">image-20230731155349216</figcaption></figure><h2 id="httpgo网络框架">HTTP——go网络框架</h2><p>超文本传输协议：（Hypertext Transfer Protocol）。</p><h3 id="协议内容">协议内容</h3><h4 id="常见方法名">常见方法名</h4><ul><li>GET</li><li>HEAD</li><li>POST</li><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTION</li><li>STRACE</li><li>PATCH</li></ul><h4 id="状态码">状态码</h4><p>状态码:</p><ul><li>1xx:信息类</li><li>2xx:成功</li><li>3xx: 重定向</li><li>4xx:客户端错误</li><li>5xx:服务端错误</li></ul><h4 id="请求方法内容">请求方法内容</h4><ul><li>请求行/状态行<ul><li>请求行：方法名、URL、协议版本</li><li>状态行：协议版本、状态码、状态码描述</li></ul></li><li>请求头/响应头<ul><li>业务相关内容</li></ul></li><li>请求体/响应体</li></ul><h3 id="http框架设计">HTTP框架设计</h3><p>怎么设计？</p><ol type="1"><li><p>明确需求:考虑清楚要解决什么问题、有哪些需求</p></li><li><p>业界调研:业界都有哪些解决方案可供参考</p></li><li><p>方案权衡:思考不同方案的取舍</p></li><li><p>方案评审:相关同学对不同方案做评审</p></li><li><p>确定开发:确定最合适的方案进行开发</p></li></ol><h4 id="分层设计">分层设计</h4><p>OSI参考模型</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230805110352870.png"alt="image-20230805110352870" /><figcaption aria-hidden="true">image-20230805110352870</figcaption></figure><p>分层设计架构图</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230805113053536.png"alt="image-20230805113053536" /><figcaption aria-hidden="true">image-20230805113053536</figcaption></figure><p>盖尔定律：一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。</p><h5 id="应用层">应用层</h5><ul><li>提供合理API<ul><li>易理解</li><li>简单</li></ul></li></ul><h5 id="中间件">中间件</h5><ul><li>配合Handler实现一个完整的请求处理生命周期</li><li>拥有预处理逻辑与后处理逻辑<ul><li>相当于调用方法，AOP思想</li></ul></li><li>可以注册多中间件</li><li>对上层模块用户逻辑模块易用</li></ul><p>遵循洋葱模型：</p><p><img src="2023年7至8月第六届字节青训营学习记录/image-20230805113435637.png" alt="image-20230805113435637" style="zoom:67%;" /></p><p>模型适用创建：</p><ul><li>日志</li><li>性能监控</li><li>事务处理</li><li>异常处理</li></ul><h5 id="路由设计">路由设计</h5><p>URI是URL的父级。</p><p>URL：完整的链接</p><p>URI：服务资源相对路径</p><p>框架路由实际上就是为<strong>URL</strong>匹配对应的处理函数（Handlers)</p><ul><li>静态路由:/a/b/c、/a/b/d</li><li>参数路由:/a/ :id/c (/a/b/c，/a/d/c)、/*all</li><li>路由修复:/a/b &lt;-&gt; /a/b/</li><li>冲突路由以及优先级:/a/b、/ :id/c</li><li>匹配 HTTP方法</li><li>多处理函数:方便添加中间件</li></ul><h6 id="路由匹配算法">路由匹配算法</h6><p>前缀树</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230805114134292.png"alt="image-20230805114134292" /><figcaption aria-hidden="true">image-20230805114134292</figcaption></figure><h6 id="匹配http方法">匹配http方法</h6><p>路由映射表：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230805114254660.png"alt="image-20230805114254660" /><figcaption aria-hidden="true">image-20230805114254660</figcaption></figure><p>根据method进行http方法筛选。</p><h5 id="协议层设计">协议层设计</h5><p>抽象出合适的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">interface</span>&#123;</span><br><span class="line">    Serve(c context.Context, conn network.Conn) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="网络层设计">网络层设计</h5><h6 id="bio">BIO</h6><p>阻塞IO：如果未接收到信息，会一直等待。</p><p>执行逻辑：接收到连接请求过后，生成一个goRoutine去等待客户端响应（忙等）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        conn,_ := listener.Accept()</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            conn.Read(request)</span><br><span class="line">            </span><br><span class="line">            handler</span><br><span class="line">            </span><br><span class="line">            conn.Write(response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go net</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read</span><br><span class="line">    Write</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="nio">NIO</h6><p>改进阻塞状态，注册监听器监听：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        readableConns, _ := Monitor(conns)</span><br><span class="line">        <span class="keyword">for</span> conn := <span class="keyword">range</span> readableConns&#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">                conn.Read(request)</span><br><span class="line"></span><br><span class="line">                handler</span><br><span class="line"></span><br><span class="line">                conn.Write(response)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多路复用。</p><p>netpoll</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span>&#123;</span><br><span class="line">    Peek(n <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Write <span class="keyword">interface</span>&#123;</span><br><span class="line">    Malloc()</span><br><span class="line">    Flush</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络与部署">网络与部署</h2><h3 id="打开抖音会发生什么">打开抖音会发生什么</h3><h4 id="网络接入">网络接入</h4><h5 id="互联网模型">互联网模型</h5><p><img src="2023年7至8月第六届字节青训营学习记录/image-20230806091922545.png" alt="image-20230806091922545" style="zoom:67%;" /></p><h5 id="路由">路由</h5><p>路由的非对称性：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230806094328262.png"alt="image-20230806094328262" /><figcaption aria-hidden="true">image-20230806094328262</figcaption></figure><p>所谓对称性就是指：你沿着一条路路由到终点，但是返回的路不一定是同一条。</p><p>路由工作在网络层，通过修改源地址传输的包文件中的<strong>MAC地址</strong>来为其导航。</p><h5 id="arp协议">ARP协议</h5><p>在当前服务器或者路由结点上，发送广播到相邻的服务器端，寻找下一跳MAC地址（并不是最终地址）。</p><h5 id="ip协议">IP协议</h5><p>服务器唯一一个</p><p>客户端唯一一个。</p><h5 id="nat">NAT</h5><p>工作流程：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230806100551958.png"alt="image-20230806100551958" /><figcaption aria-hidden="true">image-20230806100551958</figcaption></figure><h4 id="网络传输">网络传输</h4><h5 id="数据包">数据包</h5><p>客户端发到服务器的包全流程</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230806100854790.png"alt="image-20230806100854790" /><figcaption aria-hidden="true">image-20230806100854790</figcaption></figure><h5 id="dns">DNS</h5><p>发送的请求先通过DNS解析：</p><ol type="1"><li>客户端发起访问www.baidu.com的请求</li><li>本地DNS先向<strong>根服务器</strong> . 询问，域名在哪</li><li>根把顶级域名服务器com. 地址告诉本地DNS，让本地DNS去访问</li><li>顶级域名服务器把权威服务器 com.baidu 告诉本地DNS让它去访问</li><li>最后权威服务器把真实的ip地址</li></ol><p><img src="2023年7至8月第六届字节青训营学习记录/image-20230806101217228.png" alt="image-20230806101217228" style="zoom:67%;" /></p><h6 id="dns传输协议udp">DNS传输协议UDP</h6><p>UDP包：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230806101625185.png"alt="image-20230806101625185" /><figcaption aria-hidden="true">image-20230806101625185</figcaption></figure><p>保证UDP协议可靠？</p><p>①超时重传（定时器）</p><p>②有序接受（添加包序号）将数据包进行编号，按照包的顺序接收并存储。</p><p>③应答确认 （Seq/Ack应答机制）</p><p>④滑动窗口流量控制等机制 （滑动窗口协议）</p><h2 id="gorm框架">gorm框架</h2><p>Gorm是一个已经迭代了10年+的功能强大的ORM框架，拥有非常丰富的开源扩展。</p><p>特征：</p><ul><li>全功能ORM</li><li>关联（包含一个，包含多个，属于，多对多）</li><li>Callbacks（创建/保存/更新/删除/查找前后回调）</li><li>预加载</li><li>事务</li><li>复合主键</li><li>SQL Builder（执行原生sql）</li><li>自动迁移</li><li>日志</li></ul><h3 id="gorm的基本使用">gorm的基本使用</h3><ol type="1"><li><p>定义gorm model</p><p>第二个为详细定义，格式固定为<code>gorm:"column : 设置/值"</code>，感觉已经赶得上建表语句了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span>&#123;</span><br><span class="line">    Code <span class="type">string</span></span><br><span class="line">    Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">//string默认长度255,size重设长度</span></span><br><span class="line">  Age <span class="type">int</span> <span class="string">`gorm:&quot;column:my_age&quot;`</span> <span class="comment">//设置列名为my_age</span></span><br><span class="line">  Num <span class="type">int</span>  <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">//自增</span></span><br><span class="line">  IgnoreMe <span class="type">int</span> <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略字段</span></span><br><span class="line">  Email <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;//type设置sql类型，unique_index为该列设置唯一索引`</span></span><br><span class="line">  Address <span class="type">string</span> <span class="string">`gorm:&quot;not null;unique&quot;`</span> <span class="comment">//非空</span></span><br><span class="line">  no <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_no&quot;`</span> <span class="comment">// 创建索引并命名，如果有其他同名索引，则创建组合索引</span></span><br><span class="line">  code <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_no&quot;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  Profile Profile <span class="string">`gorm:&quot;ForeignKey:ProfileID;AssociationForeignKey:Refer&quot;`</span> <span class="comment">//设置外键</span></span><br><span class="line">  ProfileID <span class="type">int</span></span><br><span class="line">  remark <span class="type">string</span> <span class="string">`gorm:&quot;default:&#x27;test&#x27;&quot;`</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给model绑定表名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Product)</span></span> TableName() <span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>连接数据库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(</span><br><span class="line">    mysql.Open(<span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>),</span><br><span class="line">    &amp;gorm.Config&#123;&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增删改查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加</span></span><br><span class="line">db.Create(&amp;Product&#123;</span><br><span class="line">Code : <span class="string">&quot;666&quot;</span>,</span><br><span class="line">    Price : <span class="number">20</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">db.First(&amp;Product, <span class="number">1</span>)<span class="comment">//根据整形主键查找</span></span><br><span class="line">db.First(&amp;Product, <span class="string">&quot;code = ? &quot;</span> , <span class="string">&quot;D42&quot;</span>)</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">db.Model(&amp;Product).Update(<span class="string">&quot;Price&quot;</span>, <span class="number">200</span>)</span><br><span class="line">db.Model(&amp;Product).Updates(Product&#123;Price : <span class="number">200</span>, Code : <span class="string">&quot;666&quot;</span>&#125;)</span><br><span class="line">db.Model(&amp;Product).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Price&quot;</span>:<span class="number">200</span>, <span class="string">&quot;Code&quot;</span> : <span class="string">&quot;666&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">db.<span class="built_in">delete</span>(&amp;Product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="增">增</h4><p>唯有create方法需要&amp;符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"></span><br><span class="line">db.NewRecord(user) <span class="comment">// =&gt; 主键为空返回`true`</span></span><br><span class="line"></span><br><span class="line">db.Create(&amp;user)</span><br><span class="line"></span><br><span class="line">db.NewRecord(user) <span class="comment">// =&gt; 创建`user`后返回`false`</span></span><br></pre></td></tr></table></figure><p>创建多条：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">users := []*User&#123;&#123;Name: <span class="string">&quot;Jin2zhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;,&#123;Name: <span class="string">&quot;Jin1zhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;&#125;</span><br><span class="line"></span><br><span class="line">db.Create(users)</span><br></pre></td></tr></table></figure><h4 id="删">删</h4><p>删除</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除存在的记录</span></span><br><span class="line">db<span class="selector-class">.Delete</span>(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10;</span></span><br></pre></td></tr></table></figure><h5 id="批量删除">批量删除</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.Where</span>(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)<span class="selector-class">.Delete</span>(Email&#123;&#125;)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinhu%&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.Delete</span>(Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinhu%&quot;;</span></span><br></pre></td></tr></table></figure><h5 id="软删除">软删除</h5><p>如果模型有DeletedAt字段，删除时是软删除</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.Delete</span>(&amp;user)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db<span class="selector-class">.Where</span>(&quot;age = ?&quot;, <span class="number">20</span>)<span class="selector-class">.Delete</span>(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软删除的记录将在查询时被忽略</span></span><br><span class="line">db<span class="selector-class">.Where</span>(&quot;age = <span class="number">20</span>&quot;)<span class="selector-class">.Find</span>(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Unscoped查找软删除的记录</span></span><br><span class="line">db<span class="selector-class">.Unscoped</span>()<span class="selector-class">.Where</span>(&quot;age = <span class="number">20</span>&quot;)<span class="selector-class">.Find</span>(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Unscoped永久删除记录</span></span><br><span class="line">db<span class="selector-class">.Unscoped</span>()<span class="selector-class">.Delete</span>(&amp;order)</span><br><span class="line"><span class="comment">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure><h4 id="改">改</h4><p>更新全部字段 Save</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line">user.Name <span class="operator">=</span> &quot;jinzhu 2&quot;</span><br><span class="line">user.Age <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">db.Save(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;jinzhu 2&#x27;</span>, age<span class="operator">=</span><span class="number">100</span>, birthday<span class="operator">=</span><span class="string">&#x27;2016-01-01&#x27;</span>, updated_at <span class="operator">=</span> <span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>更新更改字段 Update Updates</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 更新单个属性（如果更改）</span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">//// UPDATE <span class="built_in">users</span> SET name=<span class="string">&#x27;hello&#x27;</span>, updated_at=<span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> WHERE <span class="built_in">id</span>=111;</span><br><span class="line"></span><br><span class="line">// 使用组合条件更新单个属性</span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">//// UPDATE <span class="built_in">users</span> SET name=<span class="string">&#x27;hello&#x27;</span>, updated_at=<span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> WHERE <span class="built_in">id</span>=111 AND active=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 使用`map`更新多个属性，只会更新这些更改的字段</span><br><span class="line">db.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: 18, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">//// UPDATE <span class="built_in">users</span> SET name=<span class="string">&#x27;hello&#x27;</span>, age=18, actived=<span class="literal">false</span>, updated_at=<span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> WHERE <span class="built_in">id</span>=111;</span><br><span class="line"></span><br><span class="line">// 使用`struct`更新多个属性，只会更新这些更改的和非空白字段</span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: 18&#125;)</span><br><span class="line">//// UPDATE <span class="built_in">users</span> SET name=<span class="string">&#x27;hello&#x27;</span>, age=18, updated_at = <span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> WHERE <span class="built_in">id</span> = 111;</span><br><span class="line"></span><br><span class="line">// 警告:当使用struct更新时，FORM将仅更新具有非空值的字段</span><br><span class="line">// 对于下面的更新，什么都不会更新为<span class="string">&quot;&quot;</span>，0，<span class="literal">false</span>是其类型的空白值</span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;&quot;</span>, Age: 0, Actived: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>更新选择字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(map[string]interface&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: 18, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">//// UPDATE <span class="built_in">users</span> SET name=<span class="string">&#x27;hello&#x27;</span>, updated_at=<span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> WHERE <span class="built_in">id</span>=111;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(map[string]interface&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: 18, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">//// UPDATE <span class="built_in">users</span> SET age=18, actived=<span class="literal">false</span>, updated_at=<span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> WHERE <span class="built_in">id</span>=111;</span><br></pre></td></tr></table></figure><h5 id="使用sql表达式更新">使用sql表达式更新</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DB.Model(&amp;product).Update(<span class="string">&quot;price&quot;</span>, gorm.Expr(<span class="string">&quot;price * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line">//// UPDATE <span class="string">&quot;products&quot;</span> <span class="built_in">SET</span> <span class="string">&quot;price&quot;</span> = price * <span class="string">&#x27;2&#x27;</span> + <span class="string">&#x27;100&#x27;</span>, <span class="string">&quot;updated_at&quot;</span> = <span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="built_in">WHERE</span> <span class="string">&quot;id&quot;</span> = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).Updates(map[<span class="built_in">string</span>]interface&#123;&#125;&#123;<span class="string">&quot;price&quot;</span>: gorm.Expr(<span class="string">&quot;price * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line">//// UPDATE <span class="string">&quot;products&quot;</span> <span class="built_in">SET</span> <span class="string">&quot;price&quot;</span> = price * <span class="string">&#x27;2&#x27;</span> + <span class="string">&#x27;100&#x27;</span>, <span class="string">&quot;updated_at&quot;</span> = <span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="built_in">WHERE</span> <span class="string">&quot;id&quot;</span> = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).UpdateColumn(<span class="string">&quot;quantity&quot;</span>, gorm.Expr(<span class="string">&quot;quantity - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line">//// UPDATE <span class="string">&quot;products&quot;</span> <span class="built_in">SET</span> <span class="string">&quot;quantity&quot;</span> = quantity - <span class="number">1</span> <span class="built_in">WHERE</span> <span class="string">&quot;id&quot;</span> = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">DB.Model(&amp;product).Where(<span class="string">&quot;quantity &gt; 1&quot;</span>).UpdateColumn(<span class="string">&quot;quantity&quot;</span>, gorm.Expr(<span class="string">&quot;quantity - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line">//// UPDATE <span class="string">&quot;products&quot;</span> <span class="built_in">SET</span> <span class="string">&quot;quantity&quot;</span> = quantity - <span class="number">1</span> <span class="built_in">WHERE</span> <span class="string">&quot;id&quot;</span> = <span class="string">&#x27;2&#x27;</span> AND quantity &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="查">查</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录，按主键排序</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录，按主键排序</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用主键获取记录</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure><p>First踩坑注意：</p><ul><li>使用 First时，需要注意查询不到数据会返回ErrRecordNotFound。</li><li>使用Find查询多条数据，查询不到数据不会返回错误。</li></ul><h5 id="where条件查询">where条件查询</h5><p>where简单sql</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一个匹配记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有匹配记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name in (?)&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>where(struct &amp; Map)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主键的Slice</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><h5 id="not条件查询">not条件查询</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h5 id="select">select</h5><p>从数据库检索字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;<span class="built_in">users</span>)</span><br><span class="line">//// SELECT name, age FROM <span class="built_in">users</span>;</span><br><span class="line"></span><br><span class="line">db.Select([]string&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;<span class="built_in">users</span>)</span><br><span class="line">//// SELECT name, age FROM <span class="built_in">users</span>;</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;COALESCE(age,?)&quot;</span>, 42).Rows()</span><br><span class="line">//// SELECT COALESCE(age,<span class="string">&#x27;42&#x27;</span>) FROM <span class="built_in">users</span>;</span><br></pre></td></tr></table></figure><h5 id="order">Order</h5><p>从数据库检索记录时指定顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Order(&quot;age desc, name&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">desc</span>, name;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Multiple orders</span><br><span class="line">db.Order(&quot;age desc&quot;).<span class="keyword">Order</span>(&quot;name&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">desc</span>, name;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ReOrder</span><br><span class="line">db.Order(&quot;age desc&quot;).Find(<span class="operator">&amp;</span>users1).<span class="keyword">Order</span>(&quot;age&quot;, <span class="literal">true</span>).Find(<span class="operator">&amp;</span>users2)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">desc</span>; (users1)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age; (users2)</span><br></pre></td></tr></table></figure><h5 id="limit">Limit</h5><p>指定要检索的记录数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.Limit</span>(<span class="number">3</span>)<span class="selector-class">.Find</span>(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel limit condition with -1</span></span><br><span class="line">db<span class="selector-class">.Limit</span>(<span class="number">10</span>)<span class="selector-class">.Find</span>(&amp;users1)<span class="selector-class">.Limit</span>(-<span class="number">1</span>)<span class="selector-class">.Find</span>(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure><h5 id="offset">Offset</h5><p>指定在开始返回记录之前要跳过的记录数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.Offset</span>(<span class="number">3</span>)<span class="selector-class">.Find</span>(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users OFFSET 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel offset condition with -1</span></span><br><span class="line">db<span class="selector-class">.Offset</span>(<span class="number">10</span>)<span class="selector-class">.Find</span>(&amp;users1)<span class="selector-class">.Offset</span>(-<span class="number">1</span>)<span class="selector-class">.Find</span>(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure><h5 id="count">Count</h5><p>获取模型的记录数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>).Find(&amp;users).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT * from USERS WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (users)</span></span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM deleted_users;</span></span><br></pre></td></tr></table></figure><h5 id="group-having">Group &amp; Having</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Date  time.Time</span><br><span class="line">    Total <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Scan(&amp;results)</span><br></pre></td></tr></table></figure><h5 id="join">Join</h5><p>指定连接条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个连接与参数</span></span><br><span class="line">db.Joins(<span class="string">&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;</span>, <span class="string">&quot;jinzhu@example.org&quot;</span>).Joins(<span class="string">&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;</span>).Where(<span class="string">&quot;credit_cards.number = ?&quot;</span>, <span class="string">&quot;411111111111&quot;</span>).Find(&amp;user)</span><br></pre></td></tr></table></figure><h4 id="原生sql构建">原生sql构建</h4><p>执行原生sql</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Exec(<span class="string">&quot;DROP TABLE users;&quot;</span>)</span><br><span class="line">db.Exec(<span class="string">&quot;UPDATE orders SET shipped_at=? WHERE id IN (?)&quot;</span>, time.Now, []<span class="type">int64</span>&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Raw(<span class="string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure><p>sql.Row &amp; sql.Rows</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">row := db.Table(<span class="string">&quot;users&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Row() <span class="comment">// (*sql.Row)</span></span><br><span class="line">row.Scan(&amp;name, &amp;age)</span><br><span class="line"></span><br><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Select(<span class="string">&quot;name, age, email&quot;</span>).Rows() <span class="comment">// (*sql.Rows, error)</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw SQL</span></span><br><span class="line">rows, err := db.Raw(<span class="string">&quot;select name, age, email from users where name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Rows() <span class="comment">// (*sql.Rows, error)</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3)迭代中使用sql.Rows的Scan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Select(<span class="string">&quot;name, age, email&quot;</span>).Rows() <span class="comment">// (*sql.Rows, error)</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  db.ScanRows(rows, &amp;user)</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务">事务</h4><p>Gorm提供了Begin、Commit、Rollback方法用于使用事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAnimals</span><span class="params">(db *gorm.DB)</span></span> err &#123;</span><br><span class="line">  tx := db.Begin()</span><br><span class="line">  <span class="comment">// 注意，一旦你在一个事务中，使用tx作为数据库句柄</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">     tx.Rollback()</span><br><span class="line">     <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">     tx.Rollback()</span><br><span class="line">     <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tx.Commit()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，在一个事务中，使用tx作为数据库句柄</li></ul><h4 id="hook">Hook</h4><p>GORM在提供了CURD的Hook 能力。</p><p>Hook是在创建、查询、更新、删除等操作之前、之后自动调用的函数。</p><p>如果任何Hook返回错误，GORM将停止后续的操作并回滚事务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID<span class="type">int64</span></span><br><span class="line">Name<span class="type">string</span> <span class="string">&#x27;gorm : &quot;default: galeone&quot;`</span></span><br><span class="line"><span class="string">Ageint64 `gorm : &quot;default:18&quot;`</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type Email struct &#123;</span></span><br><span class="line"><span class="string">IDint64</span></span><br><span class="line"><span class="string">Name string</span></span><br><span class="line"><span class="string">    Email string</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func (u *User) BeforeCreate(tx *gorm.DB) (err error)&#123;</span></span><br><span class="line"><span class="string">    if u.Age &lt; 0&#123;</span></span><br><span class="line"><span class="string">        return errors.New(&quot;con&#x27;</span>t save invalid data<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func (u *User) AfterCreate(tx *gorm.DB) (err error)&#123;</span></span><br><span class="line"><span class="string">    return tx.Create(&amp;Email&#123;ID : u.ID, Email : u.Name + &quot;</span>@***.com<span class="string">&quot;&#125;).Error</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="项目连接案例">项目连接案例</h3><p>gorm核心：用于初始化数据库连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> core</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GormLogger 包裹zap的SugaredLogger作为Gorm的Logger</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> GormLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">Logger *zap.SugaredLogger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gl GormLogger)</span></span> Printf(s <span class="type">string</span>, i ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">gl.Logger.Infof(strings.ReplaceAll(s, <span class="string">&quot;\u001b&quot;</span>, <span class="string">&quot; &quot;</span>), i...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">initGormMysql 初始化mysql连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initGormMysql</span><span class="params">()</span></span> &#123;</span><br><span class="line">mysqlConfig := config.DefaultConfiguration.Datasource.Mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">//将zap的WriteSyncer作为Gorm的日志输出位置</span></span><br><span class="line">gormLogger := logger.New(GormLogger&#123;Logger: global.Logger&#125;, logger.Config&#123;</span><br><span class="line">SlowThreshold:             <span class="number">200</span> * time.Millisecond,</span><br><span class="line">LogLevel:                  logger.Info,</span><br><span class="line">IgnoreRecordNotFoundError: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">//必须关闭，否则日志输出会乱码</span></span><br><span class="line">Colorful: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">datasource, err := gorm.Open(mysql.Open(mysqlConfig.DSN), &amp;gorm.Config&#123;</span><br><span class="line">Logger: gormLogger,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">mysqlDb, err := datasource.DB()</span><br><span class="line">mysqlDb.SetMaxIdleConns(mysqlConfig.MaxIdleConnections)</span><br><span class="line">mysqlDb.SetMaxOpenConns(mysqlConfig.MaxOpenConnections)</span><br><span class="line">mysqlDb.SetConnMaxLifetime(time.Duration(mysqlConfig.ConnectionMaxLifetime) * time.Second)</span><br><span class="line"><span class="keyword">if</span> err = mysqlDb.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">global.Datasource = datasource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接相关属性配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Datasource <span class="keyword">struct</span> &#123;</span><br><span class="line">Mysql *Mysql</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mysql <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//DSN 为datasource name 格式为&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">DSN <span class="type">string</span></span><br><span class="line"><span class="comment">//最大空闲连接数</span></span><br><span class="line">MaxIdleConnections <span class="type">int</span></span><br><span class="line"><span class="comment">//最大开启连接数</span></span><br><span class="line">MaxOpenConnections <span class="type">int</span></span><br><span class="line"><span class="comment">//连接最大存活时间 秒</span></span><br><span class="line">ConnectionMaxLifetime <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultDataSource = &amp;Datasource&#123;</span><br><span class="line">Mysql: &amp;Mysql&#123;</span><br><span class="line">DSN:                   <span class="string">&quot;root:********@tcp(192.168.200.129:3306)/tiktok?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">MaxIdleConnections:    <span class="number">10</span>,</span><br><span class="line">MaxOpenConnections:    <span class="number">20</span>,</span><br><span class="line">ConnectionMaxLifetime: <span class="number">300</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAO层的使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveVideoInfo</span><span class="params">(video *entity.Video)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">res := global.Datasource.Table(<span class="string">&quot;video&quot;</span>).Create(&amp;video)</span><br><span class="line"><span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">global.Logger.Error(res.Error)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库相关概念">数据库相关概念</h3><p>支持的数据库：MySQL、SQLServer、PostgreSQL、SQLite。</p><p><strong>数据库的DSN：</strong></p><p>是一种名称（数据来源名称），应用程序用来请求与 ODBC数据源连接的名称，它会存储连接详细信息，例如数据库名称、目录、数据库驱动程序、UserID、密码等。</p><p>数据库建立好之后，要设定系统的DSN（数据来源名称），才能让网页可以知道数据库所在的位置以及数据库相关的属性。</p><h2 id="对象存储">对象存储</h2><p>特性：</p><ul><li>易用</li><li>廉价</li><li>海量存储</li></ul><p>易用性：</p><p><img src="2023年7至8月第六届字节青训营学习记录/image-20230816231308836.png" alt="image-20230816231308836" style="zoom:80%;" /></p><p>对象存储服务提供的接口：</p><ul><li>GET：下载</li><li>HEAD：查看对象元信息</li><li>PUT：上传对象</li><li>DELETE：删除对象</li></ul><p>Bucket/Object语义</p><ul><li>Bucket:存储对象的桶，可类比一个云上的Map</li><li>Object:对象，包含如下三个部分<ul><li>Key:对象的名字，可类比Map的Key</li><li>Data:对象的内容，例如视频/图片内容</li><li>MetaData:对象的一些元信息，如对象大小，对</li><li>象Content-Type，也可以存储自定义元信息</li></ul></li></ul><h3 id="对象存储tos的使用">对象存储TOS的使用</h3><p>restful风格：</p><p><img src="2023年7至8月第六届字节青训营学习记录/image-20230816232005545.png" alt="image-20230816232005545" style="zoom:67%;" /></p><h4 id="multiupload接口">MultiUpload接口</h4><p>执行流程：</p><p><img src="2023年7至8月第六届字节青训营学习记录/image-20230816232107761.png" alt="image-20230816232107761" style="zoom:67%;" /></p><p>lnitUpload:</p><ul><li>参数: Bucket, Key</li><li>返回: Uploadld</li></ul><p>UploadPart</p><ul><li>参数: Uploadld,Partld ,Part</li><li>内容返回:成功/失败</li></ul><p>CompleteUpload :</p><ul><li>参数:Uploadld,Partld Array</li><li>返回:成功/失败</li></ul><h4 id="listprefix接口">Listprefix接口</h4><p>ListPrefix参数:</p><p>prefix: key前缀</p><p>delimiter:分隔符，默认为/</p><p>max-keys:本次分页数量</p><p>start-after:分页起始对象Key</p><p>ListPrefix返回: common-prefix:共同前缀</p><p>objects:对象key列表</p><p>isTruncated:是否已经列举完</p><h2 id="网络安全概述">网络安全概述</h2><p>常见的安全事件</p><p><strong>数据泄漏</strong>国公共卫生系统公布了一起大规模数据泄露事件，超130万人受到该事件影响。入侵网站的黑客可获取到病人的个人信息，其中包括病人的出生日期、家庭住址等。</p><p><strong>服务瘫痪</strong>某老牌航空公司因遭黑客攻击，官网出现技术性故障，整个系统突然崩溃中断。当天几乎所有航班均被延误,后续超188个航班受到影响。</p><p><strong>成果失窃</strong>某芯片制造巨头被爆逋到勒索软件攻击，入侵者成功访问并在线泄露了员工私密信息及登录数据,黑客宣称可以访问1TB的企业数据。</p><p><strong>系统劫持</strong>某国导弹袭击警报响彻云霄，持续了几乎一个小时，疑为网络攻击引发的误报。</p><p><strong>蓝军</strong></p><p>反向验证企业内部安全现状,以攻促防</p><p><strong>红军</strong></p><p>系统建设时候帮助企业提前规避漏洞</p><h3 id="服务端漏洞">服务端漏洞</h3><h4 id="第三方组件漏洞">第三方组件漏洞</h4><p>导入的第三方组件可能存在bug或者系统漏洞，会破坏我们系统的安全。</p><p>解决：</p><p>java中可以选择使用dependency-check-maven检查项目以来的组件是否存在安全漏洞</p><h4 id="sql注入">SQL注入</h4><ol type="1"><li><p>错误使用语言框架，或者框架本身存在安全问题</p><p>使用Mybatis-plus的危险函数，比如inSql，支持直接SQL拼接，存在SQL注入风险。</p></li><li><p>mybatis使用$构建SQL模板</p><p>使用「$」，实际的SQL语句:<code>SELECT id,name,pwd,age FROM t_user_info WHERE id = 'xx'</code>会存在sql注入风险。</p><p>而使用#就不会出现，因为用了？作为参数占位符：</p><p>使用「#」，实际的SQL语句:<code>SELECT id,name,pwd,age FROM t_user_info WHERE id = ?</code></p></li><li><p>go中常见错误写法。</p><p>业务场景经常遇到根据用户定义的字段进行排序的功能，如果直接将用户输入字段作为维度带到Order则会产生sQL注入，假设GORM语句为:db.Order(param).Find(&amp;products)</p><p>正常情况用户输入维度字段即可实现自定义排序</p><p>param: codeSQL语句:<code>SELECT * FROM products WHERE products . deleted_atIS NULL ORDER BY code</code></p><p>攻击者可以输入sql语句来实现sql注入：</p><p>param: if(1, sleep(10),'code') SOL语句:<code>SELECT* FROM productsWHEREproducts deleted_at lS NULORDER BY if(1, sleep(10), 'code')</code></p></li></ol><p>防护方式：</p><ul><li>尽量不要基于DB的Raw方法拼接构造SQL语句，而应该使用预编译、ORM框架</li><li>使用ORM框架时，应该注意框架中的特性，可能存在不安全的写法导致的SQL注入问题。</li><li>在复杂场景一定要使用拼接SQL，需要对外部输入进行转义。</li></ul><h4 id="命令执行">命令执行</h4><p>代码中遇到需要调用某个命令才能完成的功能时候，会涉及到命令拼接，如果命令拼接没有做好安全过滤，那么将会导致命令注入风险，服务器权限将会被控制</p><p>防护方式：</p><ol type="1"><li>对动态的值尽可能设置白名单进行验证。</li><li>如果某些位置无法白名单，需要尝试对数据类型进行校验。</li><li>特殊字符黑名单的过滤，或者转义。</li></ol><h4 id="越权漏洞">越权漏洞</h4><p><strong>认证</strong>：你是谁</p><p><strong>授权</strong>：你能做什么？</p><p><strong>越权</strong>：越过权限去做自己不能做的事</p><p><strong>未授权：</strong></p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825150055160.png"alt="image-20230825150055160" /><figcaption aria-hidden="true">image-20230825150055160</figcaption></figure><p><strong>水平越权：</strong></p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825150108119.png"alt="image-20230825150108119" /><figcaption aria-hidden="true">image-20230825150108119</figcaption></figure><p>防护方式:涉及资源id尽量不要使用短id(遍历难度较小)，同时最重要的一定要做好<strong>资源属主校验</strong>（资源属于谁）</p><p><strong>垂直越权</strong>：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825150119178.png"alt="image-20230825150119178" /><figcaption aria-hidden="true">image-20230825150119178</figcaption></figure><p>黑灰产场景:攻击者可以通过开通另外的测试管理员账户抓包获取接口，或者通过逆向前端代码方式获取实际接口，然后绕过前端直接尝试访问后端接口，获取数据详情。</p><p>防护方式:如果是简单的场景，可以将接口在路由级别进行分组，对不同的API分组引入Middleware进行权限拦截,Middleware获取当前用户角色以确定是否可以访问此接口。</p><h4 id="ssrf">SSRF</h4><p>SSRF又称服务端请求伪造攻击，指攻击者利用后端服务器为跳板，让后端服务<strong>向非预期网络地址（主要指内网地址)发出恶意请求，获取敏感信息</strong>或执行恶意操作。</p><p>SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。主要攻击方式如下所示。</p><ul><li>对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>攻击运行在内网或本地的应用程序。</li><li>对内网Web应用进行指纹识别，识别企业内部的资产信息。</li><li>攻击内外网的Web应用，主要是使用HTTPGET请求就可以实现的攻击(比如struts2、SQli等)。</li><li>利用file协议读取本地文件等。</li></ul><p>参考文章：<ahref="https://www.cnblogs.com/miruier/p/13907150.html">SSRF漏洞（原理、挖掘点、漏洞利用、修复建议）- Saint_Michael - 博客园 (cnblogs.com)</a></p><h4 id="文件上传漏洞">文件上传漏洞</h4><p>找到公开的上传点(如视频创作/文章创作/客服反馈等)，上传恶意文件（恶意视频、图片)，获取图片url，然后直接分享url至外部恶意网站或QQ/微信群。</p><p>防护方案:</p><ol type="1"><li><p>限制文件类型:如果系统只需要图片类型，可以从服务端解析文件格式，限制只能传入特定的文件格式。</p></li><li><p>站库分离:应用部署的位置和上传的文件分离，一般可以使用TOS、OSs等进行文件存储。</p></li><li><p>防止图床:对图片访问链接进行限制，包括时间限制，访问身份限制等。</p></li></ol><p>​</p><h3 id="客户端漏洞">客户端漏洞</h3><h4 id="开放重定向">开放重定向</h4><p>开放重定向:某些需要重定向到其他站点的功能，往往在参数中携带需要重定向的URL，但实际程序逻辑没有控制好重定向的范围，导致攻击者可以构造恶意链接，诱导用户重定向到恶意站点。</p><p>危害:钓鱼攻击。</p><p>修复方案:对重定向严格进行白名单控制并正确校验匹配白名单。</p><h4 id="xss">XSS</h4><p>跨站脚本(XSS)攻击:本质是一种Script代码注入,攻击者往目标Web页面里插入恶意Script代码,当用户访问页面(有客户端时需要交互)时，嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>场景:反射型,存储型,Dom型</p><p>危害:通常的危害包括窃取用户敏感信息，以用户身份执行敏感操作。</p><p>案例：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825155529331.png"alt="image-20230825155529331" /><figcaption aria-hidden="true">image-20230825155529331</figcaption></figure><ol type="1"><li>构造恶意链接，将username设置为恶意payload</li><li>攻击者通过网站反馈入口，向管理员/运营人员发送恶意链接。</li><li>攻击者的服务器成功收到管理员/运营人员的Session Cookie。</li><li>浏览器替换cookie为管理员的,获取管理员权限。</li></ol><p>防护方法:</p><ol type="1"><li>输入过滤:对输入的特殊字符进行拦截，禁止前端提交特殊字符</li><li>输出过滤:<ol type="a"><li>当字符输出到Dom时候，对危险字符进行html encode，避免XSS。</li><li>使用vue/react等框架时候，避免使用危险指令，而应该使用安全指令。v-htmI/v-text</li></ol></li><li>富文本场景:比如文章发布场景，本身是需要提供富文本功能，这时候需要严格限制tag和attribute，可以在代码层面做白名单或者黑名单。<tag attribute1='valuel' attribute2='value2'/></li><li>CSP:用于缓解XSS，理念是对当前站点允许加载什么源的资源、发送什么请求能进行限制。<code>Content-Security-Policy: default-src 'self; img-src *; media-src example.org example.net;script-src userscripts.example.com</code></li></ol><h4 id="csrf">CSRF</h4><p>跨站请求伪造(CSRF):允许攻击者<strong>诱导</strong>用户访问恶意链接，执行用户非预期执行的操作。</p><p>危害:用户执行敏感操作，如关注其他用户，或者更改账号的安全邮箱等。</p><p>更改邮箱案例：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825155945492.png"alt="image-20230825155945492" /><figcaption aria-hidden="true">image-20230825155945492</figcaption></figure><ol type="1"><li>将更改Email的请求生成CSRF表单，并构造钓鱼链接。</li><li>发送链接给其他用户。</li><li>用户点击链接后成功执行email更改操作。</li></ol><p>防护方式:防护的核心是判断请求的来源</p><ol type="1"><li><p>CSRFtokens:首次访问时候给客户端传递一个token，客户端每次访问时候都必须带上此token才能访问。</p></li><li><p>SameSite cookies: Strick -&gt; Lax(Default) -&gt;None.核心是禁止某些场景发送第三方cookie。</p></li><li><p>Referer-based validation:校验Referer来源是否是合法站点。</p></li></ol><h4 id="点击劫持">点击劫持</h4><p>点击劫持(clickjacking)是一种在网页中将恶意代码等隐藏在看似无害或者存在诱导的内容(如按钮之下，并诱使用户点击的手段，用户点击后往往会执行一些非预期的操作。</p><ol type="1"><li>参考如下代码构造钓鱼页面链接。</li></ol><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825161037366.png"alt="image-20230825161037366" /><figcaption aria-hidden="true">image-20230825161037366</figcaption></figure><p>代码效果：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230825161841378.png"alt="image-20230825161841378" /><figcaption aria-hidden="true">image-20230825161841378</figcaption></figure><ol start="2" type="1"><li><p>发送链接给其他用户。</p></li><li><p>用户访问链接，点击「Win 300$」时候，实际是点击「DeleteAccount]</p></li></ol><p>防护方式:</p><p>防护的核心是不让非预期的网站 iframe 我的站点</p><ol type="1"><li><p>X-Frame-Options: DENY/SAMEORIGIN</p></li><li><p>CSP: frame-ancestors指令，用于设置允许frame的source列表。Content-Security-Policy: frame-ancestors<space separated list of sources>; Content-Security-Policy:frame-ancestors 'self' https://example.orghttps://example.comhttps://store.example.com;</p></li></ol><h4 id="cors跨域配置错误">cors跨域配置错误</h4><p>CORS错误配置:CORS本身不存在漏洞，而是由于开发者在配置CORS过程中，错误配置跨域访问AllowList，导致非预期的站点可以进行跨域访问，最终可能导致信息泄漏。</p><p>常见几种错误配置: 以需要跨域访问example.com所有子域名为例</p><ol type="1"><li>前缀/后缀/包含/正则匹配:可用example.com.attack.com.attackexample.com、attackaexample.com域名绕过。</li><li>在Access-Control-Allow-Origin中反射请求的Origin值。理论上可以用任意域名绕过。</li><li>信任null:攻击者还可以从任意域下通过iframesandbox构造Origin为null的跨域请求</li><li>https信任http:http传输存在被劫持篡改可能，攻击者可能通过劫持通信流量注入恶意脚本方式窃取敏感信息。</li></ol><h2 id="git-的正确使用姿势与最佳实践">Git 的正确使用姿势与最佳实践</h2><h3 id="svn与git的区别">SVN与git的区别</h3><p>SVN是<strong>集中式</strong>版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>Git是<strong>分布式</strong>版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h3 id="安装与配置">安装与配置</h3><p>安装省略...</p><p><strong>配置：</strong></p><p>登录信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;&lt;用户名&gt;&quot;</span><br><span class="line">$ git config --global user.email &quot;&lt;电子邮件&gt;&quot;</span><br></pre></td></tr></table></figure><p>启用Git的彩色显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui auto</span><br></pre></td></tr></table></figure><p>命令别名设置：还可以为Git命令设置别名。例如，将"checkout"命令缩写为"co"，然后只需使用"co"来执行相应的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br></pre></td></tr></table></figure><h3 id="初始化本地仓库版本库">初始化本地仓库（版本库）</h3><p>版本库：版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以<strong>被Git管理</strong>起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>找到一个文件目录（或者自行创建），然后使用<code>git init</code>，表名当前文件夹就是创建的本地仓库，并且已经初始化。</p><p>.git文件：</p><p>当前目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。</p><h3 id="添加文件到仓库">添加文件到仓库</h3><p>在工作目录下，编写了新的文件，名为readme.txt：</p><ol type="1"><li>使用命令<code>git add readme.txt</code>添加到<strong>暂存区</strong>里面去</li><li>用命令 git commit告诉Git，把文件提交到仓库。</li></ol><p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令<code>git status</code>来查看是否还有文件未提交</p><p>现在修改readme文件，但是没执行上面两条保存命令，可以使用<code>git diff readme.txt</code>查看修改的内容。</p><h1 id="vs-code学习">VS code学习</h1><h2 id="vscode配置go开发环境">vsCode配置go开发环境</h2><ol type="1"><li>安装go</li><li>vscode安装go插件</li><li>打开任何包含 Go 代码的目录或工作区以自动激活 扩展名。<ahref="https://github.com/golang/vscode-go/wiki/ui">Go 状态栏</a>显示在窗口的左下角，并显示您的 Go 版本。</li><li>扩展依赖于 、 和其他可选工具。如果缺少任何依赖项，<code>go``gopls``dlv</code>⚠️<code>Analysis Tools Missing</code>警告将显示。单击警告以下载依赖项。</li></ol><h3 id="运行第一个go项目">运行第一个go项目</h3><ol type="1"><li><p>创建一个文件夹目录，vscode打开改目录</p></li><li><p>输入指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init vls.com/learn</span><br></pre></td></tr></table></figure></li></ol><h2 id="vscode安装go插件失败问题">vscode安装go插件失败问题</h2><p>原因：没走代理，访问不到资源</p><p>解决：</p><ol type="1"><li><p>在teminal里输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 新版改成如下链接</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://proxy.golang.com.cn,direct</span><br></pre></td></tr></table></figure></li><li><p>重启vsCode重新安装即可。</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230726101703271.png"alt="image-20230726101703271" /><figcaption aria-hidden="true">image-20230726101703271</figcaption></figure></li></ol><h1 id="项目">项目</h1><h2 id="项目简介">项目简介</h2><p>实现极简版抖音</p><h2 id="项目功能实现">项目功能实现</h2><h3 id="发布视频">发布视频</h3><h4 id="阿里云oss使用权限">阿里云oss使用权限</h4><ol type="1"><li><p>创建完阿里oss存储，一定要去创建用户，然后创建用户的可用AccessKey</p></li><li><p>创建完用户，在oss某个存储桶去设置权限</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230820172426055.png"alt="image-20230820172426055" /><figcaption aria-hidden="true">image-20230820172426055</figcaption></figure></li><li><p>给创建的用户设置权限即可：</p><figure><imgsrc="2023年7至8月第六届字节青训营学习记录/image-20230820172453299.png"alt="image-20230820172453299" /><figcaption aria-hidden="true">image-20230820172453299</figcaption></figure></li></ol><h4 id="总体代码">总体代码</h4><p>controller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程前置信息&quot;&gt;课程前置信息&lt;/h1&gt;
&lt;p&gt;文档：&lt;/p&gt;
&lt;p&gt;&lt;a
href=&quot;https://bytedance.feishu.cn/docx/KwNudUZqQoGL6sxDzFscelaHnGg?contentTheme=DARK&amp;amp;the</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://vlsmhd.github.io/categories/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
    
  </entry>
  
</feed>
