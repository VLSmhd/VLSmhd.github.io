<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>深入理解分布式系统-阅读笔记 | VLS_Blog</title><meta name="author" content="Vlong_shen"><meta name="copyright" content="Vlong_shen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="认识分布式系统 什么是分布式系统 分布式系统是一个其组件分布在不同的、联网的计算机上，组件之间通过传递消息进行通信和协调，共同完成一个任务的系统 特点：  多进程 不共享操作系统 不共享时钟  为什么需要分布式系统 为了解决但不限于单机系统的如下问题：  高性能 可扩展性：多数应用程序都是数据密集（data-intensive）型的 应用程序，大部分时间在存储和处理数据">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解分布式系统-阅读笔记">
<meta property="og:url" content="https://vlsmhd.github.io/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="VLS_Blog">
<meta property="og:description" content="认识分布式系统 什么是分布式系统 分布式系统是一个其组件分布在不同的、联网的计算机上，组件之间通过传递消息进行通信和协调，共同完成一个任务的系统 特点：  多进程 不共享操作系统 不共享时钟  为什么需要分布式系统 为了解决但不限于单机系统的如下问题：  高性能 可扩展性：多数应用程序都是数据密集（data-intensive）型的 应用程序，大部分时间在存储和处理数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vlsmhd.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-03-26T03:26:08.300Z">
<meta property="article:modified_time" content="2024-04-17T13:51:35.585Z">
<meta property="article:author" content="Vlong_shen">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vlsmhd.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vlsmhd.github.io/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解分布式系统-阅读笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-17 21:51:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="VLS_Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="VLS_Blog"><img class="site-icon" src="https://vlsmhd.github.io/img/avatar.jpg"/><span class="site-name">VLS_Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深入理解分布式系统-阅读笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-26T03:26:08.300Z" title="发表于 2024-03-26 11:26:08">2024-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-17T13:51:35.585Z" title="更新于 2024-04-17 21:51:35">2024-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深入理解分布式系统-阅读笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="认识分布式系统">认识分布式系统</h1>
<h2 id="什么是分布式系统">什么是分布式系统</h2>
<p>分布式系统是一个其<strong>组件分布</strong>在不同的、联网的计算机上，组件之间通过<strong>传递消息</strong>进行通信和协调，<strong>共同完成</strong>一个任务的系统</p>
<p>特点：</p>
<ul>
<li>多进程</li>
<li>不共享操作系统</li>
<li>不共享时钟</li>
</ul>
<h2 id="为什么需要分布式系统">为什么需要分布式系统</h2>
<p>为了解决但不限于单机系统的如下问题：</p>
<ol type="1">
<li>高性能</li>
<li>可扩展性：多数应用程序都是数据密集（data-intensive）型的
应用程序，大部分时间在存储和处理数据。随着业务扩展、用户增长或者历史数据累积，单台计算机只能扩展到有限的程度</li>
<li>高可用性：保证5个9的可用性：99.999%的时间内正常运行。每年最多允许宕机5min这种。故障切换等等</li>
<li>必要性：银行系统必须采用分布式，保证安全可靠。</li>
</ol>
<h2 id="分布式系统的挑战">分布式系统的挑战</h2>
<p>分布式计算的谬误：</p>
<ol type="1">
<li><p>网络是可靠的</p></li>
<li><p>延迟为零</p></li>
<li><p>带宽是无限的</p></li>
<li><p>网络是安全的</p></li>
<li><p>拓扑结构不会改变</p></li>
<li><p>单一管理员</p></li>
<li><p>传输成本为零</p></li>
<li><p>网络是同构的</p></li>
</ol>
<h3 id="网络延迟">网络延迟</h3>
<p>问题描述：分布式系统多个节点进行通讯，网络不能保证每个传输的数据包准确到达、什么时候到达、一定到达等。有时候网络甚至不安全。</p>
<p>消息传递会出现以下问题：</p>
<ul>
<li>消息丢失</li>
<li>消息延迟送达</li>
<li>重传消息导致消息重复</li>
<li>消息的顺序性</li>
</ul>
<h3 id="部分结点失效">部分结点失效</h3>
<p>分布式中，多个节点中某个或者多个节点会失效，亦或者发生了网络分区，将结点分成几部分，这几个部分的结点无法相互通信。</p>
<ul>
<li><p>不确定性</p></li>
<li><p>性能瓶颈</p></li>
</ul>
<h3 id="时钟问题">时钟问题</h3>
<p>单机系统可以使用时间推进的方式来标识事件之间的先后顺序，但分布式系统中的结点之间时钟不一致；并且，消息传递过程中的耗时也难以确定，导致事件的顺序需要特殊处理。</p>
<h2 id="程序员需要了解的数字">程序员需要了解的数字</h2>
<p>一些操作的延迟：</p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>延时</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>执行一个指令</td>
<td>1 ns</td>
</tr>
<tr class="even">
<td>L 1缓存查询</td>
<td>0.5 ns</td>
</tr>
<tr class="odd">
<td>分支预测错误（BranchMispredict）</td>
<td>3 ns</td>
</tr>
<tr class="even">
<td>L2缓存查询</td>
<td>4 ns</td>
</tr>
<tr class="odd">
<td>互斥锁／解锁（MutexLock／Unlock）</td>
<td>17 ns</td>
</tr>
<tr class="even">
<td>主存访问</td>
<td>100 ns</td>
</tr>
<tr class="odd">
<td>使用Zippy算法压缩1 KB的数据</td>
<td>2000 ns</td>
</tr>
<tr class="even">
<td>从内存顺序读取 1 MB的数据</td>
<td>3000 ns</td>
</tr>
<tr class="odd">
<td>SSD随机读</td>
<td>39000 ns</td>
</tr>
<tr class="even">
<td>从SSD顺序读取1MB的数据</td>
<td>49000 ns</td>
</tr>
<tr class="odd">
<td>同1个数据中心往返</td>
<td>500 000 ns</td>
</tr>
<tr class="even">
<td>从磁盘顺序读取1MB的数据</td>
<td>718 000 ns</td>
</tr>
<tr class="odd">
<td>磁盘寻址</td>
<td>2000000 ns（2 ms）</td>
</tr>
<tr class="even">
<td>数据包往返美国到欧洲</td>
<td>150000000 ns（150ms）</td>
</tr>
</tbody>
</table>
<h1 id="分布式系统模型">分布式系统模型</h1>
<p>根据实际经验抽象出的一些通用的系统模型。</p>
<h2 id="两将军问题">两将军问题</h2>
<blockquote>
<p>问题描述：指两支由不同的将军领导的军队，正准备进攻一座坚固的城市。军队在城市附近的两个山丘扎营，中间有一个山谷将两个山丘隔开，两个将军交流的唯一方法是派遣信使穿越山谷，然而，山谷被城市的守卫者占领，并且途经该山谷传递信息的信使有可能会被俘虏。</p>
</blockquote>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240403154318191.png"
alt="两将军问题模型图" />
<figcaption aria-hidden="true">两将军问题模型图</figcaption>
</figure>
<p>两队的行动和行动结果：</p>
<table>
<thead>
<tr class="header">
<th>军队A</th>
<th>军队B</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>不进攻</td>
<td>不进攻</td>
<td>无事发生</td>
</tr>
<tr class="even">
<td>进攻</td>
<td>不进攻</td>
<td>A战败</td>
</tr>
<tr class="odd">
<td>不进攻</td>
<td>进攻</td>
<td>B战败</td>
</tr>
<tr class="even">
<td>进攻</td>
<td>进攻</td>
<td>成功</td>
</tr>
</tbody>
</table>
<p>双方达成统一进攻的“共识问题”，比较困难：</p>
<ol type="1">
<li><p>A想进攻，通知B，但是A派出的士兵被俘虏</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240403154622114.png" alt="A发起进攻，士兵被俘虏" style="zoom:80%;" /></p>
<p>这时对于A的不确定性：不知道B打不打，怕自己只有一只军队上，又怕B知道消息自己上了，但是A没上</p></li>
<li><p>为了消除A的不确定性，B需要向A的军队发送ACK确认信息</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240403154825366.png"
alt="B向A的军队发送ACK确认信息" />
<figcaption aria-hidden="true">B向A的军队发送ACK确认信息</figcaption>
</figure>
<p>当B派遣的士兵被俘虏，A对其也不能信服</p></li>
</ol>
<p>因此，该问题实际上是无解的，一般在军队上需要总指挥官来协同。</p>
<p>在计算机分布式系统上，TCP的三次握手可以很好的解决这个问题。</p>
<h2 id="拜占庭将军问题">拜占庭将军问题</h2>
<blockquote>
<p>多个拜占庭将军各率领一支军队，想要占领一座防守坚固的城市，将军们还是只能通过信使进行交流。为了简化问题将各支军队的行动策略限定为进攻或者撤离两种。因为部分军队进攻、部分军队撤离可能会导致灾难性后果，所以各位将军必须通过投票来达成一致的策略，即所有军队一起进攻或者所有军队一起撤离。拜占庭将军问题的挑战在于：将军中可能出现叛徒，他们会试图故意误导和迷惑其他将军来破坏整个军事行动。</p>
</blockquote>
<p><img src="深入理解分布式系统-阅读笔记/image-20240404145134646.png" alt="拜占庭将军问题" style="zoom: 67%;" /></p>
<h2 id="系统模型">系统模型</h2>
<p>设计一个分布式系统的时候，我们必须清楚系统会发生哪种故障，然后寻找对应的解。不同的系统模型有着不同的算法和架构。我们按网络、节点故障和时间三种类型划分系统模型。</p>
<h3 id="网络链路模型">网络链路模型</h3>
<p>网络是一定不可靠，无论什么情况。</p>
<p>而网络出错常导致的问题称为网络分区（Network
Partition），网络分区是指由于网络设备故障，导致网络分裂为多个独立的组。也就是节点仍然正常工作，但它们之间的通信连接已经中断。</p>
<p>假设最简单的单播通信场景：消息通常在两个节点之间相互传递。有一个发送者、一个接收者，它们通过一个双向的链路通信。</p>
<h4 id="可靠链路完美链路">可靠链路（完美链路）</h4>
<p>完美链路不会丢失消息也不回凭空捏造消息，但可能对消息重排序，特征如下：</p>
<ol type="1">
<li>可靠传递：</li>
<li>无重复：每条消息最多传输一次</li>
<li>不会无中生有</li>
</ol>
<h4 id="公平损失链路">公平损失链路</h4>
<p>消息可能会重复、丢失、重排序，但最终一定送达，特征如下：</p>
<ol type="1">
<li>公平损失：如果<strong>发送方和接收方都是正常运行</strong>的，且发送方不断重复发送消息，则消息最终会被送达。</li>
<li>有限重复：不会无限重发消息</li>
<li>不会无中生有</li>
</ol>
<h4 id="任意链路">任意链路</h4>
<p>最弱的网络模型，允许链路执行任何操作。可以截包等，最接近互联网的模型。</p>
<h4 id="链路的转换">链路的转换</h4>
<p>公平链路 + 重传 + 重复消息过滤 = 可靠链路</p>
<p>任意链路 + 加密安全技术 = 公平链路</p>
<h3 id="节点故障类型">节点故障类型</h3>
<h4 id="崩溃-停止">崩溃-停止</h4>
<p>一个节点停止工作后永远不会恢复。这可能是不可恢复的硬件故障，比如一个人不小心将手机掉进马桶里导致手机永久失灵。对于这种模型，有些情况下也许可以通过重启机器来恢复，但这种模型主要意味着算法不能依赖于节点恢复</p>
<h4 id="崩溃-恢复">崩溃-恢复</h4>
<p>允许节点重新启动并继续执行剩余的步骤，一般通过<strong>持久化存储</strong>必要的状态信息来容忍这种故障类型。</p>
<h4 id="拜占庭故障">拜占庭故障</h4>
<p>故障的节点可能不只会宕机，还可能以任意方式<strong>偏离算法</strong>，甚至<strong>恶意破坏系统</strong>。</p>
<h3 id="按时间划分模型">按时间划分模型</h3>
<p>基于时间或者是否同步（Synchronous）来进行划分。</p>
<h4 id="同步系统模型">同步系统模型</h4>
<p>消息的响应在一个有限且已知的时间范围内。</p>
<p>系统是同步的，容易解决问题，很多问题都是可预测的，消息也是可送达的，但这是理想情况。</p>
<h4 id="异步系统模型">异步系统模型</h4>
<p>一个消息的响应时间是无限的，无法知道一条消息什么时候会到达。</p>
<p>最接近现实的系统，我们无法预知哪一个服务结点会发生故障；例如，Java的虚拟机自带的垃圾回收机制，随着服务进程的不断运行，服务器产生的垃圾数目越来越多，总会触发full
GC，造成短暂的停顿现象。</p>
<h4 id="部分同步模型">部分同步模型</h4>
<p>最能实现的系统模型，系统在大部分时间都是同步的，但偶尔会因为故障转变为异步系统。</p>
<h2 id="消息传递语义">消息传递语义</h2>
<p>幂等性问题描述：分布式系统中的各个节点之间通过互相传递消息来协作。由于网络和节点不可靠，这些消息可能会丢失，为了解决消息丢失问题会让节点重复发送信息，这意味着消息可能会发送多次。如果像http中的put操作，那就会造成很大的损失。</p>
<p>常见语义：</p>
<ul>
<li>最多一次：消息最多传递一次，可能丢失，但绝不会重复。</li>
<li>至少一次：消息至少传递一次，不会丢失，会重复传送，可能出现重复幂等性问题</li>
<li>精确一次：消息只会被精确传递一次。</li>
</ul>
<h1 id="分布式数据基础">分布式数据基础</h1>
<p>分布式常见的两个基础技术：分区&amp;复制。</p>
<h2 id="分区">分区</h2>
<p>分区是提高分布式系统可扩展性的主要方法之一，具体是指将一个大的数据集，按照某种规则，拆分成多个较小的数据集，分散存储在分布式系统中的不同节点上。可扩展性体现在，当需要更大规模的数据存储时，添加多台机器结点即可。</p>
<p>分区分为垂直分区和水平分区：</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405150829615.png" alt="垂直分区和水平分区的区别" style="zoom: 67%;" /></p>
<h3 id="垂直分区">垂直分区</h3>
<p>定义：对表的列进行拆分，也叫“行拆分”，属于是把表的元数据拆分开来。</p>
<p>应用场景：可以把不常用的列或者是text、blob的大类型的列垂直拆分，提高查询效率。</p>
<ul>
<li>列式数据库</li>
</ul>
<blockquote>
<p>列式数据库也叫列存数据库，是指以列为单位进行数据存储架构的数据库。主妥适用于批量数据处理和即时查询。与之相对应的是行式数据库，一般来说，行式数据库吏适用于联机事务处理（OLTP）这类频繁处理事务的场景，列式数据库更适用于联机分析处理（OLAP）这类在海量数据中进行复杂查询的场景。</p>
</blockquote>
<h3 id="水平分区">水平分区</h3>
<p>定义：对表的行进行拆分，将不同的行通过某种映射关系，存储到不同的数据库结点中，不改变表的元数据结构。水平分区常称为分片。</p>
<p>常见的算法如下介绍。</p>
<h4 id="范围分区">范围分区</h4>
<p>根据指定的关键字将数据集拆分成多个 <strong>连续</strong>
的范围每个范围存储到一个单独的节点上。用来分区的关键字也叫分区键。</p>
<p>案例：</p>
<p>对于2011年到2020年这十年的订单记录，以年为范围，可以划分为10个分区，然后将2011年的订单记录存储到节点N_1上，将2012年的订单记录存储到节点N2上，以此类推。</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405151635189.png" alt="年龄拆分案例" style="zoom:80%;" /></p>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>小范围查询快，容易确定查询范围涉及的结点</li>
<li>调整分区简单：通过调整范围大小控制结点存储的量级</li>
</ul>
<p>缺点：</p>
<ul>
<li>关键字限制：只能通过分区的某个关键字进行查询，其它字段查询性能要求较大</li>
<li>大范围需要跨节点，效率底下</li>
<li>数据分布不均匀：分区的原则没有规定好，比如，按照地域不同存储不同的用户信息，某一地区的用户信息是其它地区的n倍，存储该地区的结点收到的访问请求会很多。</li>
</ul>
<h4 id="哈希分区">哈希分区</h4>
<p>按照某个列（关键字），计算出hash值，来决定存储在哪个结点。</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405152137152.png" alt="哈希分区示例" style="zoom:80%;" /></p>
<p>优点：</p>
<ul>
<li>hash函数优良：分布均匀</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法范围查询</li>
<li>添加节点需要rehash，涉及大量节点的迁移</li>
</ul>
<h4 id="一致性hash算法">一致性hash算法</h4>
<p>特殊的哈希分区算法，在分布式存储系统中用来缓解哈希分区增加或删除节点时引起的大规模数据移动问题。</p>
<p>一致性hash算法有多种实现形式，如，hash环方法：</p>
<p>一致性哈希算法将整个哈希值组织成一个抽象的圆环，称为哈希环（Hashing
Ring）。hash函数的输出值范围为[0，
Integer.MAX_VALUE]，输出值均匀映射在hash环上。</p>
<ol type="1">
<li>假设hash环[0， 11]，三个结点均匀分布，如图：</li>
</ol>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405155817501.png" alt="1. hash环均匀分布" style="zoom:80%;" /></p>
<ol start="2" type="1">
<li>将要存储的数据的关键字计算出hash值，然后映射到hash环上，假设此时要存储三个键值对数据，它们的关键字分别为a、b和c，假设经过哈希函数计算后的哈希值分别为1、5和9，则数据映射到环上后如图：</li>
</ol>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405160029032.png" alt="2. 数据映射" style="zoom:80%;" /></p>
<ol start="3" type="1">
<li>数据按照顺时针方向寻找自己应该存入的结点。a存在N2，b存在N3，c存在N1</li>
<li>向集群添加节点，原本存在N2的a需要迁移到顺时针方向最近的N4结点</li>
</ol>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405160634660.png" alt="4. 向集群添加节点" style="zoom:80%;" /></p>
<p>优点：</p>
<ul>
<li>添加节点，迁移方便，迁移环上小部分数据即可</li>
</ul>
<p>缺点：</p>
<ul>
<li>节点较少会产生数据倾斜问题</li>
<li>无法范围查询</li>
</ul>
<p>解决数据倾斜问题：</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405161719933.png" alt="添加虚拟结点" style="zoom:67%;" /></p>
<p>控制虚拟节点的数量，可以控制抵达不同节点的流量级别。</p>
<h3 id="分区的挑战">分区的挑战</h3>
<ol type="1">
<li>垂直分区，left join查询低效，因为要访问多个结点的数据</li>
<li>水平分区，查询范围过大，涉及到需要访问多个结点的数据，查询效率也不快</li>
<li>事务的实现</li>
</ol>
<h2 id="复制">复制</h2>
<p>概念：复制是指将同一份数据冗余存储在多个节点，节点间通过网络同步数据。一个存储了复制数据的节点称为<strong>副本（Replica）</strong>。</p>
<p>复制有什么好处：</p>
<ol type="1">
<li>增强数据的可用性、安全性：通过复制技术，将数据冗余存储，即使系统部分节点发生故障，系统也能继续工作</li>
<li>减少往返时间：为用户选择距离最近的服务结点查询数据</li>
<li>增加吞吐量</li>
</ol>
<h3 id="单主复制">单主复制</h3>
<p>单主复制也叫主从复制或主从同步：集群选择一个主节点，客户端的写请求必须经过主结点，从结点只能处理读请求。</p>
<p>主节点收到写请求，不仅要持久化自己的结点上，还需要向其它结点进行网络同步操作。</p>
<p>优点：</p>
<ul>
<li>易实现</li>
<li>事务性能高</li>
<li>读性能高</li>
</ul>
<p>缺点：</p>
<ul>
<li>写请求处理能力不佳</li>
<li>主节点宕机会造成短暂停顿，切换结点
<ul>
<li>手动切换</li>
<li>自动切换</li>
</ul></li>
</ul>
<h4 id="同步复制">同步复制</h4>
<p>主节点持久化完毕并且向其它结点同步完毕以后再向客户端返回结果。</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405163704841.png" alt="同步复制时序图" style="zoom:80%;" /></p>
<p>特征：保证了数据的一致性，安全性，牺牲了响应性能。当结点数量增加或者某个结点有IO的瓶颈，就会大大降低响应能力。</p>
<h4 id="异步复制">异步复制</h4>
<p>主节点执行完写请求，立即返回客户端结果，随后在后台向其它结点同步消息。</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405163842500.png" alt="异步复制时序图" style="zoom:80%;" /></p>
<p>特征：不保证数据的一致性，如果用户收到写请求的ack之后立即向其它结点发起读请求，可能读不到自己已经修改的新的值。</p>
<p>如果此时主节点失效，某个从结点选举为主节点，这时候集群就会丢失这一条啊新添加的数据。</p>
<p>但是响应能力非常好。</p>
<h4 id="半同步复制">半同步复制</h4>
<p>是介于同步复制和异步复制之间的一种复制机制，主节点只需要等待额外一个从节点同步完数据即可向客户端返回。</p>
<h3 id="多主复制">多主复制</h3>
<p>多主集群中每个主的工作内容和单主模型一致，流程如下：</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405164746171.png" alt="多主复制时序图" style="zoom:80%;" /></p>
<p>优势：</p>
<ul>
<li>增加主节点的容错性</li>
<li>可以在多个节点上执行写请求，分担写压力</li>
</ul>
<p>缺点：</p>
<h4 id="数据冲突问题">数据冲突问题</h4>
<p>假如X = 1到达主节点1之后，主节点1 - &gt;
2之间的消息发生延迟，导致主节点1和从节点是最新的数据3，而主节点2是值为1的旧数据。</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405165812031.png" alt="数据冲突" style="zoom:80%;" /></p>
<p>解决方案：</p>
<ol type="1">
<li>客户端解决：服务端把冲突数据一次性全返回给客户端，由客户端决定真正的值。
<ul>
<li>购物车应用：</li>
</ul></li>
<li>最后写入胜利（last write
wins）：每个结点给到达自身的写请求添加一个唯一标识（时间戳 or
序列号），最后的那个写请求的值是正确的</li>
<li>因果关系追踪：利用happens-before原则或者业务的逻辑原则，判断请求的顺序。
<ul>
<li>发帖回帖：发帖操作一定先于回帖</li>
</ul></li>
</ol>
<h3 id="无主复制">无主复制</h3>
<p>客户端不仅向一个结点发送请求，有可能是多个甚至是集群中全部的结点。</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240405172034982.png" alt="无主复制时序图" style="zoom:80%;" /></p>
<p>当客户端收到多个节点的回应，就说明这次写入算做成功。</p>
<p>更多的数据冲突：客户端给服务端发送的请求可能会丢失，造成部分结点是旧值，部分结点是新值，造成不一致的现象。</p>
<p>Dynamo修复数据的方式：</p>
<ol type="1">
<li>读修复：客户端主导，客户端发送多个读请求，读取包含新旧数据的全部情况，然后给不一致的结点发送新的请求</li>
<li>反熵过程：后台进程检测错误数据，保证最终一致性
<ul>
<li>检验数据的正确：采用Merkle
Tree哈希树，将每个数据范围计算出哈希值，自底向上构造一棵树，有点类似B+树。这样可以根据哪部分数据发生了改动，快速定位到树的结点，也不用全部遍历，只需传入子树的根节点即可。</li>
</ul></li>
</ol>
<h4 id="基于quorum的数据冗余机制">基于Quorum的数据冗余机制</h4>
<p>Quomm（法定人数）机制，保证分布式系统中数据冗余和最终一致性的一种算法。</p>
<p>定义：有N个结点的集群，要求至少W个结点写入成功，并且需要同时从R个结点读取数据，只要
<code>W + R &gt; N</code> ，就能保证读取的消息中至少有一条是最新的。</p>
<ul>
<li>证明：已知N、W，那写入失败的结点是N - W，由于W + R &gt; N，R &gt; N
- W，读取的结点个数比写入失败的结点多。</li>
</ul>
<p>高一致性设置：W = N， R = N。</p>
<p>写多读少：W = N， R = 1</p>
<p>一般设置：W = N / 2 + 1</p>
<h2 id="cap定理">CAP定理</h2>
<p>CAP定理是对分布式系统的高级抽象。</p>
<p>定义：对于一个分布式读写存储系统来说，只能满足以下任意两个特性</p>
<ul>
<li>一致性：线性一致性</li>
<li>可用性：事事有回应</li>
<li>分区容错性：网络分区导致消息丢失，系统正常运行</li>
</ul>
<p>谬误：实际上分区很少发生，发生更多的是网络延迟的情况</p>
<h3 id="pacelc定理">PACELC定理</h3>
<p>P：有网络分区的情况下，必须考虑如下特性</p>
<ul>
<li>可用性（A）：</li>
<li>一致性（C）：</li>
</ul>
<p>E：无网络分区的情况下，必须考虑如下特性</p>
<ul>
<li>延迟（L）：</li>
<li>一致性（C）：</li>
</ul>
<p>常见的分布式系统满足的条件表如下：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406163325789.png"
alt="常见分布式数据库的PACELC" />
<figcaption aria-hidden="true">常见分布式数据库的PACELC</figcaption>
</figure>
<h3 id="base">BASE</h3>
<p>BASE（Basically Available，SoftState，Eventually
Consistent），基本可用、软状态、最终一致性。</p>
<p>保证高可用，舍弃强一致性的理论。</p>
<h2 id="一致性模型">一致性模型</h2>
<p>纠正：Raft、Paxos并不是分布式一致性算法，而是分布式共识算法。一致性的概念是另一种理论。分布式的一致性，和复制有很大关系，复制的方式保证了一致性的强弱情况。与并发编程的一致性不同，开发者遵守某些规则，是可预测的模型。</p>
<p>线性一致性是最高级的一致性模型</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240326154028290.png" alt="分布式一致性验证框架Jepsen 对一致性模型的分类" style="zoom:67%;" /></p>
<ul>
<li><p>白底矩形中的模型的可用性为不可用（Unavailable）：满足这类一致性模型的系统发生网络分区时，为了保证数据一致性和正确性，系统会不可用。用CAP定理来解释，就是典型的CP类系统。这类一致性模型包括线性一致性和顺序一致性。</p></li>
<li><p>灰底矩形中的模型的可用性为基本可用（Sticky
Available）：满足这类一致性模型的系统可以容忍一部分节点发生故障，还未出现故障的节点仍然可用，但前提是客户端不能将请求发送到不可用的副本节点。这类一致性模型包括因果一致性、PRAM一致性和读你所写一致性。</p></li>
<li><p>椭圆中的模型的可用性为高可用（Total
Available）：满足这类一致性模型的系统可用性是最高的，即使网络发生严重分区在没有发生故障的节点上，仍然保证可用。这类一致性模型包括读后写一致性、单调读一致性和单调写一致性</p></li>
</ul>
<h3 id="以数据为中心的模型">以数据为中心的模型</h3>
<h4 id="线性一致性">线性一致性</h4>
<p>非严格定义：分布式系统看起来就像只有一个结点，并且全部的操作都是原子性的（针对客户端来说）。</p>
<ul>
<li>为什么强调原子性，因为并发写操作不是瞬时完成的，是需要经历一定的时间的，在这个时间内，如果不讲究原子性，那读操作查询到的值会很多种。</li>
</ul>
<p>相关术语：</p>
<ul>
<li>历史（History H）：并发程序的执行历史，由一系列操作组成
<ul>
<li>操作：包含调用 -&gt; 响应，调用一定在响应之前
<ul>
<li>调用（Invocation）</li>
<li>响应（Response）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="深入理解分布式系统-阅读笔记/image-20240406165150516.png" alt="写操作示例" style="zoom:80%;" /></p>
<p><strong>严格定义：给定一个执行历史，而执行历史可以根据并发操作的可能性扩展为多个顺序历史，如果有一个顺序历史合法，就说明该执行历史就是线性一致性的。</strong></p>
<p>并发操作的三种关系：</p>
<ul>
<li><p>顺序关系：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406170321626.png"
alt="顺序关系" />
<figcaption aria-hidden="true">顺序关系</figcaption>
</figure></li>
<li><p>部分重叠关系（并发）：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406170338211.png"
alt="部分重叠关系" />
<figcaption aria-hidden="true">部分重叠关系</figcaption>
</figure></li>
<li><p>包含关系（并发）：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406170400307.png"
alt="包含关系" />
<figcaption aria-hidden="true">包含关系</figcaption>
</figure></li>
</ul>
<p>根据严格定义，有如下案例：</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240406165750801.png" alt="线性一致性案例" style="zoom:80%;" /></p>
<p>对这个执行历史进行重排序，得到顺序历史如下：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406170944265.png"
alt="线性一致性案例的顺序历史" />
<figcaption aria-hidden="true">线性一致性案例的顺序历史</figcaption>
</figure>
<p>很显然，S2合法，所以该执行历史是满足线性一致性的。</p>
<p>总结线性一致性的约束条件：</p>
<ul>
<li>顺序记录，任何一次读操作都读到最近一次写入的数据</li>
<li>保证顺序记录的每个操作时钟有序</li>
</ul>
<h5 id="实现">实现</h5>
<p>加原子锁实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> incr() &#123;</span><br><span class="line">	<span class="type">int</span> j = i++;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并发环境下，j 不一定就是2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> incr() &#123;</span><br><span class="line">    lock(&amp;lock);</span><br><span class="line">	<span class="type">int</span> j = i++;</span><br><span class="line">    unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见CPU对其的优化实现都是CAS原子操作保证一致性。</p>
<h5 id="代价">代价</h5>
<ol type="1">
<li>同步原语、原子变量等会造成额外的开销</li>
<li>时钟顺序必须一致，也就是必须统一全局时钟</li>
</ol>
<h4 id="顺序一致性">顺序一致性</h4>
<p>定义：以单个客户端为对象，其执行的操作相对有序；以多个客户端为主体对象，不同客户端之间执行的操作顺序可以乱序。</p>
<p>案例：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406171745565.png"
alt="顺序一致性案例" />
<figcaption aria-hidden="true">顺序一致性案例</figcaption>
</figure>
<p>其顺序历史有如下情况：</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240406171845590.png"
alt="S3" />
<figcaption aria-hidden="true">S3</figcaption>
</figure>
<p>该情况显然不满足线性一致性，但是每个客户端的操作单独来看的话，是局部有序的，虽然并发情况下乱序，但扔满足线性一致性。</p>
<h4 id="因果一致性">因果一致性</h4>
<p>定义：必须以相同的顺序，看到因果相关的操作。前提是多个操作之间有因果关系。</p>
<p>案例：</p>
<ul>
<li>发帖操作先于对帖子的评论</li>
<li>先有评论后有对该评论的回复</li>
</ul>
<h4 id="最终一致性">最终一致性</h4>
<p>系统运行的某个阶段，允许并发操作以任意顺序运行，但是在最终时刻，其系统中保持数据的一致性。</p>
<h3 id="以客户端为中心的模型">以客户端为中心的模型</h3>
<p>这类一致性模型从客户端的角度来观察分布式系统，不再从系统的角度考虑每个副本的数据是否一致，而是<strong>考虑客户端的读写请求的结果</strong>，从而推断出系统的一致性</p>
<h4 id="单调读">单调读</h4>
<p>要求：客户端某一时刻读取的某一记录的值是v，随着时间单调递增，后面读到的值的新程度
&gt;= v ，即不会读到旧值</p>
<h4 id="单调写">单调写</h4>
<p>要求：同一个客户端的写操作，在所有副本上都是以同样的顺序运行，保证写操作串行。</p>
<h4 id="读你所写">读你所写</h4>
<p>要求：客户端在集群写完数据后，读取任意结点，结点需要返回客户端自己已经写过的值。</p>
<h4 id="pram一致性">PRAM一致性</h4>
<p>又称FIFO（流水线随机访问存储器）一致性，由单调读、单调写和读你所写三个一致性模型组成。</p>
<p>要求：同一个客户端的写操作，在所有副本上的顺序一致。但不同客户端之间的写操作可以乱序。</p>
<h4 id="读后写">读后写</h4>
<p>对于同一个客户端，对一个数据项x，先读到了写操作<span
class="math inline">\(w_1\)</span>的值为v，之后的写操作必须保证值比v新，并且写操作也要在<span
class="math inline">\(w_1\)</span>之后</p>
<p>类似因果一致性。</p>
<h2 id="隔离级别">隔离级别</h2>
<blockquote>
<p>tips：箭头表示强弱、包含关系，上层的隔离级别最强</p>
</blockquote>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240329114543746.png"
alt="隔离级别-级别图" />
<figcaption aria-hidden="true">隔离级别-级别图</figcaption>
</figure>
<h3 id="常见的事务异常">常见的事务异常</h3>
<h4 id="脏写脏读">脏写脏读</h4>
<p><strong>脏写</strong>：一个事务的写覆盖了另一个正在执行还未提交的事务的写。</p>
<p>案例：事务B覆盖了事务A的写</p>
<table>
<thead>
<tr class="header">
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x = 1</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>x = 2</td>
</tr>
<tr class="odd">
<td></td>
<td>y = 2</td>
</tr>
<tr class="even">
<td></td>
<td>commit</td>
</tr>
<tr class="odd">
<td>y = 1</td>
<td></td>
</tr>
<tr class="even">
<td>commit</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果两者的事务串行化执行，x一直和y相等。该表的最终结果是x = 2， y =
1。</p>
<p><strong>脏读</strong>：一个事务读到了另一个还未提交的事务写入的值。</p>
<p>案例：事务B脏读到A的值，初始x为0</p>
<table>
<thead>
<tr class="header">
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x = 1</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>read(x) = 1</td>
</tr>
<tr class="odd">
<td>rollback</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="不可重复读模糊读">不可重复读（模糊读）</h4>
<p>一次事务中，对数据的两次读操作，读出来的值不同。</p>
<p>案例：初始x = 0，事务B读的值不同</p>
<table>
<thead>
<tr class="header">
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>read(x) = 0</td>
</tr>
<tr class="even">
<td>x = 1</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>read(x) = 1</td>
</tr>
<tr class="even">
<td>commit</td>
<td>commit</td>
</tr>
</tbody>
</table>
<h4 id="幻读">幻读</h4>
<p>一次事务中，按照某种条件查询，前后多次查询的数据量发生变化。原因是别的事务在此之间插入或者删除了满足相同条件的数据。</p>
<h4 id="丢失更新">丢失更新</h4>
<p>两个事务读取到同一个值，都想对这个值修改，由于最后只能展示一个值，一定会丢失一个事务写的值。</p>
<p>案例：初始x = 0</p>
<table>
<thead>
<tr class="header">
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x = 1</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>x = 2</td>
</tr>
<tr class="odd">
<td>commit</td>
<td>commit</td>
</tr>
</tbody>
</table>
<h4 id="读写偏斜">读写偏斜</h4>
<p><strong>读偏斜</strong>：事务读到了数据一致性<strong>约束</strong>被破坏的数据，这里的一致性是业务上的一致性</p>
<p>案例：给定约束X + Y = 100</p>
<table>
<thead>
<tr class="header">
<th>事务A</th>
<th>X</th>
<th>Y</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>50</td>
<td>50</td>
<td>Read(X) = 50</td>
</tr>
<tr class="even">
<td>Write(X， 30)</td>
<td>30</td>
<td>50</td>
<td></td>
</tr>
<tr class="odd">
<td>Write(Y， 70)</td>
<td>30</td>
<td>70</td>
<td></td>
</tr>
<tr class="even">
<td>commit</td>
<td>30</td>
<td>70</td>
<td>Read(Y) = 70</td>
</tr>
<tr class="odd">
<td></td>
<td>30</td>
<td>70</td>
<td>commit</td>
</tr>
</tbody>
</table>
<p>可以看到，事务B读到的X + Y = 50 + 70
不满足业务规定，导致读偏斜。但是实际上X和Y的结果是符合条件的，只是事务B出现异常。</p>
<p><strong>写偏斜</strong>：两个事务都读到了相同的数据集，随后各自修改了不相干的数据集，导致最终结果不满足业务上的一致性</p>
<p>案例：给定约束X + Y &lt; 100</p>
<table>
<thead>
<tr class="header">
<th>事务A</th>
<th>X</th>
<th>Y</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Read(X) = 10</td>
<td>10</td>
<td>20</td>
<td>Read(X) = 10</td>
</tr>
<tr class="even">
<td>Read(Y) = 20</td>
<td>10</td>
<td>20</td>
<td>Read(Y) = 20</td>
</tr>
<tr class="odd">
<td>Write(X， 70)</td>
<td>70</td>
<td>20</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>70</td>
<td>50</td>
<td>Write(Y， 50)</td>
</tr>
<tr class="odd">
<td>commit</td>
<td>70</td>
<td>50</td>
<td>commit</td>
</tr>
</tbody>
</table>
<p>最终X + Y &gt; 100，不满足业务规定的一致性。</p>
<h3 id="隔离级别解决的异常">隔离级别解决的异常</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 20%" />
<col style="width: 8%" />
<col style="width: 16%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>脏写</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>丢失更新</th>
<th>读偏斜</th>
<th>写偏斜</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读未提交</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>读已提交</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>快照隔离</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="even">
<td>可重复读</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>串行化</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<ul>
<li>解决：√</li>
</ul>
<h2 id="一致性-隔离级别">一致性 &amp; 隔离级别</h2>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240329120044065.png"
alt="衡量并发系统的模型" />
<figcaption aria-hidden="true">衡量并发系统的模型</figcaption>
</figure>
<h1 id="分布式共识">分布式共识</h1>
<h2 id="简介">简介</h2>
<h3 id="是什么">是什么</h3>
<p>共识：传统意义上的协商，指分布式结点之间通过消息传递，达到对某件事的共同认可。</p>
<p>数学定义：一个分布式系统包含N个进程，记为{0，1，2，3，4...n-1}，每个进程都有一个初始值，进程之间互相通信，设计一种共识算法使得尽管出现故障但进程之间仍能协商出某个不可撤销的最终决定值。<strong>每次执行</strong>满足以下：</p>
<ul>
<li>终止性：所有的进程最终都会认同一个值</li>
<li>协定性：正确的进程都会认同一个共同的值</li>
<li>完整性（有效性）：如果正确的进程都提议同一个值v，那么任何正确进程的最终决定值一定是γ</li>
</ul>
<h3 id="为什么">为什么</h3>
<p>分布式系统的几个主要难题：网络不可靠问题、时钟不一致问题和节点故障问题。解决以上问题常见的手段：状态机复制（S
M R）</p>
<p>状态机的概念：</p>
<ul>
<li>内容：一组状态、输入输出、转换函数、输出函数和独特的“初始状态”</li>
</ul>
<p>伪码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">state = init</span><br><span class="line">log = []</span><br><span class="line">while (true) &#123;</span><br><span class="line">	on receiving command from a client</span><br><span class="line">	log.append(cmd)</span><br><span class="line">	//生成新的状态</span><br><span class="line">	state， output = apply(cmd， state)</span><br><span class="line">	return output to client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现状态机需要多副本日志系统，而共识算法是其解决方案，并且共识算法使得每个副本对日志的值和顺序达成共识，这样整个集群看起来像是一个结点在工作。</p>
<h2 id="异步系统的共识">异步系统的共识</h2>
<h3 id="flp不可能定理">FLP不可能定理</h3>
<p>定义：在一个完全异步的分布式系统中，即使只有一个结点发生了故障，也不存在一个共识算法使得系统达到共识。</p>
<blockquote>
<p>在一个异步系统中，进程可以在任意时间返回响应，我们没有办法分辨一个进程是速度很慢还是己经崩溃。基于此，我们无法在有限时间内达成共识，这不满足终止性</p>
</blockquote>
<p>分布式共识算法需要两个属性：</p>
<ul>
<li>安全性：正确的进程，要认同同一个值</li>
<li>活性：系统最终会认同某一个值</li>
</ul>
<p>FLP定理实际上是强调：共识算法很难在以下条件下设计出来：</p>
<ul>
<li>一个完全异步的系统</li>
<li>系统发生故障</li>
<li>不可能有一个同时具备安全性、活性、容错性的共识算法</li>
</ul>
<p>绕过FLP定理的方法：将异步系统转化为同步系统，有如下方法</p>
<h4 id="故障屏蔽">故障屏蔽</h4>
<p>该方法假设故障的进程一定会复苏，并找到重回分布式系统的方法。如果没有受到该进程的任何信息，就一直等待。</p>
<p>实现方式：崩溃的进程具备自我恢复，重启等功能；重启前，进程会记录上下文信息，恢复时还能达到之前的状态。</p>
<h4 id="故障检测器">故障检测器</h4>
<p>常见的故障检测器如超时故障检测器，会在一定超时时间内，判断没有响应的进程是否崩溃。</p>
<p>故障检测器必须有的属性：</p>
<ul>
<li>完全性：每一个故障的进程都会被每一个正确的进程怀疑</li>
<li>精确性：正确的进程不会被别的进程怀疑</li>
</ul>
<p>完美的故障检测器无法实现，于是有最终弱故障检测器：</p>
<ul>
<li>最终弱完全性：每一个故障的进程都会被一些正确的进程怀疑</li>
<li>最终弱精确性：<strong>一段时间后</strong>，正确的进程不会被别的正确的进程怀疑</li>
</ul>
<p><img src="深入理解分布式系统-阅读笔记/image-20240408205900186.png" alt="故障检测器案例" style="zoom:80%;" /></p>
<h4 id="随机性算法">随机性算法</h4>
<p>随机算法的输出不仅取决于外部输入，还取决于执行过程中的随机概率，因此，给定两个完全相同的输入，该算法可能输出两个不同的值，随机性算法使得
“ 敌人”
不能有效地阻碍系统达成共识，即实现拜占庭容错，和传统选出领导节点再协作的模式不同，像区块链这类应用的共识是基于哪个节点最快计算出难题来达成的。</p>
<p>区块链中的每一个新区块都由本轮最快计算出数学难题的节点添加，整个分布式网络持续不断地建设这条有时间戳的区块链，而承载了最多计算量的区块链正是达成了共识的主链（即累积计算难度最大）。</p>
<h2 id="同步系统的共识">同步系统的共识</h2>
<p>实现同步系统共识的理论基础：同步系统中，有不超过f个进程发生故障，f
&lt; N，那经过f + 1轮消息最终会达成共识。</p>
<h3 id="paxos">Paxos</h3>
<p><strong>基本概念</strong></p>
<ul>
<li>提案：推动整个算法进行的消息
<ul>
<li>提案编号</li>
<li>提案值</li>
</ul></li>
</ul>
<p>系统角色：</p>
<ul>
<li>客户端：</li>
<li>提议者：收到</li>
<li>接收者 &amp; 投票者：</li>
<li>学习者：</li>
</ul>
<h4 id="算法会遇到的问题">算法会遇到的问题</h4>
<h4 id="实现流程">实现流程</h4>
<h5 id="阶段一">阶段一</h5>
<h5 id="阶段二">阶段二</h5>
<h4 id="案例">案例</h4>
<h4 id="活锁">活锁</h4>
<h4 id="go实现">Go实现</h4>
<h3 id="multi-paxos">Multi-Paxos</h3>
<h4 id="确定日志索引">确定日志索引</h4>
<h4 id="领导者选举">领导者选举</h4>
<h4 id="减少请求">减少请求</h4>
<h4 id="副本的完整性">副本的完整性</h4>
<h4 id="客户端请求">客户端请求</h4>
<h4 id="配置变更">配置变更</h4>
<h4 id="整体实现">整体实现</h4>
<h3 id="其它paxos变体">其它Paxos变体</h3>
<h3 id="raft">Raft</h3>
<p>Raft（{Reliable｜Replicated｜Redundant|}And Fault-Tolerant</p>
<p>像Multi-Paxos一样是基于领导者的算法。逻辑简单</p>
<h4 id="系统模型-1">系统模型</h4>
<ul>
<li>服务器可能宕机停止运行，过段时间再恢复，但系统不存在非拜占庭故障，即结点的行为是非恶意的。</li>
<li>可能存在网络分区</li>
<li>消息可能丢失、重复、乱序、延迟</li>
</ul>
<h4 id="算法基本概念">算法基本概念</h4>
<p><strong>状态</strong></p>
<p>任何时间段，Raft集群中每台服务器的状态只能是以下三种：</p>
<ul>
<li>领导者（Leader）：负责处理客户端的请求、日志复制；每个Term只有一个Leader</li>
<li>候选人（candidate）：权限介于领导者和追随者之间，候选者获取投票成功，晋升为领导者</li>
<li>跟随者（Follower）：完全被动的处理信息，只接受RPC请求，作出响应，不会主动发送任何消息</li>
</ul>
<p>状态伪码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">	Follower = <span class="literal">iota</span></span><br><span class="line">    Candidate</span><br><span class="line">    Leader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>任期</strong></p>
<p>Raft将时间抽象为一个个的任期（Term），代表一种逻辑时间，原来解决时序性问题。用数字代表任期号。</p>
<p>Raft服务器从Follow -&gt; Candidate
的时候，本身的任期+1，当集群选出了Leader，代表这个任期真正开始，开始处理客户端的请求。</p>
<figure>
<img src="深入理解分布式系统-阅读笔记/image-20240412210101898.png"
alt="任期" />
<figcaption aria-hidden="true">任期</figcaption>
</figure>
<p>每台服务器需要存储一个变量<code>CandidateId</code>代表当前服务器所处的任期。</p>
<p><strong>服务器之间的通信</strong></p>
<p>通过两个RPC：</p>
<ul>
<li><code>RequestVote</code>：用于领导者选举</li>
<li><code>AppendEntry</code>：用于日志复制、心跳检测</li>
</ul>
<h4 id="领导者选举-1">领导者选举</h4>
<p>何时开始选举？</p>
<p>每个服务器会定义一个<code>electionTimeout</code>（选举超时），当这个定时器定时结束后，当前服务器就会变成Candidate状态，向其它服务器发送请求投票，投票者超过半数，就晋升成Leader，为了保证leader的权威性，Leader会周期性的向其它服务结点发送心跳包。这个周期称为<code>HeartBeatTimeout</code>。</p>
<p>状态转换流程：</p>
<p><img src="深入理解分布式系统-阅读笔记/image-20240412210733654.png" alt="状态转换" style="zoom:80%;" /></p>
<p>如何设置两个超时时间？</p>
<ul>
<li><code>electionTimeout</code>：一般在100~500ms的范围</li>
<li><code>HeartBeatTimeout</code>：一定小于<code>electionTimeout</code>，保证当前Leader的权威，防止心跳失效，导致集群选举多个Leader，一般在50
- 100ms</li>
</ul>
<p><strong>选举流程</strong></p>
<p>节点开始竞选时：</p>
<ol type="1">
<li>状态变为Candidate</li>
<li>增加自己的任期</li>
<li>先给自己投一票</li>
<li>向其它结点发送RequestVote，RPC失效会重试</li>
<li>更新状态
<ol type="1">
<li>如果获得的票数超过集群总结点数目的半数以上，变为Leader状态，并发送心跳包</li>
<li>收到当前集群已经存在的Leader的AppendEntries，变为Follower</li>
<li>选举时间超时，没人获胜，等待下一个结点超时后的选举</li>
</ol></li>
</ol>
<p><img src="深入理解分布式系统-阅读笔记/image-20240412211441311.png" alt="选举流程" style="zoom:80%;" /></p>
<p><strong>保证一些特性</strong></p>
<p>选举过程中，需要保证的特性包括：</p>
<ul>
<li>活性：</li>
<li>安全性：一个任期内只有一个Leader选举出来
<ul>
<li>唯一投票：每个结点只允许投票一次。维护额外的变量votedFor，没有投票就为空，如果不为空，就不投给别人</li>
<li>过半投票胜出：这样保证不可能有两个节点同时胜出</li>
</ul></li>
</ul>
<h5 id="分割选票">分割选票</h5>
<p>原则上，结点可以无限期的分割选票。</p>
<p>假如全部结点同一时刻开始选举，瓜分选票，然后同一时间超时，继续瓜分......如此循环，类似Paxos活锁问题。这样集群就会失去活性。</p>
<p>解决方案：</p>
<p>采用随机超时时间，每个结点有选举的随机超时时间（150ms ~
300ms）。这种情况下出现分裂投票的可能性不大，满足活性。</p>
<h4 id="日志复制">日志复制</h4>
<p>每个结点有持久化的日志副本（log[]），日志条目格式如下：</p>
<ul>
<li>索引</li>
<li>任期号</li>
<li>命令：应用于状态机的命令</li>
</ul>
<p><strong>索引 + 任期号是日志的唯一标识。</strong></p>
<p><strong>提交日志</strong></p>
<p>如果一个日志条目被存储到大多数结点上，那么就可以把该日志提交。如果记录提交，就不能再改变，状态机可以安全的执行这个日志条目里的命令。</p>
<p><strong>日志复制的流程</strong></p>
<ol type="1">
<li>客户端向领导者发送命令，希望命令被所有结点执行</li>
<li>领导者先把命令转化为日志，追加自己的日志中，持久化</li>
<li>领导者并行向其它服务结点发送<code>AppendEntry</code></li>
<li>如果收到来自半数以上服务结点的正确响应，领导者认为这个日志应该提交。随后领导者将该命令应用到状态机，返回给客户端，并将应用的消息通知给其它结点。
<ul>
<li>领导者提交以后，会在之后的<code>AppendEntry</code>中加入变量
<code>LeaderCommit</code>，表示最新提交的日志最大索引。其他Follower都会把小于<code>LeaderCommit</code>的日志提交，应用命令到自己的状态机。</li>
</ul></li>
<li>跟随者宕机，Leader有定时器，超时会重复发送。</li>
<li>性能优化：领导者异步发送<code>AppendEntry</code>，这样只要超过半数的回应，即可响应客户端。</li>
</ol>
<h4 id="领导者更替">领导者更替</h4>
<h4 id="选举限制">选举限制</h4>
<h4 id="延迟提交之前任期的日志条目">延迟提交之前任期的日志条目</h4>
<h4 id="处理不一致的日志">处理不一致的日志</h4>
<h4 id="处理旧领导者">处理旧领导者</h4>
<h4 id="客户端协议">客户端协议</h4>
<h4 id="线性一致性的实现">线性一致性的实现</h4>
<h4 id="配置变更-1">配置变更</h4>
<h5 id="存在的bug">存在的bug</h5>
<h4 id="极端情况下的活性问题">极端情况下的活性问题</h4>
<h4 id="日志压缩">日志压缩</h4>
<h4 id="基于内存的状态机的快照">基于内存的状态机的快照</h4>
<h4 id="基于磁盘的状态机的快照">基于磁盘的状态机的快照</h4>
<h4 id="性能优化">性能优化</h4>
<h3 id="paxos-vs-raft">Paxos VS Raft</h3>
<h3 id="拜占庭容错和pbft">拜占庭容错和PBFT</h3>
<h1 id="分布式事务">分布式事务</h1>
<h2 id="是什么-1">是什么</h2>
<h2 id="原子提交算法-原子性">原子提交算法-原子性</h2>
<h3 id="两阶段提交">两阶段提交</h3>
<h3 id="三阶段提交">三阶段提交</h3>
<h3 id="paxos提交算法">Paxos提交算法</h3>
<h3 id="基于quorum的提交协议">基于Quorum的提交协议</h3>
<h3 id="saga事务">Saga事务</h3>
<h2 id="并发控制-隔离性">并发控制-隔离性</h2>
<p>除了原子性，分布式事务还需要实现隔离性。并发控制是一种隔离并发事务以保证数据正确性的机制。分为以下三类：</p>
<ul>
<li>悲观并发控制</li>
<li>乐观并发控制</li>
<li>多版本并发控制</li>
</ul>
<h3 id="两阶段锁">两阶段锁</h3>
<h3 id="乐观并发控制">乐观并发控制</h3>
<h3 id="多版本并发控制">多版本并发控制</h3>
<h4 id="多版本两阶段锁">多版本两阶段锁</h4>
<h4 id="多版本乐观并发控制">多版本乐观并发控制</h4>
<h4 id="多版本时间戳排序">多版本时间戳排序</h4>
<h4 id="版本存储垃圾回收">版本存储&amp;垃圾回收</h4>
<h1 id="时间和事件顺序">时间和事件顺序</h1>
<blockquote>

</blockquote>
<h2 id="物理时钟">物理时钟</h2>
<h2 id="时钟同步">时钟同步</h2>
<h2 id="逻辑时钟">逻辑时钟</h2>
<h2 id="向量时钟">向量时钟</h2>
<h2 id="分布式快照">分布式快照</h2>
<h1 id="常见分布式系统案例">常见分布式系统案例</h1>
<h2 id="分布式文件系统gfs">分布式文件系统GFS</h2>
<h3 id="gfs目标">GFS目标</h3>
<h3 id="gfs架构">GFS架构</h3>
<h3 id="读取文件">读取文件</h3>
<h3 id="写入文件">写入文件</h3>
<h3 id="一致性模型-1">一致性模型</h3>
<h3 id="其它特性">其它特性</h3>
<h2 id="分布式协调服务zookeeper">分布式协调服务Zookeeper</h2>
<h3 id="zookeeper架构">Zookeeper架构</h3>
<h3 id="数据模型">数据模型</h3>
<h3 id="实现-1">实现</h3>
<h3 id="客户端api">客户端API</h3>
<h3 id="其它">其它</h3>
<h4 id="批处理流水线">批处理、流水线</h4>
<h4 id="wait-free">wait-free</h4>
<h2 id="分布式表格存储bigtable">分布式表格存储Bigtable</h2>
<h3 id="数据模型-1">数据模型</h3>
<h3 id="架构">架构</h3>
<h3 id="sstable-和-lsm-tree">SSTable 和 LSM Tree</h3>
<h3 id="其它优化">其它优化</h3>
<h2 id="分布式键值存储dynamo">分布式键值存储Dynamo</h2>
<h3 id="架构-1">架构</h3>
<h3 id="请求协调">请求协调</h3>
<h3 id="成员管理和故障检测">成员管理和故障检测</h3>
<h2 id="分布式nosql数据库cassandra">分布式NoSQL数据库Cassandra</h2>
<h3 id="数据模型-2">数据模型</h3>
<h3 id="架构-2">架构</h3>
<h3 id="协调请求">协调请求</h3>
<h3 id="一致性级别">一致性级别</h3>
<h3 id="轻量级事务">轻量级事务</h3>
<h3 id="二级索引">二级索引</h3>
<h3 id="批处理">批处理</h3>
<h2 id="分布式数据库spanner">分布式数据库Spanner</h2>
<h3 id="数据模型-3">数据模型</h3>
<h3 id="架构-3">架构</h3>
<h3 id="truetime">TrueTime</h3>
<h3 id="读写事务">读写事务</h3>
<h3 id="只读事务">只读事务</h3>
<h3 id="快照读和模式变更事务">快照读和模式变更事务</h3>
<h2 id="分布式批处理">分布式批处理</h2>
<h3 id="mapreduce">MapReduce</h3>
<h3 id="spark">Spark</h3>
<h2 id="分布式流处理flink">分布式流处理Flink</h2>
<h3 id="计算模型">计算模型</h3>
<h3 id="架构-4">架构</h3>
<h3 id="时间处理">时间处理</h3>
<h3 id="分布式快照-1">分布式快照</h3>
<h3 id="精确一次语义">精确一次语义</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io">Vlong_shen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vlsmhd.github.io/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">https://vlsmhd.github.io/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vlsmhd.github.io" target="_blank">VLS_Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/" title="软件测试入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">软件测试入门</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/19/%E9%AB%98%E6%80%A7%E8%83%BDIM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="高性能IM即时通讯系统设计"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高性能IM即时通讯系统设计</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vlong_shen</div><div class="author-info__description">一名热爱编程的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/VLSmhd"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VLSmhd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/-" target="_blank" title="联系我QQ：1067853293"><i class="fab fa-qq"></i></a><a class="social-icon" href="/-" target="_blank" title="微信：18956757208"><i class="fa fa-wechat"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">认识分布式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是分布式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么需要分布式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">分布式系统的挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">网络延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E7%BB%93%E7%82%B9%E5%A4%B1%E6%95%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">部分结点失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">时钟问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">程序员需要了解的数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">分布式系统模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">两将军问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">拜占庭将军问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">系统模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">网络链路模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E9%93%BE%E8%B7%AF%E5%AE%8C%E7%BE%8E%E9%93%BE%E8%B7%AF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">可靠链路（完美链路）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E6%8D%9F%E5%A4%B1%E9%93%BE%E8%B7%AF"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">公平损失链路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E9%93%BE%E8%B7%AF"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">任意链路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">链路的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%95%85%E9%9A%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">节点故障类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83-%E5%81%9C%E6%AD%A2"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">崩溃-停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83-%E6%81%A2%E5%A4%8D"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">崩溃-恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E6%95%85%E9%9A%9C"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">拜占庭故障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%97%B6%E9%97%B4%E5%88%92%E5%88%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">按时间划分模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">同步系统模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">异步系统模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">部分同步模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%AD%E4%B9%89"><span class="toc-number">2.4.</span> <span class="toc-text">消息传递语义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">分布式数据基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.</span> <span class="toc-text">分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.1.</span> <span class="toc-text">垂直分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text">水平分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">范围分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">哈希分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">一致性hash算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">3.1.3.</span> <span class="toc-text">分区的挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">单主复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">同步复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">异步复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">半同步复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">多主复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">数据冲突问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">无主复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Equorum%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">基于Quorum的数据冗余机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap%E5%AE%9A%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">CAP定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pacelc%E5%AE%9A%E7%90%86"><span class="toc-number">3.3.1.</span> <span class="toc-text">PACELC定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#base"><span class="toc-number">3.3.2.</span> <span class="toc-text">BASE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">一致性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">以数据为中心的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">线性一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.1.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E4%BB%B7"><span class="toc-number">3.4.1.1.2.</span> <span class="toc-text">代价</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">顺序一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">因果一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">最终一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">以客户端为中心的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E8%AF%BB"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">单调读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E5%86%99"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">单调写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E4%BD%A0%E6%89%80%E5%86%99"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">读你所写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pram%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">PRAM一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%90%8E%E5%86%99"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">读后写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.5.</span> <span class="toc-text">隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="toc-number">3.5.1.</span> <span class="toc-text">常见的事务异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E5%86%99%E8%84%8F%E8%AF%BB"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">脏写脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%A8%A1%E7%B3%8A%E8%AF%BB"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">不可重复读（模糊读）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">幻读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">丢失更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%81%8F%E6%96%9C"><span class="toc-number">3.5.1.5.</span> <span class="toc-text">读写偏斜</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%A7%A3%E5%86%B3%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">3.5.2.</span> <span class="toc-text">隔离级别解决的异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">一致性 &amp; 隔离级别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86"><span class="toc-number">4.</span> <span class="toc-text">分布式共识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.2.</span> <span class="toc-text">为什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B1%E8%AF%86"><span class="toc-number">4.2.</span> <span class="toc-text">异步系统的共识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flp%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9A%E7%90%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">FLP不可能定理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E5%B1%8F%E8%94%BD"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">故障屏蔽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E5%99%A8"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">故障检测器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">随机性算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B1%E8%AF%86"><span class="toc-number">4.3.</span> <span class="toc-text">同步系统的共识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#paxos"><span class="toc-number">4.3.1.</span> <span class="toc-text">Paxos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">算法会遇到的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">实现流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80"><span class="toc-number">4.3.1.2.1.</span> <span class="toc-text">阶段一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C"><span class="toc-number">4.3.1.2.2.</span> <span class="toc-text">阶段二</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">Go实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multi-paxos"><span class="toc-number">4.3.2.</span> <span class="toc-text">Multi-Paxos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%97%A5%E5%BF%97%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">确定日志索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">领导者选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E8%AF%B7%E6%B1%82"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">减少请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">副本的完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">客户端请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4"><span class="toc-number">4.3.2.6.</span> <span class="toc-text">配置变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.2.7.</span> <span class="toc-text">整体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83paxos%E5%8F%98%E4%BD%93"><span class="toc-number">4.3.3.</span> <span class="toc-text">其它Paxos变体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raft"><span class="toc-number">4.3.4.</span> <span class="toc-text">Raft</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">系统模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">算法基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE-1"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">领导者选举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E9%80%89%E7%A5%A8"><span class="toc-number">4.3.4.3.1.</span> <span class="toc-text">分割选票</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">日志复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85%E6%9B%B4%E6%9B%BF"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">领导者更替</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6"><span class="toc-number">4.3.4.6.</span> <span class="toc-text">选举限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.3.4.7.</span> <span class="toc-text">延迟提交之前任期的日志条目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.4.8.</span> <span class="toc-text">处理不一致的日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A7%E9%A2%86%E5%AF%BC%E8%80%85"><span class="toc-number">4.3.4.9.</span> <span class="toc-text">处理旧领导者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.4.10.</span> <span class="toc-text">客户端协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.4.11.</span> <span class="toc-text">线性一致性的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4-1"><span class="toc-number">4.3.4.12.</span> <span class="toc-text">配置变更</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84bug"><span class="toc-number">4.3.4.12.1.</span> <span class="toc-text">存在的bug</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B4%BB%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.4.13.</span> <span class="toc-text">极端情况下的活性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.3.4.14.</span> <span class="toc-text">日志压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%BF%AB%E7%85%A7"><span class="toc-number">4.3.4.15.</span> <span class="toc-text">基于内存的状态机的快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%A3%81%E7%9B%98%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%BF%AB%E7%85%A7"><span class="toc-number">4.3.4.16.</span> <span class="toc-text">基于磁盘的状态机的快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.4.17.</span> <span class="toc-text">性能优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#paxos-vs-raft"><span class="toc-number">4.3.5.</span> <span class="toc-text">Paxos VS Raft</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E5%92%8Cpbft"><span class="toc-number">4.3.6.</span> <span class="toc-text">拜占庭容错和PBFT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">5.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">原子提交算法-原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">5.2.1.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">5.2.2.</span> <span class="toc-text">三阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#paxos%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text">Paxos提交算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Equorum%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.4.</span> <span class="toc-text">基于Quorum的提交协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#saga%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.2.5.</span> <span class="toc-text">Saga事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">并发控制-隔离性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="toc-number">5.3.1.</span> <span class="toc-text">两阶段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">乐观并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.3.</span> <span class="toc-text">多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">多版本两阶段锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">多版本乐观并发控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.3.3.</span> <span class="toc-text">多版本时间戳排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%AD%98%E5%82%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">5.3.3.4.</span> <span class="toc-text">版本存储&amp;垃圾回收</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">时间和事件顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F"><span class="toc-number">6.1.</span> <span class="toc-text">物理时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5"><span class="toc-number">6.2.</span> <span class="toc-text">时钟同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F"><span class="toc-number">6.3.</span> <span class="toc-text">逻辑时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F"><span class="toc-number">6.4.</span> <span class="toc-text">向量时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7"><span class="toc-number">6.5.</span> <span class="toc-text">分布式快照</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">常见分布式系统案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fgfs"><span class="toc-number">7.1.</span> <span class="toc-text">分布式文件系统GFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gfs%E7%9B%AE%E6%A0%87"><span class="toc-number">7.1.1.</span> <span class="toc-text">GFS目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gfs%E6%9E%B6%E6%9E%84"><span class="toc-number">7.1.2.</span> <span class="toc-text">GFS架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.3.</span> <span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.4.</span> <span class="toc-text">写入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">7.1.5.</span> <span class="toc-text">一致性模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7"><span class="toc-number">7.1.6.</span> <span class="toc-text">其它特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper"><span class="toc-number">7.2.</span> <span class="toc-text">分布式协调服务Zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zookeeper%E6%9E%B6%E6%9E%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">Zookeeper架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">7.2.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFapi"><span class="toc-number">7.2.4.</span> <span class="toc-text">客户端API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">7.2.5.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">批处理、流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-free"><span class="toc-number">7.2.5.2.</span> <span class="toc-text">wait-free</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8bigtable"><span class="toc-number">7.3.</span> <span class="toc-text">分布式表格存储Bigtable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">7.3.1.</span> <span class="toc-text">数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">7.3.2.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sstable-%E5%92%8C-lsm-tree"><span class="toc-number">7.3.3.</span> <span class="toc-text">SSTable 和 LSM Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.4.</span> <span class="toc-text">其它优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8dynamo"><span class="toc-number">7.4.</span> <span class="toc-text">分布式键值存储Dynamo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84-1"><span class="toc-number">7.4.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%B0%83"><span class="toc-number">7.4.2.</span> <span class="toc-text">请求协调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B"><span class="toc-number">7.4.3.</span> <span class="toc-text">成员管理和故障检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fnosql%E6%95%B0%E6%8D%AE%E5%BA%93cassandra"><span class="toc-number">7.5.</span> <span class="toc-text">分布式NoSQL数据库Cassandra</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-2"><span class="toc-number">7.5.1.</span> <span class="toc-text">数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84-2"><span class="toc-number">7.5.2.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E8%AF%B7%E6%B1%82"><span class="toc-number">7.5.3.</span> <span class="toc-text">协调请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E7%BA%A7%E5%88%AB"><span class="toc-number">7.5.4.</span> <span class="toc-text">一致性级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.5.5.</span> <span class="toc-text">轻量级事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.6.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">7.5.7.</span> <span class="toc-text">批处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93spanner"><span class="toc-number">7.6.</span> <span class="toc-text">分布式数据库Spanner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-3"><span class="toc-number">7.6.1.</span> <span class="toc-text">数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84-3"><span class="toc-number">7.6.2.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#truetime"><span class="toc-number">7.6.3.</span> <span class="toc-text">TrueTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.6.4.</span> <span class="toc-text">读写事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.6.5.</span> <span class="toc-text">只读事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8F%98%E6%9B%B4%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.6.6.</span> <span class="toc-text">快照读和模式变更事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">7.7.</span> <span class="toc-text">分布式批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mapreduce"><span class="toc-number">7.7.1.</span> <span class="toc-text">MapReduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spark"><span class="toc-number">7.7.2.</span> <span class="toc-text">Spark</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E5%A4%84%E7%90%86flink"><span class="toc-number">7.8.</span> <span class="toc-text">分布式流处理Flink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.8.1.</span> <span class="toc-text">计算模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84-4"><span class="toc-number">7.8.2.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">7.8.3.</span> <span class="toc-text">时间处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7-1"><span class="toc-number">7.8.4.</span> <span class="toc-text">分布式快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E4%B8%80%E6%AC%A1%E8%AF%AD%E4%B9%89"><span class="toc-number">7.8.5.</span> <span class="toc-text">精确一次语义</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/31/Spring%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Spring深度学习">Spring深度学习</a><time datetime="2024-03-31T11:41:11.573Z" title="发表于 2024-03-31 19:41:11">2024-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/" title="软件测试入门">软件测试入门</a><time datetime="2024-03-27T07:10:53.727Z" title="发表于 2024-03-27 15:10:53">2024-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="深入理解分布式系统-阅读笔记">深入理解分布式系统-阅读笔记</a><time datetime="2024-03-26T03:26:08.300Z" title="发表于 2024-03-26 11:26:08">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/19/%E9%AB%98%E6%80%A7%E8%83%BDIM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="高性能IM即时通讯系统设计">高性能IM即时通讯系统设计</a><time datetime="2024-03-19T13:31:13.565Z" title="发表于 2024-03-19 21:31:13">2024-03-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/15/Leetcode-SQL%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/" title="leetcode-SQL专项训练">leetcode-SQL专项训练</a><time datetime="2024-03-15T14:04:55.480Z" title="发表于 2024-03-15 22:04:55">2024-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Vlong_shen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>